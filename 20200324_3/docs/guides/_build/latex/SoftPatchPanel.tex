%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,11pt,openany,oneside,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[english]{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\RecustomVerbatimEnvironment{Verbatim}{Verbatim}{xleftmargin=5mm}


\title{Soft Patch Panel Documentation}
\date{Mar 24, 2020}
\release{19.08}
\author{}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Overview}
\label{\detokenize{overview:overview}}\label{\detokenize{overview:spp-overview-overview}}\label{\detokenize{overview::doc}}
\sphinxhref{http://dpdk.org/browse/apps/spp/}{Soft Patch Panel}
(SPP) is a DPDK application for providing switching
functionality for Service Function Chaining in
NFV (Network Function Virtualization).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{spp_overview}.pdf}
\caption{SPP overview}\label{\detokenize{overview:id1}}\end{figure}

With SPP, user is able to configure network easily and dynamically
via simple patch panel like interface.

The goal of SPP is to easily interconnect NFV applications via high
thoughput network interfaces provided by DPDK and change configurations
of resources dynamically to applications to build pipelines.


\chapter{Design}
\label{\detokenize{design/index:design}}\label{\detokenize{design/index:spp-design-index}}\label{\detokenize{design/index::doc}}

\section{Soft Patch Panel}
\label{\detokenize{design/spp:soft-patch-panel}}\label{\detokenize{design/spp:spp-overview-design}}\label{\detokenize{design/spp::doc}}
SPP is composed of several DPDK processes and controller processes for
connecting each of client processes with high-throughput path of DPDK.
\hyperref[\detokenize{design/spp:figure-spp-overview-design-all}]{Fig.\@ \ref{\detokenize{design/spp:figure-spp-overview-design-all}}} shows SPP processes and client apps
for describing overview of design of SPP. In this diagram, solid line arrows
describe a data path for packet forwarding and it can be configured from
controller via command messaging of blue dashed line arrows.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.850\linewidth]{{spp_overview_design_all}.pdf}
\caption{Overview of design of SPP}\label{\detokenize{design/spp:id2}}\label{\detokenize{design/spp:figure-spp-overview-design-all}}\end{figure}

In terms of DPDK processes, SPP is derived from DPDK’s multi-process sample
application and it consists of a primary process and multiple secondary
processes.
SPP primary process is responsible for resource management, for example,
initializing ports, mbufs or shared memory. On the other hand,
secondary processes of \sphinxcode{\sphinxupquote{spp\_nfv}} are working for forwarding
\sphinxhref{https://dpdksummit.com/Archive/pdf/2017USA/Implementation\%20and\%20Testing\%20of\%20Soft\%20Patch\%20Panel.pdf}{{[}1{]}}.


\subsection{Reference}
\label{\detokenize{design/spp:reference}}\begin{itemize}
\item {} 
{[}1{]} \sphinxhref{https://dpdksummit.com/Archive/pdf/2017USA/Implementation\%20and\%20Testing\%20of\%20Soft\%20Patch\%20Panel.pdf}{Implementation and Testing of Soft Patch Panel}

\end{itemize}


\section{SPP Controller}
\label{\detokenize{design/spp_controller:spp-controller}}\label{\detokenize{design/spp_controller:spp-overview-spp-controller}}\label{\detokenize{design/spp_controller::doc}}
SPP is controlled from python based management framework. It consists of
front-end CLI and back-end server process.
SPP’s front-end CLI provides a patch panel like interface for users.
This CLI process parses user input and sends request to the back-end via REST
APIs. It means that the back-end server process accepts requests from other
than CLI. It enables developers to implement control interface such as GUI, or
plugin for other framework.
\sphinxhref{https://github.com/openstack/networking-spp}{networking-spp}
is a Neutron ML2 plugin for using SPP with OpenStack.
By using networking-spp and doing some of extra tunings for optimization, you
can deploy high-performance NFV services on OpenStack
\sphinxhref{https://www.openstack.org/summit/vancouver-2018/summit-schedule/events/20826}{{[}1{]}}.


\subsection{spp-ctl}
\label{\detokenize{design/spp_controller:spp-ctl}}
\sphinxcode{\sphinxupquote{spp-ctl}} is designed for managing SPP from several controllers
via REST-like APIs for users or other applications.
It is implemented to be simple and it is stateless.
Basically, it only converts a request into a command of SPP process and
forward it to the process without any of syntax or lexical checking.

There are several usecases where SPP is managed from other process without
user inputs. For example, you need a intermediate process if you think of
using SPP from a framework, such as OpenStack.
\sphinxhref{https://github.com/openstack/networking-spp}{networking-spp}
is a Neutron ML2 plugin for SPP and \sphinxtitleref{spp-agent} works as a SPP controller.

As shown in \hyperref[\detokenize{design/spp_controller:figure-spp-overview-design-spp-ctl}]{Fig.\@ \ref{\detokenize{design/spp_controller:figure-spp-overview-design-spp-ctl}}},
\sphinxcode{\sphinxupquote{spp-ctl}} behaves as a TCP server for SPP primary and secondary processes,
and REST API server for client applications.
It should be launched in advance to setup connections with other processes.
\sphinxcode{\sphinxupquote{spp-ctl}}  uses three TCP ports for primary, secondaries and clients.
The default port numbers are \sphinxcode{\sphinxupquote{5555}}, \sphinxcode{\sphinxupquote{6666}} and \sphinxcode{\sphinxupquote{7777}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.480\linewidth]{{spp_overview_design_spp-ctl}.pdf}
\caption{Spp-ctl as a REST API server}\label{\detokenize{design/spp_controller:id3}}\label{\detokenize{design/spp_controller:figure-spp-overview-design-spp-ctl}}\end{figure}

\sphinxcode{\sphinxupquote{spp-ctl}} accepts multiple requests at the same time and serializes them
by using
\sphinxhref{https://bottlepy.org/docs/dev/}{bottle}
which is simple and well known as a web framework and
\sphinxhref{http://eventlet.net/}{eventlet}
for parallel processing.


\subsection{SPP CLI}
\label{\detokenize{design/spp_controller:spp-cli}}
SPP CLI is a user interface for managing SPP and implemented as a client of
\sphinxcode{\sphinxupquote{spp-ctl}}. It provides several kinds of command for inspecting SPP
processes, changing path configuration or showing statistics of packets.
However, you do not need to use SPP CLI if you use \sphinxcode{\sphinxupquote{netowrking-spp}} or
other client applications of \sphinxcode{\sphinxupquote{spp-ctl}}. SPP CLI is one of them.

From SPP CLI, user is able to configure paths as similar as
patch panel like manner by sending commands to each of SPP secondary processes.
\sphinxcode{\sphinxupquote{patch phy:0 ring:0}} is to connect two ports, \sphinxcode{\sphinxupquote{phy:0}} and \sphinxcode{\sphinxupquote{ring:0}}.

As described in {\hyperref[\detokenize{gsg/howto_use:spp-setup-howto-use-spp-cli}]{\sphinxcrossref{\DUrole{std,std-ref}{Getting Started}}}} guide,
SPP CLI is able to communicate several \sphinxcode{\sphinxupquote{spp-ctl}} to support multiple nodes
configuration.


\subsection{Reference}
\label{\detokenize{design/spp_controller:reference}}\begin{itemize}
\item {} 
{[}1{]} \sphinxhref{https://www.openstack.org/summit/vancouver-2018/summit-schedule/events/20826}{Integrating OpenStack with DPDK for High Performance Applications}

\end{itemize}


\section{SPP Primary}
\label{\detokenize{design/spp_primary:spp-primary}}\label{\detokenize{design/spp_primary:spp-overview-design-spp-primary}}\label{\detokenize{design/spp_primary::doc}}
SPP is originally derived from
\sphinxhref{https://doc.dpdk.org/guides/sample\_app\_ug/multi\_process.html\#client-server-multi-process-example}{Client-Server Multi-process Example}
of
\sphinxhref{https://doc.dpdk.org/guides/sample\_app\_ug/multi\_process.html}{Multi-process Sample Application}
in DPDK’s sample applications.
\sphinxcode{\sphinxupquote{spp\_primary}} is a server for other secondary processes and
basically working same as described in
“How the Application Works” section of the sample application.

However, there are some differences between \sphinxcode{\sphinxupquote{spp\_primary}} and
the server process of the sample application.
\sphinxcode{\sphinxupquote{spp\_primary}} has no limitation of the number of secondary processes.
It does not work for packet forwaring without in some usecases, but just
provide rings and memory pools for secondary processes.


\subsection{Master and Worker Threads}
\label{\detokenize{design/spp_primary:master-and-worker-threads}}
In SPP, Both of primary and secondary processes consist of master thread and
worker thread as slave. Master thread is for accepting commands from a user
for doing task, and running on a master lcore. On the other hand,
slave thread is for packet forwarding or other process specific jobs
as worker, and running on slave lcore. Only slave thread requires
dedicated core for running in pole mode, and launched from
\sphinxcode{\sphinxupquote{rte\_eal\_remote\_launch()}} or \sphinxcode{\sphinxupquote{rte\_eal\_mp\_remote\_launch()}}.

\sphinxcode{\sphinxupquote{spp\_primary}} is able to run with or without worker thread selectively,
and requires at least one lcore for server process.
Using worker thread or not depends on your usecases.
\sphinxcode{\sphinxupquote{spp\_primary}} provides two types of workers currently.


\subsection{Worker Types}
\label{\detokenize{design/spp_primary:worker-types}}
There are two types of worker thread in \sphinxcode{\sphinxupquote{spp\_primary}}. First one is
is forwarder thread, and second one is monitor thread.

As default, \sphinxcode{\sphinxupquote{spp\_primary}} runs packet forwarder if two or more lcores
are given while launching the process. Behavior of this forwarder is
same as \sphinxcode{\sphinxupquote{spp\_nfv}} described in the next section.
This forwarder provides features for managing ports, patching them and
forwarding packets between ports.
It is useful for very simple usecase in which only few ports are patched
and no need to do forwarding packets in parallel with several processes.

\begin{sphinxadmonition}{note}{Note:}
In DPDK v18.11 or later, some of PMDs, such as vhost, do not work for
multi-process application. It means that packets cannot forwarded
to a VM or container via secondary process in SPP.
In this case, you use forwarder in \sphinxcode{\sphinxupquote{spp\_primary}}.
\end{sphinxadmonition}

Another type is monitor for displaying status of \sphinxcode{\sphinxupquote{spp\_primary}} in which
statistics of RX and TX packets on each of physical ports and ring ports
are shown periodically in terminal \sphinxcode{\sphinxupquote{spp\_primary}} is launched.
Although statistics can be referred in SPP CLI by using \sphinxcode{\sphinxupquote{pri; status}}
command, running monitor thread is useful if you always watch statistics.


\section{SPP Secondary}
\label{\detokenize{design/spp_secondary:spp-secondary}}\label{\detokenize{design/spp_secondary:spp-design-spp-sec}}\label{\detokenize{design/spp_secondary::doc}}
SPP secondary process is a worker process in client-server multp-process
application model. Basically, the role of secondary process is to connenct
each of application running on host, containers or VMs for packet forwarding.
Spp secondary process forwards packets from source port to destination port
with DPDK’s high-performance forwarding mechanizm. In other word, it behaves
as a cable to connect two patches ports.

All of secondary processes are able to attach ring PMD and vhost PMD ports
for sending or receiving packets with other processes. Ring port is used to
communicate with a process running on host or container if it is implemented
as secondary process to access shared ring memory.
Vhost port is used for a process on container or VM and implemented as primary
process, and no need to access shared memory of SPP primary.

In addition to the basic forwarding, SPP secondary process provides several
networking features. One of the typical example is packet cauture.
\sphinxcode{\sphinxupquote{spp\_nfv}} is the simplest SPP secondary and used to connect two of processes
or other feature ports including PCAP PMD port. PCAP PMD is to dump packets to
a file or retrieve from.

There are more specific or funcional features than \sphinxcode{\sphinxupquote{spp\_nfv}}. \sphinxcode{\sphinxupquote{spp\_vf}} is
a simple pseudo SR-IOV feature for classifying or merging packets.
\sphinxcode{\sphinxupquote{spp\_mirror}} is to duplicate incoming packets to several destination ports.


\subsection{spp\_nfv}
\label{\detokenize{design/spp_secondary:spp-nfv}}\label{\detokenize{design/spp_secondary:spp-design-spp-sec-nfv}}
\sphinxcode{\sphinxupquote{spp\_nfv}} is the simplest SPP secondary to connect two of processes or other
feature ports. Each of \sphinxcode{\sphinxupquote{spp\_nfv}} processes has a list of entries including
source and destination ports, and forwards packets by referring the list.
It means that one \sphinxcode{\sphinxupquote{spp\_nfv}} might have several forwarding paths, but
throughput is gradually decreased if it has too much paths.
This list is implemented as an array of \sphinxcode{\sphinxupquote{port}} structure and named
\sphinxcode{\sphinxupquote{ports\_fwd\_array}}. The index of \sphinxcode{\sphinxupquote{ports\_fwd\_array}} is the same as unique
port ID.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k}{struct} \PYG{n}{port} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{in\PYGZus{}port\PYGZus{}id}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{out\PYGZus{}port\PYGZus{}id}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{c+cm}{/* ports\PYGZus{}fwd\PYGZus{}array is an array of port */}
\PYG{k}{static} \PYG{k}{struct} \PYG{n}{port} \PYG{n}{ports\PYGZus{}fwd\PYGZus{}array}\PYG{p}{[}\PYG{n}{RTE\PYGZus{}MAX\PYGZus{}ETHPORTS}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\hyperref[\detokenize{design/spp_secondary:figure-design-spp-sec-nfv-port-fwd-array}]{Fig.\@ \ref{\detokenize{design/spp_secondary:figure-design-spp-sec-nfv-port-fwd-array}}} describes an example of
forwarding between ports. In this case, \sphinxcode{\sphinxupquote{spp\_nfv}} is responsible for
forwarding from \sphinxcode{\sphinxupquote{port\#0}} to \sphinxcode{\sphinxupquote{port\#2}}. You notice that each of \sphinxcode{\sphinxupquote{out\_port}}
entry has the destination port ID.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.800\linewidth]{{spp_design_spp_sec_nfv}.pdf}
\caption{Forwarding by referring ports\_fwd\_array}\label{\detokenize{design/spp_secondary:id1}}\label{\detokenize{design/spp_secondary:figure-design-spp-sec-nfv-port-fwd-array}}\end{figure}

\sphinxcode{\sphinxupquote{spp\_nfv}} consists of main thread and worker thread to update the entry
while running the process. Main thread is for waiting user command for
updating the entry. Worker thread is for dedicating packet forwarding.
\hyperref[\detokenize{design/spp_secondary:figure-design-spp-sec-nfv-threads}]{Fig.\@ \ref{\detokenize{design/spp_secondary:figure-design-spp-sec-nfv-threads}}} describes tasks in each of
threads. Worker thread is launched from main thread after initialization.
In worker thread, it starts forwarding if user send forward command and
main thread accepts it.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{spp_design_spp_sec_nfv_threads}.pdf}
\caption{Main thread and worker thread in spp\_nfv}\label{\detokenize{design/spp_secondary:id2}}\label{\detokenize{design/spp_secondary:figure-design-spp-sec-nfv-threads}}\end{figure}


\subsection{spp\_vf}
\label{\detokenize{design/spp_secondary:spp-vf}}\label{\detokenize{design/spp_secondary:spp-design-spp-sec-vf}}
\sphinxcode{\sphinxupquote{spp\_vf}} provides a SR-IOV like network feature.

\sphinxcode{\sphinxupquote{spp\_vf}} forwards incoming packets to several destination VMs by referring
MAC address like as a Virtual Function (VF) of SR-IOV.

\sphinxcode{\sphinxupquote{spp\_vf}} is a  multi-process and multi-thread application.
Each of \sphinxcode{\sphinxupquote{spp\_vf}} has one manager thread and worker threads called as
components.
The manager thread provides a function for parsing a command and creating the
components.
The component threads have its own multiple components, ports and classifier
tables including Virtual MAC address.
There are three types of components, \sphinxcode{\sphinxupquote{forwarder}},
\sphinxcode{\sphinxupquote{merger}} and \sphinxcode{\sphinxupquote{classifier}}.

This is an example of network configuration, in which one
\sphinxcode{\sphinxupquote{classifier}},
one merger and four forwarders are running in \sphinxcode{\sphinxupquote{spp\_vf}} process
for two destinations of vhost interface.
Incoming packets from rx on host1 are sent to each of vhosts of VM
by looking up destination MAC address in the packet.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.720\linewidth]{{spp_vf_overview}.pdf}
\caption{Classification of spp\_vf for two VMs}\label{\detokenize{design/spp_secondary:id3}}\end{figure}


\subsubsection{Forwarder}
\label{\detokenize{design/spp_secondary:forwarder}}
Simply forwards packets from rx to tx port.
Forwarder does not start forwarding until when at least one rx and one tx are
added.


\subsubsection{Merger}
\label{\detokenize{design/spp_secondary:merger}}
Receives packets from multiple rx ports to aggregate
packets and sends to a desctination port.
Merger does not start forwarding until when at least two rx and one tx are
added.


\subsubsection{Classifier}
\label{\detokenize{design/spp_secondary:classifier}}
Sends packets to multiple tx ports based on entries of
MAC address and destination port in a classifier table.
This component also supports VLAN tag.

For VLAN addressing, classifier has other tables than defalut.
Classifier prepares tables for each of VLAN ID and decides
which of table is referred
if TPID (Tag Protocol Indetifier) is included in a packet and
equals to 0x8100 as defined in IEEE 802.1Q standard.
Classifier does not start forwarding until when at least one rx and two tx
are added.


\subsection{spp\_mirror}
\label{\detokenize{design/spp_secondary:spp-mirror}}\label{\detokenize{design/spp_secondary:spp-design-spp-sec-mirror}}
\sphinxcode{\sphinxupquote{spp\_mirror}} is an implementation of
\sphinxhref{https://docs.openstack.org/dragonflow/latest/specs/tap\_as\_a\_service.html}{TaaS}
as a SPP secondary process for port mirroring.
TaaS stands for TAP as a Service.
The keyword \sphinxcode{\sphinxupquote{mirror}} means that it duplicates incoming packets and forwards
to additional destination.


\subsubsection{Mirror}
\label{\detokenize{design/spp_secondary:mirror}}
\sphinxcode{\sphinxupquote{mirror}} component has one \sphinxcode{\sphinxupquote{rx}} port and two \sphinxcode{\sphinxupquote{tx}} ports. Incoming packets
from \sphinxcode{\sphinxupquote{rx}} port are duplicated and sent to each of \sphinxcode{\sphinxupquote{tx}} ports.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{spp_mirror_design}.pdf}
\caption{Spp\_mirror component}\label{\detokenize{design/spp_secondary:id4}}\label{\detokenize{design/spp_secondary:figure-spp-mirror-design}}\end{figure}

In general, copying packet is time-consuming because it requires to make a new
region on memory space. Considering to minimize impact for performance,
\sphinxcode{\sphinxupquote{spp\_mirror}} provides a choice of copying methods, \sphinxcode{\sphinxupquote{shallowocopy}} or
\sphinxcode{\sphinxupquote{deepcopy}}.
The difference between those methods is \sphinxcode{\sphinxupquote{shallowocopy}} does not copy whole of
packet data but share without header actually.
\sphinxcode{\sphinxupquote{shallowcopy}} is to share mbuf between packets to get better performance
than \sphinxcode{\sphinxupquote{deepcopy}}, but it should be used for read only for the packet.

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{shallowcopy}} calls \sphinxcode{\sphinxupquote{rte\_pktmbuf\_clone()}} internally and
\sphinxcode{\sphinxupquote{deepcopy}} create a new mbuf region.
\end{sphinxadmonition}

You should choose \sphinxcode{\sphinxupquote{deepcopy}} if you use VLAN feature to make no change for
original packet while copied packet is modified.


\subsection{spp\_pcap}
\label{\detokenize{design/spp_secondary:spp-pcap}}\label{\detokenize{design/spp_secondary:spp-design-spp-sec-pcap}}
SPP provides a connectivity between VM and NIC as a virtual patch panel.
However, for more practical use, operator and/or developer needs to capture
packets. For such use, spp\_pcap provides packet capturing feature from
specific port. It is aimed to capture up to 10Gbps packets.

\sphinxcode{\sphinxupquote{spp\_pcap}} is a SPP secondary process for capturing packets from specific
\sphinxcode{\sphinxupquote{port}}. \hyperref[\detokenize{design/spp_secondary:figure-spp-pcap-overview}]{Fig.\@ \ref{\detokenize{design/spp_secondary:figure-spp-pcap-overview}}} shows an overview of use of
\sphinxcode{\sphinxupquote{spp\_pcap}} in which \sphinxcode{\sphinxupquote{spp\_pcap}} process receives packets from \sphinxcode{\sphinxupquote{phy:0}}
for capturing.

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{spp\_pcap}} supports only two types of ports for capturing, \sphinxcode{\sphinxupquote{phy}}
and \sphinxcode{\sphinxupquote{ring}}, currently.
\end{sphinxadmonition}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{spp_pcap_overview}.pdf}
\caption{Overview of spp\_pcap}\label{\detokenize{design/spp_secondary:id5}}\label{\detokenize{design/spp_secondary:figure-spp-pcap-overview}}\end{figure}

\sphinxcode{\sphinxupquote{spp\_pcap}} cosisits of main thread, \sphinxcode{\sphinxupquote{receiver}} thread and one or more
\sphinxcode{\sphinxupquote{wirter}} threads. As design policy, the number of \sphinxcode{\sphinxupquote{receiver}} is fixed
to 1 because to make it simple and it is enough for task of receiving.
\sphinxcode{\sphinxupquote{spp\_pcap}} requires at least three lcores, and assign to from master,
\sphinxcode{\sphinxupquote{receiver}} and then the rest of \sphinxcode{\sphinxupquote{writer}} threads respectively.

Incoming packets are received by \sphinxcode{\sphinxupquote{receiver}} thread and transferred to
\sphinxcode{\sphinxupquote{writer}} threads via ring buffers between threads.

Several \sphinxcode{\sphinxupquote{writer}} work in parallel to store packets as files in LZ4
format. You can capture a certain amount of heavy traffic by using much
\sphinxcode{\sphinxupquote{writer}} threads.

\hyperref[\detokenize{design/spp_secondary:figure-spp-pcap-design}]{Fig.\@ \ref{\detokenize{design/spp_secondary:figure-spp-pcap-design}}} shows an usecase of \sphinxcode{\sphinxupquote{spp\_pcap}} in which
packets from \sphinxcode{\sphinxupquote{phy:0}} are captured by using three \sphinxcode{\sphinxupquote{writer}} threads.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.550\linewidth]{{spp_pcap_design}.pdf}
\caption{spp\_pcap internal structure}\label{\detokenize{design/spp_secondary:id6}}\label{\detokenize{design/spp_secondary:figure-spp-pcap-design}}\end{figure}


\section{Implementation}
\label{\detokenize{design/impl/index:implementation}}\label{\detokenize{design/impl/index:spp-design-impl-index}}\label{\detokenize{design/impl/index::doc}}
This section describes topics of implementation of SPP processes.


\subsection{spp\_nfv}
\label{\detokenize{design/impl/spp_nfv:spp-nfv}}\label{\detokenize{design/impl/spp_nfv:design-impl-spp-nfv}}\label{\detokenize{design/impl/spp_nfv::doc}}
\sphinxcode{\sphinxupquote{spp\_nfv}} is a DPDK secondary process and communicates with primary and
other peer processes via TCP sockets or shared memory.
\sphinxcode{\sphinxupquote{spp\_nfv}} consists of several threads, main thread for maanging behavior of
\sphinxcode{\sphinxupquote{spp\_nfv}} and worker threads for packet forwarding.

As initialization of the process, it calls \sphinxcode{\sphinxupquote{rte\_eal\_init()}}, then specific
initialization functions for resources of \sphinxcode{\sphinxupquote{spp\_nfv}} itself.

After initialization, main thread launches worker threads on each of given
slave lcores with \sphinxcode{\sphinxupquote{rte\_eal\_remote\_launch()}}. It means that \sphinxcode{\sphinxupquote{spp\_nfv}}
requires two lcores at least.
Main thread starts to accept user command after all of worker threads are
launched.


\subsubsection{Initialization}
\label{\detokenize{design/impl/spp_nfv:initialization}}
In main funciton, \sphinxcode{\sphinxupquote{spp\_nfv}} calls \sphinxcode{\sphinxupquote{rte\_eal\_init()}} first as other
DPDK applications, \sphinxcode{\sphinxupquote{forward\_array\_init()}} and \sphinxcode{\sphinxupquote{port\_map\_init()}}
for initializing port forward array which is a kind of forwarding table.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k+kt}{int}
\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

        \PYG{n}{ret} \PYG{o}{=} \PYG{n}{rte\PYGZus{}eal\PYGZus{}init}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{ret} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

        \PYG{c+cm}{/* initialize port forward array*/}
        \PYG{n}{forward\PYGZus{}array\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{port\PYGZus{}map\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

Port forward array is implemented as an array of \sphinxcode{\sphinxupquote{port}} structure.
It consists of RX, TX ports and its forwarding functions,
\sphinxcode{\sphinxupquote{rte\_rx\_burst()}} and \sphinxcode{\sphinxupquote{rte\_tx\_burst()}} actually.
Each of ports are identified with unique port ID.
Worker thread iterates this array and forward packets from RX port to
TX port.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* src/shared/common.h */}

\PYG{k}{struct} \PYG{n}{port} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{uint16\PYGZus{}t} \PYG{n}{in\PYGZus{}port\PYGZus{}id}\PYG{p}{;}
    \PYG{k+kt}{uint16\PYGZus{}t} \PYG{n}{out\PYGZus{}port\PYGZus{}id}\PYG{p}{;}
    \PYG{k+kt}{uint16\PYGZus{}t} \PYG{p}{(}\PYG{o}{*}\PYG{n}{rx\PYGZus{}func}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{uint16\PYGZus{}t}\PYG{p}{,} \PYG{k+kt}{uint16\PYGZus{}t}\PYG{p}{,} \PYG{k}{struct} \PYG{n}{rte\PYGZus{}mbuf} \PYG{o}{*}\PYG{o}{*}\PYG{p}{,} \PYG{k+kt}{uint16\PYGZus{}t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{uint16\PYGZus{}t} \PYG{p}{(}\PYG{o}{*}\PYG{n}{tx\PYGZus{}func}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{uint16\PYGZus{}t}\PYG{p}{,} \PYG{k+kt}{uint16\PYGZus{}t}\PYG{p}{,} \PYG{k}{struct} \PYG{n}{rte\PYGZus{}mbuf} \PYG{o}{*}\PYG{o}{*}\PYG{p}{,} \PYG{k+kt}{uint16\PYGZus{}t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Port map is another kind of structure for managing its type and statistics.
Port type for indicating PMD type, for example, ring, vhost or so.
Statistics is used as a counter of packet forwarding.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* src/shared/common.h */}

\PYG{k}{struct} \PYG{n}{port\PYGZus{}map} \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{id}\PYG{p}{;}
        \PYG{k}{enum} \PYG{n}{port\PYGZus{}type} \PYG{n}{port\PYGZus{}type}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{stats} \PYG{o}{*}\PYG{n}{stats}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{stats} \PYG{n}{default\PYGZus{}stats}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Final step of initialization is setting up memzone.
In this step, \sphinxcode{\sphinxupquote{spp\_nfv}} just looks up memzone of primary process as a
secondary.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* set up array for port data */}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{rte\PYGZus{}eal\PYGZus{}process\PYGZus{}type}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{RTE\PYGZus{}PROC\PYGZus{}SECONDARY}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{mz} \PYG{o}{=} \PYG{n}{rte\PYGZus{}memzone\PYGZus{}lookup}\PYG{p}{(}\PYG{n}{MZ\PYGZus{}PORT\PYGZus{}INFO}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{mz} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)}
                \PYG{n}{rte\PYGZus{}exit}\PYG{p}{(}\PYG{n}{EXIT\PYGZus{}FAILURE}\PYG{p}{,}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot get port info structure}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ports} \PYG{o}{=} \PYG{n}{mz}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{addr}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Launch Worker Threads}
\label{\detokenize{design/impl/spp_nfv:launch-worker-threads}}
Worker threads are launched with \sphinxcode{\sphinxupquote{rte\_eal\_remote\_launch()}} from main thread.
\sphinxcode{\sphinxupquote{RTE\_LCORE\_FOREACH\_SLAVE}} is a macro for traversing slave lcores while
incrementing \sphinxcode{\sphinxupquote{lcore\_id}} and \sphinxcode{\sphinxupquote{rte\_eal\_remote\_launch()}} is a function
for running a function on worker thread.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{n}{lcore\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{RTE\PYGZus{}LCORE\PYGZus{}FOREACH\PYGZus{}SLAVE}\PYG{p}{(}\PYG{n}{lcore\PYGZus{}id}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{rte\PYGZus{}eal\PYGZus{}remote\PYGZus{}launch}\PYG{p}{(}\PYG{n}{main\PYGZus{}loop}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n}{lcore\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

In this case, \sphinxcode{\sphinxupquote{main\_loop}} is a starting point for calling task of worker
thread \sphinxcode{\sphinxupquote{nfv\_loop()}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k}{static} \PYG{k+kt}{int}
\PYG{n+nf}{main\PYGZus{}loop}\PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{dummy} \PYG{n}{\PYGZus{}\PYGZus{}rte\PYGZus{}unused}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{n}{nfv\PYGZus{}loop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Parsing User Command}
\label{\detokenize{design/impl/spp_nfv:parsing-user-command}}
After all of worker threads are launched, main threads goes into while
loop for waiting user command from SPP controller via TCP connection.
If receiving a user command, it simply parses the command and make a response.
It terminates the while loop if it receives \sphinxcode{\sphinxupquote{exit}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k}{while} \PYG{p}{(}\PYG{n}{on}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{ret} \PYG{o}{=} \PYG{n}{do\PYGZus{}connection}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{connected}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sock}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
        \PYG{n}{ret} \PYG{o}{=} \PYG{n}{do\PYGZus{}receive}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{connected}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sock}\PYG{p}{,} \PYG{n}{str}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
        \PYG{n}{flg\PYGZus{}exit} \PYG{o}{=} \PYG{n}{parse\PYGZus{}command}\PYG{p}{(}\PYG{n}{str}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
        \PYG{n}{ret} \PYG{o}{=} \PYG{n}{do\PYGZus{}send}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{connected}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sock}\PYG{p}{,} \PYG{n}{str}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{parse\_command()}} is a function for parsing user command as named.
There are several commnads for \sphinxcode{\sphinxupquote{spp\_nfv}} as described in
{\hyperref[\detokenize{commands/secondary/spp_nfv:commands-spp-nfv}]{\sphinxcrossref{\DUrole{std,std-ref}{Secondary Commands}}}}.
Command from controller is a simple plain text and action for the command
is decided with the first token of the command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k}{static} \PYG{k+kt}{int}
\PYG{n+nf}{parse\PYGZus{}command}\PYG{p}{(}\PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{str}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{strcmp}\PYG{p}{(}\PYG{n}{token\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{status}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{RTE\PYGZus{}LOG}\PYG{p}{(}\PYG{n}{DEBUG}\PYG{p}{,} \PYG{n}{SPP\PYGZus{}NFV}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{status}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{memset}\PYG{p}{(}\PYG{n}{str}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{MSG\PYGZus{}SIZE}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

                \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{strcmp}\PYG{p}{(}\PYG{n}{token\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{add}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{RTE\PYGZus{}LOG}\PYG{p}{(}\PYG{n}{DEBUG}\PYG{p}{,} \PYG{n}{SPP\PYGZus{}NFV}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Received add command}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{do\PYGZus{}add}\PYG{p}{(}\PYG{n}{token\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{n}{RTE\PYGZus{}LOG}\PYG{p}{(}\PYG{n}{ERR}\PYG{p}{,} \PYG{n}{SPP\PYGZus{}NFV}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed to do\PYGZus{}add()}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{strcmp}\PYG{p}{(}\PYG{n}{token\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{patch}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{RTE\PYGZus{}LOG}\PYG{p}{(}\PYG{n}{DEBUG}\PYG{p}{,} \PYG{n}{SPP\PYGZus{}NFV}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{patch}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

For instance, if the first token is \sphinxcode{\sphinxupquote{add}}, it calls \sphinxcode{\sphinxupquote{do\_add()}} with
given tokens and adds port to the process.


\subsection{spp\_vf}
\label{\detokenize{design/impl/spp_vf:spp-vf}}\label{\detokenize{design/impl/spp_vf:spp-vf-explain-spp-vf}}\label{\detokenize{design/impl/spp_vf::doc}}
This section describes implementation of key features of \sphinxcode{\sphinxupquote{spp\_vf}}.

\sphinxcode{\sphinxupquote{spp\_vf}} consists of master thread and several worker threads,
\sphinxcode{\sphinxupquote{forwarder}}, \sphinxcode{\sphinxupquote{classifier}} or \sphinxcode{\sphinxupquote{merger}}, as slaves.
For classifying packets, \sphinxcode{\sphinxupquote{spp\_vf}} has a worker thread named \sphinxcode{\sphinxupquote{classifier}}
and a table for registering MAC address entries.


\subsubsection{Initialization}
\label{\detokenize{design/impl/spp_vf:initialization}}
In master thread, data of classifier and VLAN features are initialized
after \sphinxcode{\sphinxupquote{rte\_eal\_init()}} is called.
Port capability is a set of data for describing VLAN features.
Then, each of worker threads are launched with \sphinxcode{\sphinxupquote{rte\_eal\_remote\_launch()}}
on assigned lcores..

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
 \PYG{c+cm}{/* spp\PYGZus{}vf.c */}

 \PYG{n}{ret} \PYG{o}{=} \PYG{n}{rte\PYGZus{}eal\PYGZus{}init}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}

 \PYG{c+cm}{/* skipping lines ... */}

 \PYG{c+cm}{/* Start worker threads of classifier and forwarder */}
\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{lcore\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{RTE\PYGZus{}LCORE\PYGZus{}FOREACH\PYGZus{}SLAVE}\PYG{p}{(}\PYG{n}{lcore\PYGZus{}id}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{rte\PYGZus{}eal\PYGZus{}remote\PYGZus{}launch}\PYG{p}{(}\PYG{n}{slave\PYGZus{}main}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n}{lcore\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Slave Main}
\label{\detokenize{design/impl/spp_vf:slave-main}}
Main function of worker thread is defined as \sphinxcode{\sphinxupquote{slave\_main()}} which is called
from \sphinxcode{\sphinxupquote{rte\_eal\_remote\_launch()}}.
Behavior of worker thread is decided in while loop in this function.
If lcore status is not \sphinxcode{\sphinxupquote{SPPWK\_LCORE\_RUNNING}}, worker thread does nothing.
On the other hand, it does packet forwarding with or without classifying.
It classifies incoming packets if component type is \sphinxcode{\sphinxupquote{SPPWK\_TYPE\_CLS}},
or simply forwards packets.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* spp\PYGZus{}vf.c */}

\PYG{k}{while} \PYG{p}{(}\PYG{p}{(}\PYG{n}{status} \PYG{o}{=} \PYG{n}{spp\PYGZus{}get\PYGZus{}core\PYGZus{}status}\PYG{p}{(}\PYG{n}{lcore\PYGZus{}id}\PYG{p}{)}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=}
    \PYG{n}{SPPWK\PYGZus{}LCORE\PYGZus{}REQ\PYGZus{}STOP}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{status} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SPPWK\PYGZus{}LCORE\PYGZus{}RUNNING}\PYG{p}{)}
        \PYG{k}{continue}\PYG{p}{;}

    \PYG{c+cm}{/* skipping lines ... */}

    \PYG{c+cm}{/* It is for processing multiple components. */}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{cnt} \PYG{o}{\PYGZlt{}} \PYG{n}{core}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{num}\PYG{p}{;} \PYG{n}{cnt}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/* Component classification to call a function. */}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{spp\PYGZus{}get\PYGZus{}component\PYGZus{}type}\PYG{p}{(}\PYG{n}{core}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{id}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=}
                \PYG{n}{SPPWK\PYGZus{}TYPE\PYGZus{}CLS}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+cm}{/* Component type for classifier. */}
        \PYG{n}{ret} \PYG{o}{=} \PYG{n}{classify\PYGZus{}packets}\PYG{p}{(}\PYG{n}{core}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{id}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{unlikely}\PYG{p}{(}\PYG{n}{ret} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
        \PYG{c+cm}{/* Component type for forward or merge. */}
            \PYG{n}{ret} \PYG{o}{=} \PYG{n}{forward\PYGZus{}packets}\PYG{p}{(}\PYG{n}{core}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{id}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{unlikely}\PYG{p}{(}\PYG{n}{ret} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Data structure of classifier}
\label{\detokenize{design/impl/spp_vf:data-structure-of-classifier}}
Classifier has a set of attributes for classification as
struct \sphinxcode{\sphinxupquote{mac\_classifier}}, which consists of a table of MAC addresses,
number of classifying ports, indices of ports
and default index of port.
Clasifier table is implemented as hash of struct \sphinxcode{\sphinxupquote{rte\_hash}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* shared/secondary/spp\PYGZus{}worker\PYGZus{}th/vf\PYGZus{}deps.h */}

\PYG{c+cm}{/* Classifier for MAC addresses. */}
\PYG{k}{struct} \PYG{n}{mac\PYGZus{}classifier} \PYG{p}{\PYGZob{}}
    \PYG{k}{struct} \PYG{n}{rte\PYGZus{}hash} \PYG{o}{*}\PYG{n}{cls\PYGZus{}tbl}\PYG{p}{;}  \PYG{c+cm}{/* Hash table for MAC classification. */}
    \PYG{k+kt}{int} \PYG{n}{nof\PYGZus{}cls\PYGZus{}ports}\PYG{p}{;}  \PYG{c+cm}{/* Num of ports classified validly. */}
    \PYG{k+kt}{int} \PYG{n}{cls\PYGZus{}ports}\PYG{p}{[}\PYG{n}{RTE\PYGZus{}MAX\PYGZus{}ETHPORTS}\PYG{p}{]}\PYG{p}{;}  \PYG{c+cm}{/* Ports for classification. */}
    \PYG{k+kt}{int} \PYG{n}{default\PYGZus{}cls\PYGZus{}idx}\PYG{p}{;}  \PYG{c+cm}{/* Default index for classification. */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Classifier itself is defined as a struct \sphinxcode{\sphinxupquote{cls\_comp\_info}}.
There are several attributes in this struct including \sphinxcode{\sphinxupquote{mac\_classifier}}
or \sphinxcode{\sphinxupquote{cls\_port\_info}} or so.
\sphinxcode{\sphinxupquote{cls\_port\_info}} is for defining a set of attributes of ports, such as
interface type, device ID or packet data.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* shared/secondary/spp\PYGZus{}worker\PYGZus{}th/vf\PYGZus{}deps.h */}

\PYG{c+cm}{/* classifier component information */}
\PYG{k}{struct} \PYG{n}{cls\PYGZus{}comp\PYGZus{}info} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{name}\PYG{p}{[}\PYG{n}{STR\PYGZus{}LEN\PYGZus{}NAME}\PYG{p}{]}\PYG{p}{;}  \PYG{c+cm}{/* component name */}
    \PYG{k+kt}{int} \PYG{n}{mac\PYGZus{}addr\PYGZus{}entry}\PYG{p}{;}  \PYG{c+cm}{/* mac address entry flag */}
    \PYG{k}{struct} \PYG{n}{mac\PYGZus{}classifier} \PYG{o}{*}\PYG{n}{mac\PYGZus{}clfs}\PYG{p}{[}\PYG{n}{NOF\PYGZus{}VLAN}\PYG{p}{]}\PYG{p}{;}  \PYG{c+cm}{/* classifiers per VLAN. */}
    \PYG{k+kt}{int} \PYG{n}{nof\PYGZus{}tx\PYGZus{}ports}\PYG{p}{;}  \PYG{c+cm}{/* Number of TX ports info entries. */}
    \PYG{c+cm}{/* Classifier has one RX port and several TX ports. */}
    \PYG{k}{struct} \PYG{n}{cls\PYGZus{}port\PYGZus{}info} \PYG{n}{rx\PYGZus{}port\PYGZus{}i}\PYG{p}{;}  \PYG{c+cm}{/* RX port info classified. */}
    \PYG{k}{struct} \PYG{n}{cls\PYGZus{}port\PYGZus{}info} \PYG{n}{tx\PYGZus{}ports\PYGZus{}i}\PYG{p}{[}\PYG{n}{RTE\PYGZus{}MAX\PYGZus{}ETHPORTS}\PYG{p}{]}\PYG{p}{;}  \PYG{c+cm}{/* TX info. */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* Attirbutes of port for classification. */}
\PYG{k}{struct} \PYG{n}{cls\PYGZus{}port\PYGZus{}info} \PYG{p}{\PYGZob{}}
    \PYG{k}{enum} \PYG{n}{port\PYGZus{}type} \PYG{n}{iface\PYGZus{}type}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{iface\PYGZus{}no}\PYG{p}{;}   \PYG{c+cm}{/* Index of ports handled by classifier. */}
    \PYG{k+kt}{int} \PYG{n}{iface\PYGZus{}no\PYGZus{}global}\PYG{p}{;}  \PYG{c+cm}{/* ID for interface generated by spp\PYGZus{}vf */}
    \PYG{k+kt}{uint16\PYGZus{}t} \PYG{n}{ethdev\PYGZus{}port\PYGZus{}id}\PYG{p}{;}  \PYG{c+cm}{/* Ethdev port ID. */}
    \PYG{k+kt}{uint16\PYGZus{}t} \PYG{n}{nof\PYGZus{}pkts}\PYG{p}{;}  \PYG{c+cm}{/* Number of packets in pkts[]. */}
    \PYG{k}{struct} \PYG{n}{rte\PYGZus{}mbuf} \PYG{o}{*}\PYG{n}{pkts}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}PKT\PYGZus{}BURST}\PYG{p}{]}\PYG{p}{;}  \PYG{c+cm}{/* packets to be classified. */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Classifying the packet}
\label{\detokenize{design/impl/spp_vf:classifying-the-packet}}
If component type is \sphinxcode{\sphinxupquote{SPPWK\_TYPE\_CLS}}, worker thread behaves as a classifier,
so component calls \sphinxcode{\sphinxupquote{classify\_packets()}}. In this function, packets
from RX port are received with \sphinxcode{\sphinxupquote{sppwk\_eth\_vlan\_rx\_burst()}} which is derived
from \sphinxcode{\sphinxupquote{rte\_eth\_rx\_burst()}} for adding or deleting VLAN tags.
Received packets are classified with \sphinxcode{\sphinxupquote{classify\_packet()}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* classifier.c */}

\PYG{n}{n\PYGZus{}rx} \PYG{o}{=} \PYG{n}{sppwk\PYGZus{}eth\PYGZus{}vlan\PYGZus{}rx\PYGZus{}burst}\PYG{p}{(}\PYG{n}{clsd\PYGZus{}data\PYGZus{}rx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ethdev\PYGZus{}port\PYGZus{}id}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n}{rx\PYGZus{}pkts}\PYG{p}{,} \PYG{n}{MAX\PYGZus{}PKT\PYGZus{}BURST}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/* skipping lines ... */}

\PYG{n}{classify\PYGZus{}packet}\PYG{p}{(}\PYG{n}{rx\PYGZus{}pkts}\PYG{p}{,} \PYG{n}{n\PYGZus{}rx}\PYG{p}{,} \PYG{n}{cmp\PYGZus{}info}\PYG{p}{,} \PYG{n}{clsd\PYGZus{}data\PYGZus{}tx}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Packet processing in forwarder and merger}
\label{\detokenize{design/impl/spp_vf:packet-processing-in-forwarder-and-merger}}
Configuration data for forwarder and merger is stored as structured
tables \sphinxcode{\sphinxupquote{forward\_rxtx}}, \sphinxcode{\sphinxupquote{forward\_path}} and \sphinxcode{\sphinxupquote{forward\_info}}.
The \sphinxcode{\sphinxupquote{forward\_rxtx}} has two member variables for expressing the port
to be sent(tx) and to be receive(rx),
\sphinxcode{\sphinxupquote{forward\_path}} has member variables for expressing the data path.
Like as \sphinxcode{\sphinxupquote{mac\_classifier}}, \sphinxcode{\sphinxupquote{forward\_info}} has two tables,
one is for updating by commands, the other is for looking up to process
packets.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* forwarder.c */}
\PYG{c+cm}{/* A set of port info of rx and tx */}
\PYG{k}{struct} \PYG{n}{forward\PYGZus{}rxtx} \PYG{p}{\PYGZob{}}
        \PYG{k}{struct} \PYG{n}{spp\PYGZus{}port\PYGZus{}info} \PYG{n}{rx}\PYG{p}{;} \PYG{c+cm}{/* rx port */}
        \PYG{k}{struct} \PYG{n}{spp\PYGZus{}port\PYGZus{}info} \PYG{n}{tx}\PYG{p}{;} \PYG{c+cm}{/* tx port */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* Information on the path used for forward. */}
\PYG{k}{struct} \PYG{n}{forward\PYGZus{}path} \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{char} \PYG{n}{name}\PYG{p}{[}\PYG{n}{STR\PYGZus{}LEN\PYGZus{}NAME}\PYG{p}{]}\PYG{p}{;}  \PYG{c+cm}{/* Component name */}
        \PYG{k}{volatile} \PYG{k}{enum} \PYG{n}{sppwk\PYGZus{}worker\PYGZus{}type} \PYG{n}{wk\PYGZus{}type}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{nof\PYGZus{}rx}\PYG{p}{;}  \PYG{c+cm}{/* Number of RX ports */}
        \PYG{k+kt}{int} \PYG{n}{nof\PYGZus{}tx}\PYG{p}{;}  \PYG{c+cm}{/* Number of TX ports */}
        \PYG{k}{struct} \PYG{n}{forward\PYGZus{}rxtx} \PYG{n}{ports}\PYG{p}{[}\PYG{n}{RTE\PYGZus{}MAX\PYGZus{}ETHPORTS}\PYG{p}{]}\PYG{p}{;}  \PYG{c+cm}{/* Set of RX and TX */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* Information for forward. */}
\PYG{k}{struct} \PYG{n}{forward\PYGZus{}info} \PYG{p}{\PYGZob{}}
        \PYG{k}{volatile} \PYG{k+kt}{int} \PYG{n}{ref\PYGZus{}index}\PYG{p}{;} \PYG{c+cm}{/* index to reference area */}
        \PYG{k}{volatile} \PYG{k+kt}{int} \PYG{n}{upd\PYGZus{}index}\PYG{p}{;} \PYG{c+cm}{/* index to update area    */}
        \PYG{k}{struct} \PYG{n}{forward\PYGZus{}path} \PYG{n}{path}\PYG{p}{[}\PYG{n}{SPP\PYGZus{}INFO\PYGZus{}AREA\PYGZus{}MAX}\PYG{p}{]}\PYG{p}{;}
                                \PYG{c+cm}{/* Information of data path */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{L2 Multicast Support}
\label{\detokenize{design/impl/spp_vf:l2-multicast-support}}
\sphinxcode{\sphinxupquote{spp\_vf}} supports multicast for resolving ARP requests.
It is implemented as \sphinxcode{\sphinxupquote{handle\_l2multicast\_packet()}} and called from
\sphinxcode{\sphinxupquote{classify\_packet()}} for incoming multicast packets.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* classify\PYGZus{}packet() in classifier.c */}

\PYG{c+cm}{/* L2 multicast(include broadcast) ? */}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{unlikely}\PYG{p}{(}\PYG{n}{is\PYGZus{}multicast\PYGZus{}ether\PYGZus{}addr}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{eth}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{d\PYGZus{}addr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{RTE\PYGZus{}LOG}\PYG{p}{(}\PYG{n}{DEBUG}\PYG{p}{,} \PYG{n}{SPP\PYGZus{}CLASSIFIER\PYGZus{}MAC}\PYG{p}{,}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{multicast mac address.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{handle\PYGZus{}l2multicast\PYGZus{}packet}\PYG{p}{(}\PYG{n}{rx\PYGZus{}pkts}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}
                        \PYG{n}{classifier\PYGZus{}info}\PYG{p}{,}
                        \PYG{n}{classified\PYGZus{}data}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{continue}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Packets are cloned with \sphinxcode{\sphinxupquote{rte\_mbuf\_refcnt\_update()}} for distributing
multicast packets.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* classifier.c */}

\PYG{n}{handle\PYGZus{}l2multicast\PYGZus{}packet}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{rte\PYGZus{}mbuf} \PYG{o}{*}\PYG{n}{pkt}\PYG{p}{,}
        \PYG{k}{struct} \PYG{n}{cls\PYGZus{}comp\PYGZus{}info} \PYG{o}{*}\PYG{n}{cmp\PYGZus{}info}\PYG{p}{,}
        \PYG{k}{struct} \PYG{n}{cls\PYGZus{}port\PYGZus{}info} \PYG{o}{*}\PYG{n}{clsd\PYGZus{}data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{mac\PYGZus{}classifier} \PYG{o}{*}\PYG{n}{mac\PYGZus{}cls}\PYG{p}{;}
        \PYG{k+kt}{uint16\PYGZus{}t} \PYG{n}{vid} \PYG{o}{=} \PYG{n}{get\PYGZus{}vid}\PYG{p}{(}\PYG{n}{pkt}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{gen\PYGZus{}def\PYGZus{}clsd\PYGZus{}idx} \PYG{o}{=} \PYG{n}{get\PYGZus{}general\PYGZus{}default\PYGZus{}classified\PYGZus{}index}\PYG{p}{(}\PYG{n}{cmp\PYGZus{}info}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{n\PYGZus{}act\PYGZus{}clsd}\PYG{p}{;}

        \PYG{c+cm}{/* skipping lines... */}

        \PYG{n}{rte\PYGZus{}mbuf\PYGZus{}refcnt\PYGZus{}update}\PYG{p}{(}\PYG{n}{pkt}\PYG{p}{,} \PYG{p}{(}\PYG{k+kt}{int16\PYGZus{}t}\PYG{p}{)}\PYG{p}{(}\PYG{n}{n\PYGZus{}act\PYGZus{}clsd} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Two phase update for forwarding}
\label{\detokenize{design/impl/spp_vf:two-phase-update-for-forwarding}}
Update of netowrk configuration in \sphinxcode{\sphinxupquote{spp\_vf}} is done in a short period of
time, but not so short considering the time scale of packet forwarding.
It might forward packets before the updating is completed possibly.
To avoid such kind of situation, \sphinxcode{\sphinxupquote{spp\_vf}} has two phase update mechanism.
Status info is referred from forwarding process after the update is completed.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k+kt}{int}
\PYG{n+nf}{flush\PYGZus{}cmd}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{ret}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{p\PYGZus{}change\PYGZus{}comp}\PYG{p}{;}
    \PYG{k}{struct} \PYG{n}{sppwk\PYGZus{}comp\PYGZus{}info} \PYG{o}{*}\PYG{n}{p\PYGZus{}comp\PYGZus{}info}\PYG{p}{;}
    \PYG{k}{struct} \PYG{n}{cancel\PYGZus{}backup\PYGZus{}info} \PYG{o}{*}\PYG{n}{backup\PYGZus{}info}\PYG{p}{;}

    \PYG{n}{sppwk\PYGZus{}get\PYGZus{}mng\PYGZus{}data}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{p\PYGZus{}comp\PYGZus{}info}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{p\PYGZus{}change\PYGZus{}comp}\PYG{p}{,}
            \PYG{o}{\PYGZam{}}\PYG{n}{backup\PYGZus{}info}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{ret} \PYG{o}{=} \PYG{n}{update\PYGZus{}port\PYGZus{}info}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ret} \PYG{o}{\PYGZlt{}} \PYG{n}{SPPWK\PYGZus{}RET\PYGZus{}OK}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{ret}\PYG{p}{;}

    \PYG{n}{update\PYGZus{}lcore\PYGZus{}info}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{ret} \PYG{o}{=} \PYG{n}{update\PYGZus{}comp\PYGZus{}info}\PYG{p}{(}\PYG{n}{p\PYGZus{}comp\PYGZus{}info}\PYG{p}{,} \PYG{n}{p\PYGZus{}change\PYGZus{}comp}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{backup\PYGZus{}mng\PYGZus{}info}\PYG{p}{(}\PYG{n}{backup\PYGZus{}info}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{ret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{spp\_mirror}
\label{\detokenize{design/impl/spp_mirror:spp-mirror}}\label{\detokenize{design/impl/spp_mirror:spp-vf-explain-spp-mirror}}\label{\detokenize{design/impl/spp_mirror::doc}}
This section describes implementation of \sphinxcode{\sphinxupquote{spp\_mirror}}.
It consists of master thread and several worker threads for duplicating
packets.


\subsubsection{Slave Main}
\label{\detokenize{design/impl/spp_mirror:slave-main}}
Main function of worker thread is defined as \sphinxcode{\sphinxupquote{slave\_main()}} in which
for duplicating packets is \sphinxcode{\sphinxupquote{mirror\_proc()}} on each of lcores.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{cnt} \PYG{o}{\PYGZlt{}} \PYG{n}{core}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{num}\PYG{p}{;} \PYG{n}{cnt}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}

    \PYG{n}{ret} \PYG{o}{=} \PYG{n}{mirror\PYGZus{}proc}\PYG{p}{(}\PYG{n}{core}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{id}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{unlikely}\PYG{p}{(}\PYG{n}{ret} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{break}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Mirroring Packets}
\label{\detokenize{design/impl/spp_mirror:mirroring-packets}}
Worker thread receives and duplicate packets. There are two modes of copying
packets, \sphinxcode{\sphinxupquote{shallowcopy}} and \sphinxcode{\sphinxupquote{deepcopy}}.
Deep copy is for duplicating whole of packet data, but less performance than
shallow copy. Shallow copy duplicates only packet header and body is not shared
among original packet and duplicated packet. So, changing packet data affects
both of original and copied packet.

You can configure using which of modes in Makefile. Default mode is
\sphinxcode{\sphinxupquote{shallowcopy}}. If you change the mode to \sphinxcode{\sphinxupquote{deepcopy}}, comment out this
line of CFLAGS.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c}{\PYGZsh{} Default mode is shallow copy.}
\PYG{n+nv}{CFLAGS} \PYG{o}{+=} \PYGZhy{}DSPP\PYGZus{}MIRROR\PYGZus{}SHALLOWCOPY
\end{sphinxVerbatim}

This code is a part of \sphinxcode{\sphinxupquote{mirror\_proc()}}. In this function,
\sphinxcode{\sphinxupquote{rte\_pktmbuf\_clone()}} is just called if in shallow copy
mode, or create a new packet with \sphinxcode{\sphinxupquote{rte\_pktmbuf\_alloc()}} for duplicated
packet if in deep copy mode.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
             \PYG{k}{for} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{cnt} \PYG{o}{\PYGZlt{}} \PYG{n}{nb\PYGZus{}rx}\PYG{p}{;} \PYG{n}{cnt}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                     \PYG{n}{org\PYGZus{}mbuf} \PYG{o}{=} \PYG{n}{bufs}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{p}{;}
                     \PYG{n}{rte\PYGZus{}prefetch0}\PYG{p}{(}\PYG{n}{rte\PYGZus{}pktmbuf\PYGZus{}mtod}\PYG{p}{(}\PYG{n}{org\PYGZus{}mbuf}\PYG{p}{,} \PYG{k+kt}{void} \PYG{o}{*}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef SPP\PYGZus{}MIRROR\PYGZus{}SHALLOWCOPY}
                     \PYG{c+cm}{/* Shallow Copy */}
         \PYG{n}{copybufs}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rte\PYGZus{}pktmbuf\PYGZus{}clone}\PYG{p}{(}\PYG{n}{org\PYGZus{}mbuf}\PYG{p}{,}
                                                     \PYG{n}{g\PYGZus{}mirror\PYGZus{}pool}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
                     \PYG{k}{struct} \PYG{n}{rte\PYGZus{}mbuf} \PYG{o}{*}\PYG{n}{mirror\PYGZus{}mbuf} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}
                     \PYG{k}{struct} \PYG{n}{rte\PYGZus{}mbuf} \PYG{o}{*}\PYG{o}{*}\PYG{n}{mirror\PYGZus{}mbufs} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{mirror\PYGZus{}mbuf}\PYG{p}{;}
                     \PYG{k}{struct} \PYG{n}{rte\PYGZus{}mbuf} \PYG{o}{*}\PYG{n}{copy\PYGZus{}mbuf} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}
                     \PYG{c+cm}{/* Deep Copy */}
                     \PYG{k}{do} \PYG{p}{\PYGZob{}}
                             \PYG{n}{copy\PYGZus{}mbuf} \PYG{o}{=} \PYG{n}{rte\PYGZus{}pktmbuf\PYGZus{}alloc}\PYG{p}{(}\PYG{n}{g\PYGZus{}mirror\PYGZus{}pool}\PYG{p}{)}\PYG{p}{;}
                             \PYG{k}{if} \PYG{p}{(}\PYG{n}{unlikely}\PYG{p}{(}\PYG{n}{copy\PYGZus{}mbuf} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                                     \PYG{n}{rte\PYGZus{}pktmbuf\PYGZus{}free}\PYG{p}{(}\PYG{n}{mirror\PYGZus{}mbuf}\PYG{p}{)}\PYG{p}{;}
                                     \PYG{n}{mirror\PYGZus{}mbuf} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}
                                     \PYG{n}{RTE\PYGZus{}LOG}\PYG{p}{(}\PYG{n}{INFO}\PYG{p}{,} \PYG{n}{MIRROR}\PYG{p}{,}
                                             \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{copy mbuf alloc NG!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                                     \PYG{k}{break}\PYG{p}{;}
                             \PYG{p}{\PYGZcb{}}

                             \PYG{n}{copy\PYGZus{}mbuf}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data\PYGZus{}off} \PYG{o}{=} \PYG{n}{org\PYGZus{}mbuf}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data\PYGZus{}off}\PYG{p}{;}
                             \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
                             \PYG{n}{copy\PYGZus{}mbuf}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{packet\PYGZus{}type} \PYG{o}{=} \PYG{n}{org\PYGZus{}mbuf}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{packet\PYGZus{}type}\PYG{p}{;}

                             \PYG{n}{rte\PYGZus{}memcpy}\PYG{p}{(}\PYG{n}{rte\PYGZus{}pktmbuf\PYGZus{}mtod}\PYG{p}{(}\PYG{n}{copy\PYGZus{}mbuf}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{p}{)}\PYG{p}{,}
                                     \PYG{n}{rte\PYGZus{}pktmbuf\PYGZus{}mtod}\PYG{p}{(}\PYG{n}{org\PYGZus{}mbuf}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{p}{)}\PYG{p}{,}
                                     \PYG{n}{org\PYGZus{}mbuf}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data\PYGZus{}len}\PYG{p}{)}\PYG{p}{;}

                             \PYG{o}{*}\PYG{n}{mirror\PYGZus{}mbufs} \PYG{o}{=} \PYG{n}{copy\PYGZus{}mbuf}\PYG{p}{;}
                             \PYG{n}{mirror\PYGZus{}mbufs} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{copy\PYGZus{}mbuf}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
                     \PYG{p}{\PYGZcb{}} \PYG{k}{while} \PYG{p}{(}\PYG{p}{(}\PYG{n}{org\PYGZus{}mbuf} \PYG{o}{=} \PYG{n}{org\PYGZus{}mbuf}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{copybufs}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]} \PYG{o}{=} \PYG{n}{mirror\PYGZus{}mbuf}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* SPP\PYGZus{}MIRROR\PYGZus{}SHALLOWCOPY */}
             \PYG{p}{\PYGZcb{}}
     \PYG{k}{if} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                     \PYG{n}{nb\PYGZus{}tx2} \PYG{o}{=} \PYG{n}{spp\PYGZus{}eth\PYGZus{}tx\PYGZus{}burst}\PYG{p}{(}\PYG{n}{tx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dpdk\PYGZus{}port}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}
                             \PYG{n}{copybufs}\PYG{p}{,} \PYG{n}{cnt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{spp\_pcap}
\label{\detokenize{design/impl/spp_pcap:spp-pcap}}\label{\detokenize{design/impl/spp_pcap:spp-pcap-explain}}\label{\detokenize{design/impl/spp_pcap::doc}}
This section describes implementation of \sphinxcode{\sphinxupquote{spp\_pcap}}.


\subsubsection{Slave Main}
\label{\detokenize{design/impl/spp_pcap:slave-main}}
In \sphinxcode{\sphinxupquote{slave\_main()}}, it calls \sphinxcode{\sphinxupquote{pcap\_proc\_receive()}} if thread type is
receiver, or \sphinxcode{\sphinxupquote{pcap\_proc\_write()}} if the type is writer.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* spp\PYGZus{}pcap.c */}

\PYG{k}{while} \PYG{p}{(}\PYG{p}{(}\PYG{n}{status} \PYG{o}{=} \PYG{n}{spp\PYGZus{}get\PYGZus{}core\PYGZus{}status}\PYG{p}{(}\PYG{n}{lcore\PYGZus{}id}\PYG{p}{)}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=}
                \PYG{n}{SPP\PYGZus{}CORE\PYGZus{}STOP\PYGZus{}REQUEST}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{pcap\PYGZus{}info}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{type} \PYG{o}{=}\PYG{o}{=} \PYG{n}{TYPE\PYGZus{}RECIVE}\PYG{p}{)}
                \PYG{n}{ret} \PYG{o}{=} \PYG{n}{pcap\PYGZus{}proc\PYGZus{}receive}\PYG{p}{(}\PYG{n}{lcore\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else}
                \PYG{n}{ret} \PYG{o}{=} \PYG{n}{pcap\PYGZus{}proc\PYGZus{}write}\PYG{p}{(}\PYG{n}{lcore\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Receiving Pakcets}
\label{\detokenize{design/impl/spp_pcap:receiving-pakcets}}
\sphinxcode{\sphinxupquote{pcap\_proc\_receive()}} is for receiving packets with \sphinxcode{\sphinxupquote{rte\_eth\_rx\_burst}}
and sending the packets to the writer thread via ring memory by using
\sphinxcode{\sphinxupquote{rte\_ring\_enqueue\_bulk()}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cm}{/* spp\PYGZus{}pcap.c */}

\PYG{n}{rx} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{g\PYGZus{}pcap\PYGZus{}option}\PYG{p}{.}\PYG{n}{port\PYGZus{}cap}\PYG{p}{;}
\PYG{n}{nb\PYGZus{}rx} \PYG{o}{=} \PYG{n}{rte\PYGZus{}eth\PYGZus{}rx\PYGZus{}burst}\PYG{p}{(}\PYG{n}{rx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ethdev\PYGZus{}port\PYGZus{}id}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{bufs}\PYG{p}{,} \PYG{n}{MAX\PYGZus{}PCAP\PYGZus{}BURST}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/* Forward to ring for writer thread */}
\PYG{n}{nb\PYGZus{}tx} \PYG{o}{=} \PYG{n}{rte\PYGZus{}ring\PYGZus{}enqueue\PYGZus{}burst}\PYG{p}{(}\PYG{n}{write\PYGZus{}ring}\PYG{p}{,} \PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*}\PYG{p}{)}\PYG{n}{bufs}\PYG{p}{,} \PYG{n}{nb\PYGZus{}rx}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Writing Packet}
\label{\detokenize{design/impl/spp_pcap:writing-packet}}
\sphinxcode{\sphinxupquote{pcap\_proc\_write()}} is for capturing packets to a file. The captured file
is compressed with
\sphinxhref{https://github.com/lz4/lz4}{LZ4}
which is a lossless compression algorithm and providing compression
speed \textgreater{} 500 MB/s per core.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{n}{nb\PYGZus{}rx} \PYG{o}{=}  \PYG{n}{rte\PYGZus{}ring\PYGZus{}dequeue\PYGZus{}bulk}\PYG{p}{(}\PYG{n}{read\PYGZus{}ring}\PYG{p}{,} \PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*}\PYG{p}{)}\PYG{n}{bufs}\PYG{p}{,} \PYG{n}{MAX\PYGZus{}PKT\PYGZus{}BURST}\PYG{p}{,}
                                                                \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{buf} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{buf} \PYG{o}{\PYGZlt{}} \PYG{n}{nb\PYGZus{}rx}\PYG{p}{;} \PYG{n}{buf}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{mbuf} \PYG{o}{=} \PYG{n}{bufs}\PYG{p}{[}\PYG{n}{buf}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{rte\PYGZus{}prefetch0}\PYG{p}{(}\PYG{n}{rte\PYGZus{}pktmbuf\PYGZus{}mtod}\PYG{p}{(}\PYG{n}{mbuf}\PYG{p}{,} \PYG{k+kt}{void} \PYG{o}{*}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{compress\PYGZus{}file\PYGZus{}packet}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{g\PYGZus{}pcap\PYGZus{}info}\PYG{p}{[}\PYG{n}{lcore\PYGZus{}id}\PYG{p}{]}\PYG{p}{,} \PYG{n}{mbuf}\PYG{p}{)}
                                                \PYG{o}{!}\PYG{o}{=} \PYG{n}{SPPWK\PYGZus{}RET\PYGZus{}OK}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{RTE\PYGZus{}LOG}\PYG{p}{(}\PYG{n}{ERR}\PYG{p}{,} \PYG{n}{PCAP}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{capture file write error: }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}d (\PYGZpc{}s)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{errno}\PYG{p}{,} \PYG{n}{strerror}\PYG{p}{(}\PYG{n}{errno}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{ret} \PYG{o}{=} \PYG{n}{SPPWK\PYGZus{}RET\PYGZus{}NG}\PYG{p}{;}
                \PYG{n}{info}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{status} \PYG{o}{=} \PYG{n}{SPP\PYGZus{}CAPTURE\PYGZus{}IDLE}\PYG{p}{;}
                \PYG{n}{compress\PYGZus{}file\PYGZus{}operation}\PYG{p}{(}\PYG{n}{info}\PYG{p}{,} \PYG{n}{CLOSE\PYGZus{}MODE}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{buf} \PYG{o}{=} \PYG{n}{nb\PYGZus{}rx}\PYG{p}{;} \PYG{n}{buf} \PYG{o}{\PYGZlt{}} \PYG{n}{nb\PYGZus{}rx}\PYG{p}{;} \PYG{n}{buf}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{rte\PYGZus{}pktmbuf\PYGZus{}free}\PYG{p}{(}\PYG{n}{bufs}\PYG{p}{[}\PYG{n}{buf}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Getting Started Guide}
\label{\detokenize{gsg/index:getting-started-guide}}\label{\detokenize{gsg/index::doc}}

\section{Setup}
\label{\detokenize{gsg/setup:setup}}\label{\detokenize{gsg/setup:gsg-setup}}\label{\detokenize{gsg/setup::doc}}
This documentation is described for following distributions.
\begin{itemize}
\item {} 
Ubuntu 16.04 and 18.04

\item {} 
CentOS 7.6 (not fully supported)

\end{itemize}


\subsection{Reserving Hugepages}
\label{\detokenize{gsg/setup:reserving-hugepages}}\label{\detokenize{gsg/setup:gsg-reserve-hugep}}
Hugepages should be enabled for running DPDK application.
Hugepage support is to reserve large amount size of pages,
2MB or 1GB per page, to less TLB (Translation Lookaside Buffers) and
to reduce cache miss.
Less TLB means that it reduce the time for translating virtual address
to physical.

How to configure reserving hugepages is different between 2MB or 1GB.
In general, 1GB is better for getting high performance,
but 2MB is easier for configuration than 1GB.


\subsubsection{1GB Hugepage}
\label{\detokenize{gsg/setup:gb-hugepage}}
For using 1GB page, hugepage setting is activated while booting system.
It must be defined in boot loader configuration, usually it is
\sphinxcode{\sphinxupquote{/etc/default/grub}}.
Add an entry of configuration of the size and the number of pages.

Here is an example for Ubuntu, and almost the same as CentOS. The points are
that \sphinxcode{\sphinxupquote{hugepagesz}} is for the size and \sphinxcode{\sphinxupquote{hugepages}} is for the number of
pages.
You can also configure \sphinxcode{\sphinxupquote{isolcpus}} in grub setting for improving performance
as described in
{\hyperref[\detokenize{gsg/performance_opt:gsg-performance-opt}]{\sphinxcrossref{\DUrole{std,std-ref}{Performance Optimizing}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} /etc/default/grub
GRUB\PYGZus{}CMDLINE\PYGZus{}LINUX=\PYGZdq{}default\PYGZus{}hugepagesz=1G hugepagesz=1G hugepages=8\PYGZdq{}
\end{sphinxVerbatim}

For Ubuntu, you should run \sphinxcode{\sphinxupquote{update-grub}} for updating
\sphinxcode{\sphinxupquote{/boot/grub/grub.cfg}} after editing to update grub’s
config file, or this configuration is not activated.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Ubuntu
\PYG{g+gp}{\PYGZdl{}} sudo update\PYGZhy{}grub
\PYG{g+go}{Generating grub configuration file ...}
\end{sphinxVerbatim}

Or for CentOS7, you use \sphinxcode{\sphinxupquote{grub2-mkconfig}} instead of \sphinxcode{\sphinxupquote{update-grub}}.
In this case, you should give the output file with \sphinxcode{\sphinxupquote{-o}} option.
The output path might be different, so you should find your correct
\sphinxcode{\sphinxupquote{grub.cfg}} by yourself.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} CentOS
\PYG{g+gp}{\PYGZdl{}} sudo grub2\PYGZhy{}mkconfig \PYGZhy{}o /boot/efi/EFI/centos/grub.cfg
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
1GB hugepages might not be supported on your hardware.
It depends on that CPUs support 1GB pages or not. You can check it
by referring \sphinxcode{\sphinxupquote{/proc/cpuinfo}}. If it is supported, you can find
\sphinxcode{\sphinxupquote{pdpe1gb}} in the \sphinxcode{\sphinxupquote{flags}} attribute.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} cat /proc/cpuinfo \PYG{p}{\textbar{}} grep pdpe1gb
\PYG{g+go}{flags           : fpu vme ... pdpe1gb ...}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{2MB Hugepage}
\label{\detokenize{gsg/setup:mb-hugepage}}
For using 2MB page, you can activate hugepages while booting or at anytime
after system is booted.
Define hugepages setting in \sphinxcode{\sphinxupquote{/etc/default/grub}} to activate it while
booting, or overwrite the number of 2MB hugepages as following.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{echo} \PYG{l+m}{1024} \PYGZgt{} /sys/kernel/mm/hugepages/hugepages\PYGZhy{}2048kB/nr\PYGZus{}hugepages
\end{sphinxVerbatim}

In this case, 1024 pages of 2MB, totally 2048 MB, are reserved.


\subsection{Mount hugepages}
\label{\detokenize{gsg/setup:mount-hugepages}}
Make the memory available for using hugepages from DPDK.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} mkdir /mnt/huge
\PYG{g+gp}{\PYGZdl{}} mount \PYGZhy{}t hugetlbfs nodev /mnt/huge
\end{sphinxVerbatim}

It is also available while booting by adding a configuration of mount
point in \sphinxcode{\sphinxupquote{/etc/fstab}}.
The mount point for 2MB or 1GB can be made permanently accross reboot.
For 2MB, it is no need to declare the size of hugepages explicity.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} /etc/fstab
nodev /mnt/huge hugetlbfs defaults 0 0
\end{sphinxVerbatim}

For 1GB, the size of hugepage \sphinxcode{\sphinxupquote{pagesize}} must be specified.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} /etc/fstab
nodev /mnt/huge\PYGZus{}1GB hugetlbfs pagesize=1GB 0 0
\end{sphinxVerbatim}


\subsection{Disable ASLR}
\label{\detokenize{gsg/setup:disable-aslr}}
SPP is a DPDK multi-process application and there are a number of
\sphinxhref{https://dpdk.org/doc/guides/prog\_guide/multi\_proc\_support.html\#multi-process-limitations}{limitations}
.

Address-Space Layout Randomization (ASLR) is a security feature for
memory protection, but may cause a failure of memory
mapping while starting multi-process application as discussed in
\sphinxhref{http://dpdk.org/ml/archives/dev/2014-September/005236.html}{dpdk-dev}
.

ASLR can be disabled by assigning \sphinxcode{\sphinxupquote{kernel.randomize\_va\_space}} to
\sphinxcode{\sphinxupquote{0}}, or be enabled by assigning it to \sphinxcode{\sphinxupquote{2}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} disable ASLR
\PYG{g+gp}{\PYGZdl{}} sudo sysctl \PYGZhy{}w kernel.randomize\PYGZus{}va\PYGZus{}space\PYG{o}{=}\PYG{l+m}{0}

\PYG{g+gp}{\PYGZsh{}} \PYG{n+nb}{enable} ASLR
\PYG{g+gp}{\PYGZdl{}} sudo sysctl \PYGZhy{}w kernel.randomize\PYGZus{}va\PYGZus{}space\PYG{o}{=}\PYG{l+m}{2}
\end{sphinxVerbatim}

You can check the value as following.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sysctl \PYGZhy{}n kernel.randomize\PYGZus{}va\PYGZus{}space
\end{sphinxVerbatim}


\subsection{Using Virtual Machine}
\label{\detokenize{gsg/setup:using-virtual-machine}}
SPP provides vhost interface for inter VM communication.
You can use any of DPDK supported hypervisors, but this document describes
usecases of qemu and libvirt.


\subsubsection{Server mode v.s. Client mode}
\label{\detokenize{gsg/setup:server-mode-v-s-client-mode}}
For using vhost, vhost port should be created before VM is launched in
server mode, or SPP is launched in client mode to be able to create
vhost port after VM is launched.

Client mode is optional and supported in qemu 2.7 or later.
For using this mode, launch secondary process with \sphinxcode{\sphinxupquote{-{-}vhost-client}}.
Qemu creates socket file instead of secondary process.
It means that you can launch a VM before secondary process create vhost port.


\subsubsection{Libvirt}
\label{\detokenize{gsg/setup:libvirt}}
If you use libvirt for managing virtual machines, you might need some
additional configurations.

To have access to resources with your account, update and
activate user and group parameters in \sphinxcode{\sphinxupquote{/etc/libvirt/qemu.conf}}.
Here is an example.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} /etc/libvirt/qemu.conf

user = \PYGZdq{}root\PYGZdq{}
group = \PYGZdq{}root\PYGZdq{}
\end{sphinxVerbatim}

For using hugepages with libvirt, change \sphinxcode{\sphinxupquote{KVM\_HUGEPAGES}} from 0 to 1
in \sphinxcode{\sphinxupquote{/etc/default/qemu-kvm}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} /etc/default/qemu\PYGZhy{}kvm

KVM\PYGZus{}HUGEPAGES=1
\end{sphinxVerbatim}

Change grub config as similar to
{\hyperref[\detokenize{gsg/setup:gsg-reserve-hugep}]{\sphinxcrossref{\DUrole{std,std-ref}{Reserving Hugepages}}}}.
You can check hugepage settings as following.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} cat /proc/meminfo \PYG{p}{\textbar{}} grep \PYGZhy{}i huge
\PYG{g+go}{AnonHugePages:      2048 kB}
\PYG{g+go}{HugePages\PYGZus{}Total:      36            \PYGZsh{}       /etc/default/grub}
\PYG{g+go}{HugePages\PYGZus{}Free:       36}
\PYG{g+go}{HugePages\PYGZus{}Rsvd:        0}
\PYG{g+go}{HugePages\PYGZus{}Surp:        0}
\PYG{g+go}{Hugepagesize:    1048576 kB         \PYGZsh{}       /etc/default/grub}

\PYG{g+gp}{\PYGZdl{}} mount \PYG{p}{\textbar{}} grep \PYGZhy{}i huge
\PYG{g+go}{cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,...,nsroot=/)}
\PYG{g+go}{hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime)}
\PYG{g+go}{hugetlbfs\PYGZhy{}kvm on /run/hugepages/kvm type hugetlbfs (rw,...,gid=117)}
\PYG{g+go}{hugetlb on /run/lxcfs/controllers/hugetlb type cgroup (rw,...,nsroot=/)}
\end{sphinxVerbatim}

Finally, you umount default hugepages.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo umount /dev/hugepages
\end{sphinxVerbatim}


\subsubsection{Trouble Shooting}
\label{\detokenize{gsg/setup:trouble-shooting}}
You might encounter a permission error while creating a resource,
such as a socket file under \sphinxcode{\sphinxupquote{tmp/}}, because of AppArmor.

You can avoid this error by editing \sphinxcode{\sphinxupquote{/etc/libvirt/qemu.conf}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Set security\PYGZus{}driver to \PYG{l+s+s2}{\PYGZdq{}none\PYGZdq{}}
\PYG{g+gp}{\PYGZdl{}}sudo vi /etc/libvirt/qemu.conf
\PYG{g+go}{...}
\PYG{g+go}{security\PYGZus{}driver = \PYGZdq{}none\PYGZdq{}}
\PYG{g+go}{...}
\end{sphinxVerbatim}

Restart libvirtd to activate this configuration.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}}sudo systemctl restart libvirtd.service
\end{sphinxVerbatim}

Or, you can also avoid by simply removing AppArmor itself.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo apt\PYGZhy{}get remove apparmor
\end{sphinxVerbatim}

If you use CentOS, confirm that SELinux doesn’t prevent
for permission.
SELinux is disabled simply by changing the configuration to \sphinxcode{\sphinxupquote{disabled}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} /etc/selinux/config
\PYG{g+go}{SELINUX=disabled}
\end{sphinxVerbatim}

Check your SELinux configuration.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} getenforce
\PYG{g+go}{Disabled}
\end{sphinxVerbatim}


\subsection{Python 2 or 3 ?}
\label{\detokenize{gsg/setup:python-2-or-3}}
Without SPP container tools, Python2 is not supported anymore.
SPP container will also be updated to Python3.


\subsection{Reference}
\label{\detokenize{gsg/setup:reference}}\begin{itemize}
\item {} 
{[}1{]} \sphinxhref{http://dpdk.org/doc/guides/linux\_gsg/sys\_reqs.html\#running-dpdk-applications}{Use of Hugepages in the Linux Environment}

\item {} 
{[}2{]} \sphinxhref{http://dpdk.org/doc/guides/linux\_gsg/enable\_func.html\#using-linux-core-isolation-to-reduce-context-switches}{Using Linux Core Isolation to Reduce Context Switches}

\item {} 
{[}3{]} \sphinxhref{http://dpdk.org/doc/guides/linux\_gsg/nic\_perf\_intel\_platform.html\#linux-boot-command-line}{Linux boot command line}

\end{itemize}


\section{Install DPDK and SPP}
\label{\detokenize{gsg/install:install-dpdk-and-spp}}\label{\detokenize{gsg/install:setup-install-dpdk-spp}}\label{\detokenize{gsg/install::doc}}
Before setting up SPP, you need to install DPDK.
In this document, briefly described how to install and setup DPDK.
Refer to \sphinxhref{https://dpdk.org/doc/guides/}{DPDK documentation} for more details.
For Linux, see \sphinxhref{http://www.dpdk.org/doc/guides/linux\_gsg/index.html}{Getting Started Guide for Linux} .


\subsection{Required Packages}
\label{\detokenize{gsg/install:required-packages}}\label{\detokenize{gsg/install:setup-install-packages}}
Installing packages for DPDK and SPP is almost the on Ubunu and CentOS,
but names are different for some packages.


\subsubsection{Ubuntu}
\label{\detokenize{gsg/install:ubuntu}}
To compile DPDK, it is required to install following packages.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo apt install libnuma\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
  libarchive\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
  build\PYGZhy{}essential
\end{sphinxVerbatim}

You also need to install linux-headers of your kernel version.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo apt install linux\PYGZhy{}headers\PYGZhy{}\PYG{k}{\PYGZdl{}(}uname \PYGZhy{}r\PYG{k}{)}
\end{sphinxVerbatim}

Some of SPP secondary processes depend on other libraries and you fail to
compile SPP without installing them.

SPP provides libpcap-based PMD for dumping packet to a file or retrieve
it from the file.
\sphinxcode{\sphinxupquote{spp\_nfv}} and \sphinxcode{\sphinxupquote{spp\_pcap}} use \sphinxcode{\sphinxupquote{libpcap-dev}} for packet capture.
\sphinxcode{\sphinxupquote{spp\_pcap}} uses \sphinxcode{\sphinxupquote{liblz4-dev}} and \sphinxcode{\sphinxupquote{liblz4-tool}} to compress PCAP file.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo apt install libpcap\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
  liblz4\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
  liblz4\PYGZhy{}tool
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{text2pcap}} is also required for creating pcap file which
is included in \sphinxcode{\sphinxupquote{wireshark}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo apt install wireshark
\end{sphinxVerbatim}


\subsubsection{CentOS}
\label{\detokenize{gsg/install:centos}}
Before installing packages for DPDK, you should add
\sphinxhref{https://ius.io/GettingStarted/}{IUS Community repositories}
with yum command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo yum install https://centos7.iuscommunity.org/ius\PYGZhy{}release.rpm
\end{sphinxVerbatim}

To compile DPDK, required to install following packages.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo yum install numactl\PYGZhy{}devel \PYG{l+s+se}{\PYGZbs{}}
  libarchive\PYGZhy{}devel \PYG{l+s+se}{\PYGZbs{}}
  kernel\PYGZhy{}headers \PYG{l+s+se}{\PYGZbs{}}
  kernel\PYGZhy{}devel
\end{sphinxVerbatim}

As same as Ubuntu, you should install additional packages because
SPP provides libpcap-based PMD for dumping packet to a file or retrieve
it from the file.
\sphinxcode{\sphinxupquote{spp\_nfv}} and \sphinxcode{\sphinxupquote{spp\_pcap}} use \sphinxcode{\sphinxupquote{libpcap-dev}} for packet capture.
\sphinxcode{\sphinxupquote{spp\_pcap}} uses \sphinxcode{\sphinxupquote{liblz4-dev}} and \sphinxcode{\sphinxupquote{liblz4-tool}} to compress PCAP file.
\sphinxcode{\sphinxupquote{text2pcap}} is also required for creating pcap file which is included in \sphinxcode{\sphinxupquote{wireshark}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo apt install libpcap\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
  libpcap \PYG{l+s+se}{\PYGZbs{}}
  libpcap\PYGZhy{}devel \PYG{l+s+se}{\PYGZbs{}}
  lz4 \PYG{l+s+se}{\PYGZbs{}}
  lz4\PYGZhy{}devel \PYG{l+s+se}{\PYGZbs{}}
  wireshark \PYG{l+s+se}{\PYGZbs{}}
  wireshark\PYGZhy{}devel \PYG{l+s+se}{\PYGZbs{}}
  libX11\PYGZhy{}devel
\end{sphinxVerbatim}


\subsection{DPDK}
\label{\detokenize{gsg/install:dpdk}}\label{\detokenize{gsg/install:setup-install-dpdk}}
Clone repository and compile DPDK in any directory.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/any
\PYG{g+gp}{\PYGZdl{}} git clone http://dpdk.org/git/dpdk
\end{sphinxVerbatim}

Installing on Ubuntu and CentOS are almost the same, but required packages
are just bit different.

PCAP is disabled by default in DPDK configuration.
\sphinxcode{\sphinxupquote{CONFIG\_RTE\_LIBRTE\_PMD\_PCAP}} and \sphinxcode{\sphinxupquote{CONFIG\_RTE\_PORT\_PCAP}} defined in
config file \sphinxcode{\sphinxupquote{common\_base}} should be changed to \sphinxcode{\sphinxupquote{y}} to enable PCAP.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} dpdk/config/common\PYGZus{}base
\PYG{g+go}{CONFIG\PYGZus{}RTE\PYGZus{}LIBRTE\PYGZus{}PMD\PYGZus{}PCAP=y}
\PYG{g+go}{...}
\PYG{g+go}{CONFIG\PYGZus{}RTE\PYGZus{}PORT\PYGZus{}PCAP=y}
\end{sphinxVerbatim}

Compile DPDK with target environment.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} dpdk
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{export} \PYG{n+nv}{RTE\PYGZus{}SDK}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}\PYG{n+nb}{pwd}\PYG{k}{)}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{export} \PYG{n+nv}{RTE\PYGZus{}TARGET}\PYG{o}{=}x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc  \PYG{c+c1}{\PYGZsh{} depends on your env}
\PYG{g+gp}{\PYGZdl{}} make install \PYG{n+nv}{T}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}RTE\PYGZus{}TARGET}
\end{sphinxVerbatim}

PCAP is disabled by default in DPDK configuration, so should be changed
if you use this feature.
\sphinxcode{\sphinxupquote{CONFIG\_RTE\_LIBRTE\_PMD\_PCAP}} and \sphinxcode{\sphinxupquote{CONFIG\_RTE\_PORT\_PCAP}} defined in
config file \sphinxcode{\sphinxupquote{common\_base}} should be changed to \sphinxcode{\sphinxupquote{y}} to enable PCAP.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} dpdk/config/common\PYGZus{}base
\PYG{g+go}{CONFIG\PYGZus{}RTE\PYGZus{}LIBRTE\PYGZus{}PMD\PYGZus{}PCAP=y}
\PYG{g+go}{...}
\PYG{g+go}{CONFIG\PYGZus{}RTE\PYGZus{}PORT\PYGZus{}PCAP=y}
\end{sphinxVerbatim}

Compile DPDK with options for target environment.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} dpdk
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{export} \PYG{n+nv}{RTE\PYGZus{}SDK}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}\PYG{n+nb}{pwd}\PYG{k}{)}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{export} \PYG{n+nv}{RTE\PYGZus{}TARGET}\PYG{o}{=}x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc  \PYG{c+c1}{\PYGZsh{} depends on your env}
\PYG{g+gp}{\PYGZdl{}} make install \PYG{n+nv}{T}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}RTE\PYGZus{}TARGET}
\end{sphinxVerbatim}


\subsection{Pyhton}
\label{\detokenize{gsg/install:pyhton}}
Python3 and pip3 are also required because SPP controller is implemented
in Pyhton3. Required packages can be installed from \sphinxcode{\sphinxupquote{requirements.txt}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Ubuntu
\PYG{g+gp}{\PYGZdl{}} sudo apt install python3 \PYG{l+s+se}{\PYGZbs{}}
  python3\PYGZhy{}pip
\end{sphinxVerbatim}

For CentOS, you need to specify minor version of python3.
Here is an example of installing python3.6.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} CentOS
\PYG{g+gp}{\PYGZdl{}} sudo yum install python36 \PYG{l+s+se}{\PYGZbs{}}
  python36\PYGZhy{}pip
\end{sphinxVerbatim}

SPP provides \sphinxcode{\sphinxupquote{requirements.txt}} for installing required packages of Python3.
You might fail to run \sphinxcode{\sphinxupquote{pip3}} without sudo on some environments.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} pip3 install \PYGZhy{}r requirements.txt
\end{sphinxVerbatim}

For some environments, \sphinxcode{\sphinxupquote{pip3}} might install packages under your home
directory \sphinxcode{\sphinxupquote{\$HOME/.local/bin}} and you should add it to \sphinxcode{\sphinxupquote{\$PATH}} environment
variable.


\subsection{SPP}
\label{\detokenize{gsg/install:spp}}\label{\detokenize{gsg/install:setup-install-spp}}
Clone SPP repository and compile it in any directory.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/any
\PYG{g+gp}{\PYGZdl{}} git clone http://dpdk.org/git/apps/spp
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} spp
\PYG{g+gp}{\PYGZdl{}} make  \PYG{c+c1}{\PYGZsh{} Confirm that \PYGZdl{}RTE\PYGZus{}SDK and \PYGZdl{}RTE\PYGZus{}TARGET are set}
\end{sphinxVerbatim}

If you use \sphinxcode{\sphinxupquote{spp\_mirror}} in deep copy mode,
which is used for cloning whole of packet data for modification,
you should change configuration of copy mode in Makefile of \sphinxcode{\sphinxupquote{spp\_mirror}}
before.
It is for copying full payload into a new mbuf.
Default mode is shallow copy.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} src/mirror/Makefile
\PYG{g+gp}{\PYGZsh{}}\PYG{n+nv}{CFLAGS} \PYG{o}{+=} \PYGZhy{}Dspp\PYGZus{}mirror\PYGZus{}SHALLOWCOPY
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Before run make command, you might need to consider if using deep copy
for cloning packets in \sphinxcode{\sphinxupquote{spp\_mirror}}. Comparing with shallow copy, it
clones entire packet payload into a new mbuf and it is modifiable,
but lower performance. Which of copy mode should be chosen depends on
your usage.
\end{sphinxadmonition}


\subsection{Binding Network Ports to DPDK}
\label{\detokenize{gsg/install:binding-network-ports-to-dpdk}}
Network ports must be bound to DPDK with a UIO (Userspace IO) driver.
UIO driver is for mapping device memory to userspace and registering
interrupts.


\subsubsection{UIO Drivers}
\label{\detokenize{gsg/install:uio-drivers}}
You usually use the standard \sphinxcode{\sphinxupquote{uio\_pci\_generic}} for many use cases
or \sphinxcode{\sphinxupquote{vfio-pci}} for more robust and secure cases.
Both of drivers are included by default in modern Linux kernel.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Activate uio\PYGZus{}pci\PYGZus{}generic
\PYG{g+gp}{\PYGZdl{}} sudo modprobe uio\PYGZus{}pci\PYGZus{}generic

\PYG{g+gp}{\PYGZsh{}} or vfio\PYGZhy{}pci
\PYG{g+gp}{\PYGZdl{}} sudo modprobe vfio\PYGZhy{}pci
\end{sphinxVerbatim}

You can also use kmod included in DPDK instead of \sphinxcode{\sphinxupquote{uio\_pci\_generic}}
or \sphinxcode{\sphinxupquote{vfio-pci}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo modprobe uio
\PYG{g+gp}{\PYGZdl{}} sudo insmod kmod/igb\PYGZus{}uio.ko
\end{sphinxVerbatim}


\subsubsection{Binding Network Ports}
\label{\detokenize{gsg/install:binding-network-ports}}
Once UIO driver is activated, bind network ports with the driver.
DPDK provides \sphinxcode{\sphinxupquote{usertools/dpdk-devbind.py}} for managing devices.

Find ports for binding to DPDK by running the tool with \sphinxcode{\sphinxupquote{-s}} option.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nv}{\PYGZdl{}RTE\PYGZus{}SDK}/usertools/dpdk\PYGZhy{}devbind.py \PYGZhy{}\PYGZhy{}status

\PYG{g+go}{Network devices using DPDK\PYGZhy{}compatible driver}
\PYG{g+go}{============================================}
\PYG{g+go}{\PYGZlt{}none\PYGZgt{}}

\PYG{g+go}{Network devices using kernel driver}
\PYG{g+go}{===================================}
\PYG{g+go}{0000:29:00.0 \PYGZsq{}82571EB ... 10bc\PYGZsq{} if=enp41s0f0 drv=e1000e unused=}
\PYG{g+go}{0000:29:00.1 \PYGZsq{}82571EB ... 10bc\PYGZsq{} if=enp41s0f1 drv=e1000e unused=}
\PYG{g+go}{0000:2a:00.0 \PYGZsq{}82571EB ... 10bc\PYGZsq{} if=enp42s0f0 drv=e1000e unused=}
\PYG{g+go}{0000:2a:00.1 \PYGZsq{}82571EB ... 10bc\PYGZsq{} if=enp42s0f1 drv=e1000e unused=}

\PYG{g+go}{Other Network devices}
\PYG{g+go}{=====================}
\PYG{g+go}{\PYGZlt{}none\PYGZgt{}}
\PYG{g+go}{....}
\end{sphinxVerbatim}

You can find network ports are bound to kernel driver and not to DPDK.
To bind a port to DPDK, run \sphinxcode{\sphinxupquote{dpdk-devbind.py}} with specifying a driver
and a device ID.
Device ID is a PCI address of the device or more friendly style like
\sphinxcode{\sphinxupquote{eth0}} found by \sphinxcode{\sphinxupquote{ifconfig}} or \sphinxcode{\sphinxupquote{ip}} command..

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Bind a port with 2a:00.0 \PYG{o}{(}PCI address\PYG{o}{)}
\PYG{g+go}{./usertools/dpdk\PYGZhy{}devbind.py \PYGZhy{}\PYGZhy{}bind=uio\PYGZus{}pci\PYGZus{}generic 2a:00.0}

\PYG{g+gp}{\PYGZsh{}} or eth0
\PYG{g+go}{./usertools/dpdk\PYGZhy{}devbind.py \PYGZhy{}\PYGZhy{}bind=uio\PYGZus{}pci\PYGZus{}generic eth0}
\end{sphinxVerbatim}

After binding two ports, you can find it is under the DPDK driver and
cannot find it by using \sphinxcode{\sphinxupquote{ifconfig}} or \sphinxcode{\sphinxupquote{ip}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nv}{\PYGZdl{}RTE\PYGZus{}SDK}/usertools/dpdk\PYGZhy{}devbind.py \PYGZhy{}s

\PYG{g+go}{Network devices using DPDK\PYGZhy{}compatible driver}
\PYG{g+go}{============================================}
\PYG{g+go}{0000:2a:00.0 \PYGZsq{}82571EB ... 10bc\PYGZsq{} drv=uio\PYGZus{}pci\PYGZus{}generic unused=vfio\PYGZhy{}pci}
\PYG{g+go}{0000:2a:00.1 \PYGZsq{}82571EB ... 10bc\PYGZsq{} drv=uio\PYGZus{}pci\PYGZus{}generic unused=vfio\PYGZhy{}pci}

\PYG{g+go}{Network devices using kernel driver}
\PYG{g+go}{===================================}
\PYG{g+go}{0000:29:00.0 \PYGZsq{}...\PYGZsq{} if=enp41s0f0 drv=e1000e unused=vfio\PYGZhy{}pci,uio\PYGZus{}pci\PYGZus{}generic}
\PYG{g+go}{0000:29:00.1 \PYGZsq{}...\PYGZsq{} if=enp41s0f1 drv=e1000e unused=vfio\PYGZhy{}pci,uio\PYGZus{}pci\PYGZus{}generic}

\PYG{g+go}{Other Network devices}
\PYG{g+go}{=====================}
\PYG{g+go}{\PYGZlt{}none\PYGZgt{}}
\PYG{g+go}{....}
\end{sphinxVerbatim}


\subsection{Confirm DPDK is setup properly}
\label{\detokenize{gsg/install:confirm-dpdk-is-setup-properly}}
For testing, you can confirm if you are ready to use DPDK by running
DPDK’s sample application. \sphinxcode{\sphinxupquote{l2fwd}} is good example to confirm it
before SPP because it is very similar to SPP’s worker process for forwarding.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} \PYG{n+nv}{\PYGZdl{}RTE\PYGZus{}SDK}/examples/l2fwd
\PYG{g+gp}{\PYGZdl{}} make
\PYG{g+go}{  CC main.o}
\PYG{g+go}{  LD l2fwd}
\PYG{g+go}{  INSTALL\PYGZhy{}APP l2fwd}
\PYG{g+go}{  INSTALL\PYGZhy{}MAP l2fwd.map}
\end{sphinxVerbatim}

In this case, run this application simply with just two options
while DPDK has many kinds of options.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{-l}}: core list

\item {} 
\sphinxcode{\sphinxupquote{-p}}: port mask

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo ./build/app/l2fwd \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}l \PYG{l+m}{1}\PYGZhy{}2 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{} \PYGZhy{}p 0x3
\end{sphinxVerbatim}

It must be separated with \sphinxcode{\sphinxupquote{-{-}}} to specify which option is
for EAL or application.
Refer to \sphinxhref{https://dpdk.org/doc/guides/sample\_app\_ug/l2\_forward\_real\_virtual.html}{L2 Forwarding Sample Application}
for more details.


\subsection{Build Documentation}
\label{\detokenize{gsg/install:build-documentation}}
This documentation is able to be built as HTML and PDF formats from make
command. Before compiling the documentation, you need to install some of
packages required to compile.

For HTML documentation, install sphinx and additional theme.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} pip3 install sphinx \PYG{l+s+se}{\PYGZbs{}}
  sphinx\PYGZhy{}rtd\PYGZhy{}theme
\end{sphinxVerbatim}

For PDF, inkscape and latex packages are required.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Ubuntu
\PYG{g+gp}{\PYGZdl{}} sudo apt install inkscape \PYG{l+s+se}{\PYGZbs{}}
  texlive\PYGZhy{}latex\PYGZhy{}extra \PYG{l+s+se}{\PYGZbs{}}
  texlive\PYGZhy{}latex\PYGZhy{}recommended
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} CentOS
\PYG{g+gp}{\PYGZdl{}} sudo yum install inkscape \PYG{l+s+se}{\PYGZbs{}}
  texlive\PYGZhy{}latex
\end{sphinxVerbatim}

You might also need to install \sphinxcode{\sphinxupquote{latexmk}} in addition to if you use
Ubuntu 18.04 LTS.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo apt install latexmk
\end{sphinxVerbatim}

HTML documentation is compiled by running make with \sphinxcode{\sphinxupquote{doc-html}}. This
command launch sphinx for compiling HTML documents.
Compiled HTML files are created in \sphinxcode{\sphinxupquote{docs/guides/\_build/html/}} and
You can find the top page \sphinxcode{\sphinxupquote{index.html}} in the directory.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} make doc\PYGZhy{}html
\end{sphinxVerbatim}

PDF documentation is compiled with \sphinxcode{\sphinxupquote{doc-pdf}} which runs latex for.
Compiled PDF file is created as \sphinxcode{\sphinxupquote{docs/guides/\_build/html/SoftPatchPanel.pdf}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} make doc\PYGZhy{}pdf
\end{sphinxVerbatim}

You can also compile both of HTML and PDF documentations with \sphinxcode{\sphinxupquote{doc}} or
\sphinxcode{\sphinxupquote{doc-all}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} make doc
\PYG{g+gp}{\PYGZsh{}} or
\PYG{g+gp}{\PYGZdl{}} make doc\PYGZhy{}all
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
For CentOS, compilation PDF document is not supported.
\end{sphinxadmonition}


\section{How to Use}
\label{\detokenize{gsg/howto_use:how-to-use}}\label{\detokenize{gsg/howto_use:spp-gsg-howto-use}}\label{\detokenize{gsg/howto_use::doc}}
As described in {\hyperref[\detokenize{design/spp:spp-overview-design}]{\sphinxcrossref{\DUrole{std,std-ref}{Design}}}}, SPP consists of
primary process for managing resources, secondary processes for
forwarding packet, and SPP controller to accept user commands and
send it to SPP processes.

You should keep in mind the order of launching processes if you do it
manually, or you can use startup script. This start script is for launching
\sphinxcode{\sphinxupquote{spp-ctl}}, \sphinxcode{\sphinxupquote{spp\_primary}} and SPP CLI.

Before starting, you should define environmental variable \sphinxcode{\sphinxupquote{SPP\_FILE\_PREFIX}}
for using the same prefix among SPP processes. \sphinxcode{\sphinxupquote{-{-}file-prefix}} is an EAL
option for using a different shared data file prefix for a DPDK process.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{export} \PYG{n+nv}{SPP\PYGZus{}FILE\PYGZus{}PREFIX}\PYG{o}{=}spp
\end{sphinxVerbatim}

This option is used for running several DPDK processes because it is not
allowed different processes to have the same name of share data file, although
each process of multi-process application should have the same prefix on the
contrary.
Even if you do not run several DPDK applications, you do not need to define
actually. However, it is a good practice because SPP is used for connecting
DPDK applications in actual usecases.


\subsection{Quick Start}
\label{\detokenize{gsg/howto_use:quick-start}}\label{\detokenize{gsg/howto_use:spp-gsg-howto-quick-start}}
Run \sphinxcode{\sphinxupquote{bin/start.sh}} with configuration file \sphinxcode{\sphinxupquote{bin/config.sh}}. However,
at the first time you run the script, it is failed because this configration
file does not exist. It create the config from template
\sphinxcode{\sphinxupquote{bin/sample/config.sh}} and asks you to edit this file.
All of options for launching the processes are defined in the configuration
file.

Edit the config file before run \sphinxcode{\sphinxupquote{bin/start.sh}} again. It is expected you
have two physical ports on your server, but it is configurable.
You can use virtual ports instead of physical.
The number of ports is defined as \sphinxcode{\sphinxupquote{PRI\_PORTMASK=0x03}} as default.
If you do not have physical ports and use two memif ports instead of physical,
uncomment \sphinxcode{\sphinxupquote{PRI\_MEMIF\_VDEVS=(0 1)}}.
You can also use several types of port at once.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} spp\PYGZus{}primary options
...
PRI\PYGZus{}PORTMASK=0x03  \PYGZsh{} total num of ports of spp\PYGZus{}primary.

\PYGZsh{} Vdevs of spp\PYGZus{}primary
\PYGZsh{}PRI\PYGZus{}MEMIF\PYGZus{}VDEVS=(0 1)  \PYGZsh{} IDs of {}`net\PYGZus{}memif{}`
\PYGZsh{}PRI\PYGZus{}VHOST\PYGZus{}VDEVS=(11 12)  \PYGZsh{} IDs of {}`eth\PYGZus{}vhost{}`
...
\end{sphinxVerbatim}

After that, you can run the startup script again for launching processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} launch with default URL http://127.0.0.1:7777
\PYG{g+gp}{\PYGZdl{}} bin/start.sh
\PYG{g+go}{Start spp\PYGZhy{}ctl}
\PYG{g+go}{Start spp\PYGZus{}primary}
\PYG{g+go}{Waiting for spp\PYGZus{}primary is ready .................... OK! (8.5[sec])}
\PYG{g+go}{Welcome to the SPP CLI. Type {}`help{}` or {}`?{}` to list commands.}

\PYG{g+go}{spp \PYGZgt{}}
\end{sphinxVerbatim}

Check status of \sphinxcode{\sphinxupquote{spp\_primary}} because it takes several seconds to be ready.
Confirm that the status is \sphinxcode{\sphinxupquote{running}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} status
\PYGZhy{} spp\PYGZhy{}ctl:
  \PYGZhy{} address: 127.0.0.1:7777
\PYGZhy{} primary:
  \PYGZhy{} status: running
\PYGZhy{} secondary:
  \PYGZhy{} processes:
\end{sphinxVerbatim}

Now you are ready to launch secondary processes from \sphinxcode{\sphinxupquote{pri; launch}}
command, or another terminal. Here is an example for launching \sphinxcode{\sphinxupquote{spp\_nfv}}
with options from \sphinxcode{\sphinxupquote{pri; launch}}.
Log file of this process is created as \sphinxcode{\sphinxupquote{log/spp\_nfv1.log}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pri; launch nfv 1 \PYGZhy{}l 1,2 \PYGZhy{}m 512 \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix spp \PYGZhy{}\PYGZhy{} \PYGZhy{}n 1 \PYGZhy{}s ...
\end{sphinxVerbatim}

This \sphinxcode{\sphinxupquote{launch}} command supports TAB completion. Parameters for \sphinxcode{\sphinxupquote{spp\_nfv}}
are completed after secondary ID \sphinxcode{\sphinxupquote{1}}.

You might notice \sphinxcode{\sphinxupquote{-{-}file-prefix spp}} which should be the same value among
primary and secondary processes. SPP CLI expects that this value can be
referred as environmental variable \sphinxcode{\sphinxupquote{SPP\_FILE\_PREFIX}}, and spp\_primary is
launched with the same \sphinxcode{\sphinxupquote{-{-}file-prefix spp}}.
If you run SPP from \sphinxcode{\sphinxupquote{bin/start.sh}}, you do no need to define the variable
by yourself because it is defined in \sphinxcode{\sphinxupquote{bin/config.sh}} so that spp\_primary is
launched with the prefix.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pri; launch nfv 1

\PYGZsh{} Press TAB
spp \PYGZgt{} pri; launch nfv 1 \PYGZhy{}l 1,2 \PYGZhy{}m 512 \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix spp \PYGZhy{}\PYGZhy{} \PYGZhy{}n 1 \PYGZhy{}s ...
\end{sphinxVerbatim}

It is same as following options launching from terminal.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo ./src/nfv/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}nfv \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{1},2 \PYGZhy{}n \PYG{l+m}{4} \PYGZhy{}m \PYG{l+m}{512} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type secondary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix spp \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}n \PYG{l+m}{1} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}s \PYG{l+m}{127}.0.0.1:6666
\end{sphinxVerbatim}

Parameters for completion are defined in SPP CLI, and you can find
parameters with \sphinxcode{\sphinxupquote{config}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} config
\PYGZhy{} max\PYGZus{}secondary: \PYGZdq{}16\PYGZdq{}   \PYGZsh{} The maximum number of secondary processes
\PYGZhy{} prompt: \PYGZdq{}spp \PYGZgt{} \PYGZdq{}  \PYGZsh{} Command prompt
\PYGZhy{} topo\PYGZus{}size: \PYGZdq{}60\PYGZpc{}\PYGZdq{}  \PYGZsh{} Percentage or ratio of topo
\PYGZhy{} sec\PYGZus{}mem: \PYGZdq{}\PYGZhy{}m 512\PYGZdq{} \PYGZsh{} Mem size
...
\end{sphinxVerbatim}

You can launch consequence secondary processes from CLI for your usage.
If you just patch two DPDK applications on host, it is enough to use one
\sphinxcode{\sphinxupquote{spp\_nfv}}, or use \sphinxcode{\sphinxupquote{spp\_vf}} if you need to classify packets.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pri; launch nfv 2 \PYGZhy{}l 1,3 \PYGZhy{}m 512 \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix spp \PYGZhy{}\PYGZhy{} \PYGZhy{}n 2 \PYGZhy{}s ...
spp \PYGZgt{} pri; launch vf 3 \PYGZhy{}l 1,4,5,6 \PYGZhy{}m 512 \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix spp \PYGZhy{}\PYGZhy{} \PYGZhy{}n 3 \PYGZhy{}s ...
...
\end{sphinxVerbatim}

If you launch processes by yourself, \sphinxcode{\sphinxupquote{spp\_primary}} must be launched
before secondary processes.
\sphinxcode{\sphinxupquote{spp-ctl}} need to be launched before SPP CLI, but no need to be launched
before other processes. SPP CLI is launched from \sphinxcode{\sphinxupquote{spp.py}}.
If \sphinxcode{\sphinxupquote{spp-ctl}} is not running after primary and
secondary processes are launched, processes wait \sphinxcode{\sphinxupquote{spp-ctl}} is launched.

In general, \sphinxcode{\sphinxupquote{spp-ctl}} should be launched first, then SPP CLI and
\sphinxcode{\sphinxupquote{spp\_primary}} in each of terminals without running as background process.
After \sphinxcode{\sphinxupquote{spp\_primary}}, you launch secondary processes for your usage.

In the rest of this chapter is for explaining how to launch each of processes
options and usages for the all of processes.
How to connect to VMs is also described in this chapter.

How to use of these secondary processes is described as usecases
in the next chapter.


\subsection{SPP Controller}
\label{\detokenize{gsg/howto_use:spp-controller}}\label{\detokenize{gsg/howto_use:spp-gsg-howto-controller}}
SPP Controller consists of \sphinxcode{\sphinxupquote{spp-ctl}} and SPP CLI.


\subsubsection{spp-ctl}
\label{\detokenize{gsg/howto_use:spp-ctl}}
\sphinxcode{\sphinxupquote{spp-ctl}} is a HTTP server for REST APIs for managing SPP
processes. In default, it is accessed with URL \sphinxcode{\sphinxupquote{http://127.0.0.1:7777}}
or \sphinxcode{\sphinxupquote{http://localhost:7777}}.
\sphinxcode{\sphinxupquote{spp-ctl}} shows no messages at first after launched, but shows
log messages for events such as receiving a request or terminating
a process.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl
\end{sphinxVerbatim}

It has a option \sphinxcode{\sphinxupquote{-b}} for binding address explicitly to be accessed
from other than default, \sphinxcode{\sphinxupquote{127.0.0.1}} or \sphinxcode{\sphinxupquote{localhost}}.
If you deploy SPP on multiple nodes, you might need to use \sphinxcode{\sphinxupquote{-b}} option
it to be accessed from other processes running on other than local node.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} launch with URL http://192.168.1.100:7777
\PYG{g+gp}{\PYGZdl{}} python3 src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{spp-ctl}} is the most important process in SPP. For some usecases,
you might better to manage this process with \sphinxcode{\sphinxupquote{systemd}}.
Here is a simple example of service file for systemd.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
[Unit]
Description = SPP Controller

[Service]
ExecStart = /usr/bin/python3 /path/to/spp/src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl
User = root
\end{sphinxVerbatim}

All of options can be referred with help option \sphinxcode{\sphinxupquote{-h}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{python3 ./src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl \PYGZhy{}h}
\PYG{g+go}{usage: spp\PYGZhy{}ctl [\PYGZhy{}h] [\PYGZhy{}b BIND\PYGZus{}ADDR] [\PYGZhy{}p PRI\PYGZus{}PORT] [\PYGZhy{}s SEC\PYGZus{}PORT] [\PYGZhy{}a API\PYGZus{}PORT]}

\PYG{g+go}{SPP Controller}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help            show this help message and exit}
\PYG{g+go}{  \PYGZhy{}b BIND\PYGZus{}ADDR, \PYGZhy{}\PYGZhy{}bind\PYGZhy{}addr BIND\PYGZus{}ADDR}
\PYG{g+go}{                        bind address, default=localhost}
\PYG{g+go}{  \PYGZhy{}p PRI\PYGZus{}PORT           primary port, default=5555}
\PYG{g+go}{  \PYGZhy{}s SEC\PYGZus{}PORT           secondary port, default=6666}
\PYG{g+go}{  \PYGZhy{}a API\PYGZus{}PORT           web api port, default=7777}
\end{sphinxVerbatim}


\subsubsection{SPP CLI}
\label{\detokenize{gsg/howto_use:spp-cli}}\label{\detokenize{gsg/howto_use:spp-setup-howto-use-spp-cli}}
If \sphinxcode{\sphinxupquote{spp-ctl}} is launched, go to the next terminal and launch SPP CLI.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py
\PYG{g+go}{Welcome to the spp.   Type help or ? to list commands.}

\PYG{g+go}{spp \PYGZgt{}}
\end{sphinxVerbatim}

If you launched \sphinxcode{\sphinxupquote{spp-ctl}} with \sphinxcode{\sphinxupquote{-b}} option, you also need to use the same
option for \sphinxcode{\sphinxupquote{spp.py}}, or failed to connect and to launch.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZsh{}} \PYG{n+nb}{bind} to spp\PYGZhy{}ctl on http://192.168.1.100:7777
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\PYG{g+go}{Welcome to the spp.   Type help or ? to list commands.}

\PYG{g+go}{spp \PYGZgt{}}
\end{sphinxVerbatim}

One of the typical usecase of this option is to deploy multiple SPP nodes.
\hyperref[\detokenize{gsg/howto_use:figure-spp-howto-multi-spp}]{Fig.\@ \ref{\detokenize{gsg/howto_use:figure-spp-howto-multi-spp}}} is an exmaple of multiple nodes case.
There are three nodes on each of which \sphinxcode{\sphinxupquote{spp-ctl}} is running for accepting
requests for SPP. These \sphinxcode{\sphinxupquote{spp-ctl}} processes are controlled from
\sphinxcode{\sphinxupquote{spp.py}} on host1 and all of paths are configured across the nodes.
It is also able to be configured between hosts by changing
soure or destination of phy ports.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.800\linewidth]{{spp_howto_multi_spp}.pdf}
\caption{Multiple SPP nodes}\label{\detokenize{gsg/howto_use:id1}}\label{\detokenize{gsg/howto_use:figure-spp-howto-multi-spp}}\end{figure}

Launch SPP CLI with three entries of binding addresses with \sphinxcode{\sphinxupquote{-b}} option
for specifying \sphinxcode{\sphinxupquote{spp-ctl}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Launch SPP CLI with three nodes
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py \PYGZhy{}b \PYG{l+m}{192}.168.11.101 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}b \PYG{l+m}{192}.168.11.102 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}b \PYG{l+m}{192}.168.11.103 \PYG{l+s+se}{\PYGZbs{}}
\end{sphinxVerbatim}

You can also add nodes after SPP CLI is launched.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Launch SPP CLI with one node
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py \PYGZhy{}b \PYG{l+m}{192}.168.11.101
\PYG{g+go}{Welcome to the SPP CLI. Type {}`help{}` or {}`?{}` to list commands.}

\PYG{g+gp}{\PYGZsh{}} Add the rest of nodes after
\PYG{g+go}{spp \PYGZgt{} server add 192.168.11.102}
\PYG{g+go}{Registered spp\PYGZhy{}ctl \PYGZdq{}192.168.11.102:7777\PYGZdq{}.}
\PYG{g+go}{spp \PYGZgt{} server add 192.168.11.103}
\PYG{g+go}{Registered spp\PYGZhy{}ctl \PYGZdq{}192.168.11.103:7777\PYGZdq{}.}
\end{sphinxVerbatim}

You find the host under the management of SPP CLI and switch with
\sphinxcode{\sphinxupquote{server}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} server list
  1: 192.168.1.101:7777 *
  2: 192.168.1.102:7777
  3: 192.168.1.103:7777
\end{sphinxVerbatim}

To change the server, add an index number after \sphinxcode{\sphinxupquote{server}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} Launch SPP CLI
spp \PYGZgt{} server 3
Switch spp\PYGZhy{}ctl to \PYGZdq{}3: 192.168.1.103:7777\PYGZdq{}.
\end{sphinxVerbatim}

All of options can be referred with help option \sphinxcode{\sphinxupquote{-h}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py \PYGZhy{}h
\PYG{g+go}{usage: spp.py [\PYGZhy{}h] [\PYGZhy{}b BIND\PYGZus{}ADDR] [\PYGZhy{}a API\PYGZus{}PORT]}

\PYG{g+go}{SPP Controller}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help            show this help message and exit}
\PYG{g+go}{  \PYGZhy{}b BIND\PYGZus{}ADDR, \PYGZhy{}\PYGZhy{}bind\PYGZhy{}addr BIND\PYGZus{}ADDR}
\PYG{g+go}{                        bind address, default=127.0.0.1:7777}
\end{sphinxVerbatim}

All of SPP CLI commands are described in {\hyperref[\detokenize{commands/index::doc}]{\sphinxcrossref{\DUrole{doc}{SPP Commands}}}}.


\paragraph{Default Configuration}
\label{\detokenize{gsg/howto_use:default-configuration}}
SPP CLI imports several params from configuration file while launching.
Some of behaviours of SPP CLI depends on the params.
The default configuration is defined in
\sphinxcode{\sphinxupquote{src/controller/config/default.yml}}.
You can change this params by editing the config file, or from \sphinxcode{\sphinxupquote{config}}
command after SPP CLI is launched.

All of config params are referred by \sphinxcode{\sphinxupquote{config}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} show list of config
spp \PYGZgt{} config
\PYGZhy{} max\PYGZus{}secondary: \PYGZdq{}16\PYGZdq{}       \PYGZsh{} The maximum number of secondary processes
\PYGZhy{} sec\PYGZus{}nfv\PYGZus{}nof\PYGZus{}lcores: \PYGZdq{}1\PYGZdq{}   \PYGZsh{} Default num of lcores for workers of spp\PYGZus{}nfv
....
\end{sphinxVerbatim}

To change the config, set a value for the param.
Here is an example for changing command prompt.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} set prompt to \PYGZdq{}\PYGZdl{} spp \PYGZdq{}
spp \PYGZgt{} config prompt \PYGZdq{}\PYGZdl{} spp \PYGZdq{}
Set prompt: \PYGZdq{}\PYGZdl{} spp \PYGZdq{}
\PYGZdl{} spp
\end{sphinxVerbatim}


\subsection{SPP Primary}
\label{\detokenize{gsg/howto_use:spp-primary}}\label{\detokenize{gsg/howto_use:spp-gsg-howto-pri}}
SPP primary is a resource manager and has a responsibility for
initializing EAL for secondary processes. It should be launched before
secondary.

To launch SPP primary, run \sphinxcode{\sphinxupquote{spp\_primary}} with specific options.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/primary/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem \PYG{l+m}{512},512 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}huge\PYGZhy{}dir /dev/hugepages \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix \PYG{n+nv}{\PYGZdl{}SPP\PYGZus{}FILE\PYGZus{}PREFIX} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}base\PYGZhy{}virtaddr 0x100000000
\PYG{g+go}{    \PYGZhy{}\PYGZhy{} \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}p 0x03 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}n 10 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}s 192.168.1.100:5555}
\end{sphinxVerbatim}

SPP primary takes EAL options and application specific options.

Core list option \sphinxcode{\sphinxupquote{-l}} is for assigining cores and SPP primary requires just
one core. You can use core mask option \sphinxcode{\sphinxupquote{-c}} instead of \sphinxcode{\sphinxupquote{-l}}.
For memory, this example is for reserving 512 MB on each of two NUMA nodes
hardware, so you use \sphinxcode{\sphinxupquote{-m 1024}} simply, or \sphinxcode{\sphinxupquote{-{-}socket-mem 1024,0}}
if you run the process on single NUMA node.

\begin{sphinxadmonition}{note}{Note:}
If you use DPDK v18.08 or before,
you should consider give \sphinxcode{\sphinxupquote{-{-}base-virtaddr}} with 4 GiB or higher value
because a secondary process is accidentally failed to mmap while init
memory. The reason of the failure is secondary process tries to reserve
the region which is already used by some of thread of primary.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Failed to secondary
\PYG{g+go}{EAL: Could not mmap 17179869184 ... \PYGZhy{} please use \PYGZsq{}\PYGZhy{}\PYGZhy{}base\PYGZhy{}virtaddr\PYGZsq{} option}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{-{-}base-virtaddr}} is to decide base address explicitly to avoid this
overlapping. 4 GiB \sphinxcode{\sphinxupquote{0x100000000}} is enough for the purpose.

If you use DPDK v18.11 or later, \sphinxcode{\sphinxupquote{-{-}base-virtaddr 0x100000000}} is enabled
in default. You need to use this option only for changing the default value.
\end{sphinxadmonition}

If \sphinxcode{\sphinxupquote{spp\_primary}} is launched with two or more lcores, forwarder or monitor
is activated. The default is forwarder and monitor is optional in this case.
If you use monitor thread, additional option \sphinxcode{\sphinxupquote{-{-}disp-stat}} is required.
Here is an example for launching \sphinxcode{\sphinxupquote{spp\_primary}} with monitor thread.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/primary/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{0}\PYGZhy{}1 \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{} }  \PYG{c+c1}{\PYGZsh{} two lcores}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem 512,512 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}huge\PYGZhy{}dir /dev/hugepages \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type primary \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix \PYGZdl{}SPP\PYGZus{}FILE\PYGZus{}PREFIX \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}base\PYGZhy{}virtaddr 0x100000000}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{} \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}p 0x03 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}n 10 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}s 192.168.1.100:5555}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}disp\PYGZhy{}stats}
\end{sphinxVerbatim}

Primary process sets up physical ports of given port mask with \sphinxcode{\sphinxupquote{-p}} option
and ring ports of the number of \sphinxcode{\sphinxupquote{-n}} option. Ports of  \sphinxcode{\sphinxupquote{-p}} option is for
accepting incomming packets and \sphinxcode{\sphinxupquote{-n}} option is for inter-process packet
forwarding. You can also add ports initialized with \sphinxcode{\sphinxupquote{-{-}vdev}} option to
physical ports. However, ports added with \sphinxcode{\sphinxupquote{-{-}vdev}} cannot referred from
secondary processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/primary/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem \PYG{l+m}{512},512 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}huge\PYGZhy{}dir\PYG{o}{=}/dev/hugepages \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}vdev eth\PYGZus{}vhost1,iface\PYG{o}{=}/tmp/sock1  \PYG{c+c1}{\PYGZsh{} used as 1st phy port}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}vdev eth\PYGZus{}vhost2,iface=/tmp/sock2  \PYGZsh{} used as 2nd phy port}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type=primary \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix \PYGZdl{}SPP\PYGZus{}FILE\PYGZus{}PREFIX \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}base\PYGZhy{}virtaddr 0x100000000}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{} \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}p 0x03 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}n 10 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}s 192.168.1.100:5555}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
EAL options:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{-l}}: core list

\item {} 
\sphinxcode{\sphinxupquote{-{-}socket-mem}}: Memory size on each of NUMA nodes.

\item {} 
\sphinxcode{\sphinxupquote{-{-}huge-dir}}: Path of hugepage dir.

\item {} 
\sphinxcode{\sphinxupquote{-{-}proc-type}}: Process type.

\item {} 
\sphinxcode{\sphinxupquote{-{-}base-virtaddr}}: Specify base virtual address.

\item {} 
\sphinxcode{\sphinxupquote{-{-}disp-stats}}: Show statistics periodically.

\end{itemize}

\item {} 
Application options:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{-p}}: Port mask.

\item {} 
\sphinxcode{\sphinxupquote{-n}}: Number of ring PMD.

\item {} 
\sphinxcode{\sphinxupquote{-s}}: IP address of controller and port prepared for primary.

\end{itemize}

\end{itemize}


\subsection{SPP Secondary}
\label{\detokenize{gsg/howto_use:spp-secondary}}\label{\detokenize{gsg/howto_use:spp-gsg-howto-sec}}
Secondary process behaves as a client of primary process and a worker
for doing tasks for packet processing. There are several kinds of secondary
process, for example, simply forwarding between ports, classsifying packets
by referring its header or duplicate packets for redundancy.


\subsubsection{spp\_nfv}
\label{\detokenize{gsg/howto_use:spp-nfv}}
Run \sphinxcode{\sphinxupquote{spp\_nfv}} with options which simply forward packets as similar
as \sphinxcode{\sphinxupquote{l2fwd}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} sudo ./src/nfv/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}nfv \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{2}\PYGZhy{}3 \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type secondary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix \PYG{n+nv}{\PYGZdl{}SPP\PYGZus{}FILE\PYGZus{}PREFIX} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}n \PYG{l+m}{1} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}s \PYG{l+m}{192}.168.1.100:6666
\end{sphinxVerbatim}

EAL options are the same as primary process. Here is a list of application
options of \sphinxcode{\sphinxupquote{spp\_nfv}}.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{-n}}: Secondary ID.

\item {} 
\sphinxcode{\sphinxupquote{-s}}: IP address and secondary port of spp-ctl.

\item {} 
\sphinxcode{\sphinxupquote{-{-}vhost-client}}: Enable vhost-user client mode.

\end{itemize}

Secondary ID is used to identify for sending messages and must be
unique among all of secondaries.
If you attempt to launch a secondary process with the same ID, it
is failed.

If \sphinxcode{\sphinxupquote{-{-}vhost-client}} option is specified, then \sphinxcode{\sphinxupquote{vhost-user}} act as
the client, otherwise the server.
For reconnect feature from SPP to VM, \sphinxcode{\sphinxupquote{-{-}vhost-client}} option can be
used. This reconnect features requires QEMU 2.7 (or later).
See also \sphinxhref{http://dpdk.org/doc/guides/sample\_app\_ug/vhost.html}{Vhost Sample Application}.


\subsubsection{spp\_vf}
\label{\detokenize{gsg/howto_use:spp-vf}}
\sphinxcode{\sphinxupquote{spp\_vf}} is a kind of secondary process for classify or merge packets.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo ./src/vf/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}vf \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{2}\PYGZhy{}13 \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type secondary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix \PYG{n+nv}{\PYGZdl{}SPP\PYGZus{}FILE\PYGZus{}PREFIX} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}client\PYGZhy{}id \PYG{l+m}{1} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}s \PYG{l+m}{192}.168.1.100:6666 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}vhost\PYGZhy{}client
\end{sphinxVerbatim}

EAL options are the same as primary process. Here is a list of application
options of \sphinxcode{\sphinxupquote{spp\_vf}}.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{-{-}client-id}}: Client ID unique among secondary processes.

\item {} 
\sphinxcode{\sphinxupquote{-s}}: IPv4 address and secondary port of spp-ctl.

\item {} 
\sphinxcode{\sphinxupquote{-{-}vhost-client}}: Enable vhost-user client mode.

\end{itemize}


\subsubsection{spp\_mirror}
\label{\detokenize{gsg/howto_use:spp-mirror}}
\sphinxcode{\sphinxupquote{spp\_mirror}} is a kind of secondary process for duplicating packets,
and options are same as \sphinxcode{\sphinxupquote{spp\_vf}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo ./src/mirror/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}mirror \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{2},3 \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type secondary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix \PYG{n+nv}{\PYGZdl{}SPP\PYGZus{}FILE\PYGZus{}PREFIX} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}client\PYGZhy{}id \PYG{l+m}{1} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}s \PYG{l+m}{192}.168.1.100:6666 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}vhost\PYGZhy{}client
\end{sphinxVerbatim}

EAL options are the same as primary process. Here is a list of application
options of \sphinxcode{\sphinxupquote{spp\_mirror}}.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{-{-}client-id}}: Client ID unique among secondary processes.

\item {} 
\sphinxcode{\sphinxupquote{-s}}: IPv4 address and secondary port of spp-ctl.

\item {} 
\sphinxcode{\sphinxupquote{-{-}vhost-client}}: Enable vhost-user client mode.

\end{itemize}


\subsubsection{spp\_pcap}
\label{\detokenize{gsg/howto_use:spp-pcap}}\label{\detokenize{gsg/howto_use:spp-vf-gsg-howto-use-spp-pcap}}
Other than PCAP feature implemented as pcap port in \sphinxcode{\sphinxupquote{spp\_nfv}},
SPP provides \sphinxcode{\sphinxupquote{spp\_pcap}} for capturing comparatively heavy traffic.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo ./src/pcap/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}pcap \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{2}\PYGZhy{}5 \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type secondary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix \PYG{n+nv}{\PYGZdl{}SPP\PYGZus{}FILE\PYGZus{}PREFIX} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}client\PYGZhy{}id \PYG{l+m}{1} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}s \PYG{l+m}{192}.168.1.100:6666 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}c phy:0 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}out\PYGZhy{}dir /path/to/dir \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}fsize \PYG{l+m}{107374182}
\end{sphinxVerbatim}

EAL options are the same as primary process. Here is a list of application
options of \sphinxcode{\sphinxupquote{spp\_pcap}}.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{-{-}client-id}}: Client ID unique among secondary processes.

\item {} 
\sphinxcode{\sphinxupquote{-s}}: IPv4 address and secondary port of spp-ctl.

\item {} 
\sphinxcode{\sphinxupquote{-c}}: Captured port. Only \sphinxcode{\sphinxupquote{phy}} and \sphinxcode{\sphinxupquote{ring}} are supported.

\item {} 
\sphinxcode{\sphinxupquote{-{-}out-dir}}: Optional. Path of dir for captured file. Default is \sphinxcode{\sphinxupquote{/tmp}}.

\item {} 
\sphinxcode{\sphinxupquote{-{-}fsize}}: Optional. Maximum size of a capture file. Default is \sphinxcode{\sphinxupquote{1GiB}}.

\end{itemize}

Captured file of LZ4 is generated in \sphinxcode{\sphinxupquote{/tmp}} by default.
The name of file is consists of timestamp, resource ID of captured port,
ID of \sphinxcode{\sphinxupquote{writer}} threads and sequential number.
Timestamp is decided when capturing is started and formatted as
\sphinxcode{\sphinxupquote{YYYYMMDDhhmmss}}.
Both of \sphinxcode{\sphinxupquote{writer}} thread ID and sequential number are started from \sphinxcode{\sphinxupquote{1}}.
Sequential number is required for the case if the size of
captured file is reached to the maximum and another file is generated to
continue capturing.

This is an example of captured file. It consists of timestamp,
\sphinxcode{\sphinxupquote{20190214154925}}, port \sphinxcode{\sphinxupquote{phy0}}, thread ID \sphinxcode{\sphinxupquote{1}} and sequential number
\sphinxcode{\sphinxupquote{1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
/tmp/spp\PYGZus{}pcap.20190214154925.phy0.1.1.pcap.lz4
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{spp\_pcap}} also generates temporary files which are owned by each of
\sphinxcode{\sphinxupquote{writer}} threads until capturing is finished or the size of captured file
is reached to the maximum.
This temporary file has additional extension \sphinxcode{\sphinxupquote{tmp}} at the end of file
name.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
/tmp/spp\PYGZus{}pcap.20190214154925.phy0.1.1.pcap.lz4.tmp
\end{sphinxVerbatim}


\subsubsection{Launch from SPP CLI}
\label{\detokenize{gsg/howto_use:launch-from-spp-cli}}
You can launch SPP secondary processes from SPP CLI wihtout openning
other terminals. \sphinxcode{\sphinxupquote{pri; launch}} command is for any of secondary processes
with specific options. It takes secondary type, ID and options of EAL
and application itself as similar to launching from terminal.
Here is an example of launching \sphinxcode{\sphinxupquote{spp\_nfv}}. You notice that there is no
\sphinxcode{\sphinxupquote{-{-}proc-type secondary}} which should be required for secondary.
It is added to the options by SPP CLI before launching the process.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} launch spp\PYGZus{}nfv with sec ID 2
spp \PYGZgt{} pri; launch nfv 2 \PYGZhy{}l 1,2 \PYGZhy{}m 512 \PYGZhy{}\PYGZhy{} \PYGZhy{}n 2 \PYGZhy{}s 192.168.1.100:6666
Send request to launch nfv:2.
\end{sphinxVerbatim}

After running this command, you can find \sphinxcode{\sphinxupquote{nfv:2}} is launched
successfully.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} status
\PYGZhy{} spp\PYGZhy{}ctl:
  \PYGZhy{} address: 192.168.1.100:7777
\PYGZhy{} primary:
  \PYGZhy{} status: running
\PYGZhy{} secondary:
  \PYGZhy{} processes:
    1: nfv:2
\end{sphinxVerbatim}

Instead of displaying log messages in terminal, it outputs the messages
in a log file. All of log files of secondary processes launched with
\sphinxcode{\sphinxupquote{pri}} are located in \sphinxcode{\sphinxupquote{log/}} directory under the project root.
The name of log file is found \sphinxcode{\sphinxupquote{log/spp\_nfv-2.log}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{5}
\PYG{g+gp}{\PYGZdl{}} tail \PYGZhy{}f log/spp\PYGZus{}nfv\PYGZhy{}2.log
\PYG{g+go}{SPP\PYGZus{}NFV: Used lcores: 1 2}
\PYG{g+go}{SPP\PYGZus{}NFV: entering main loop on lcore 2}
\PYG{g+go}{SPP\PYGZus{}NFV: My ID 2 start handling message}
\PYG{g+go}{SPP\PYGZus{}NFV: [Press Ctrl\PYGZhy{}C to quit ...]}
\PYG{g+go}{SPP\PYGZus{}NFV: Creating socket...}
\PYG{g+go}{SPP\PYGZus{}NFV: Trying to connect ... socket 24}
\PYG{g+go}{SPP\PYGZus{}NFV: Connected}
\PYG{g+go}{SPP\PYGZus{}NFV: Received string: \PYGZus{}get\PYGZus{}client\PYGZus{}id}
\PYG{g+go}{SPP\PYGZus{}NFV: token 0 = \PYGZus{}get\PYGZus{}client\PYGZus{}id}
\PYG{g+go}{SPP\PYGZus{}NFV: To Server: \PYGZob{}\PYGZdq{}results\PYGZdq{}:[\PYGZob{}\PYGZdq{}result\PYGZdq{}:\PYGZdq{}success\PYGZdq{}\PYGZcb{}],\PYGZdq{}client\PYGZus{}id\PYGZdq{}:2, ...}
\end{sphinxVerbatim}


\subsubsection{Launch SPP on VM}
\label{\detokenize{gsg/howto_use:launch-spp-on-vm}}
To communicate DPDK application running on a VM,
it is required to create a virtual device for the VM.
In this instruction, launch a VM with qemu command and
create \sphinxcode{\sphinxupquote{vhost-user}} and \sphinxcode{\sphinxupquote{virtio-net-pci}} devices on the VM.

Before launching VM, you need to prepare a socket file for creating
\sphinxcode{\sphinxupquote{vhost-user}} device.
Run \sphinxcode{\sphinxupquote{add}} command with resource UID \sphinxcode{\sphinxupquote{vhost:0}} to create socket file.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} nfv 1; add vhost:0
\end{sphinxVerbatim}

In this example, it creates socket file with index 0 from \sphinxcode{\sphinxupquote{spp\_nfv}} of ID 1.
Socket file is created as \sphinxcode{\sphinxupquote{/tmp/sock0}}.
It is used as a qemu option to add vhost interface.

Launch VM with \sphinxcode{\sphinxupquote{qemu-system-x86\_64}} for x86 64bit architecture.
Qemu takes many options for defining resources including virtual
devices. You cannot use this example as it is because some options are
depend on your environment.
You should specify disk image with \sphinxcode{\sphinxupquote{-hda}}, sixth option in this
example, and \sphinxcode{\sphinxupquote{qemu-ifup}} script for assigning an IP address for the VM
to be able to access as 12th line.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{5}
\PYG{g+gp}{\PYGZdl{}} sudo qemu\PYGZhy{}system\PYGZhy{}x86\PYGZus{}64 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}cpu host \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}enable\PYGZhy{}kvm \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}numa node,memdev\PYG{o}{=}mem \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}mem\PYGZhy{}prealloc \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}hda /path/to/image.qcow2 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}m \PYG{l+m}{4096} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}smp \PYG{n+nv}{cores}\PYG{o}{=}\PYG{l+m}{4},threads\PYG{o}{=}\PYG{l+m}{1},sockets\PYG{o}{=}\PYG{l+m}{1} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}object \PYG{l+s+se}{\PYGZbs{}}
    memory\PYGZhy{}backend\PYGZhy{}file,id\PYG{o}{=}mem,size\PYG{o}{=}4096M,mem\PYGZhy{}path\PYG{o}{=}/dev/hugepages,share\PYG{o}{=}on \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}device e1000,netdev\PYG{o}{=}net0,mac\PYG{o}{=}\PYG{l+m}{00}:AD:BE:B3:11:00 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}netdev tap,id\PYG{o}{=}net0,ifname\PYG{o}{=}net0,script\PYG{o}{=}/path/to/qemu\PYGZhy{}ifup \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}nographic \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}chardev socket,id\PYG{o}{=}chr0,path\PYG{o}{=}/tmp/sock0 \PYG{l+s+se}{\PYGZbs{} } \PYG{c+c1}{\PYGZsh{} /tmp/sock0}
\PYG{g+go}{    \PYGZhy{}netdev vhost\PYGZhy{}user,id=net1,chardev=chr0,vhostforce \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}device virtio\PYGZhy{}net\PYGZhy{}pci,netdev=net1,mac=00:AD:BE:B4:11:00 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}monitor telnet::44911,server,nowait}
\end{sphinxVerbatim}

This VM has two network interfaces.
\sphinxcode{\sphinxupquote{-device e1000}} is a management network port
which requires \sphinxcode{\sphinxupquote{qemu-ifup}} to activate while launching.
Management network port is used for login and setup the VM.
\sphinxcode{\sphinxupquote{-device virtio-net-pci}} is created for SPP or DPDK application
running on the VM.

\sphinxcode{\sphinxupquote{vhost-user}} is a backend of \sphinxcode{\sphinxupquote{virtio-net-pci}} which requires
a socket file \sphinxcode{\sphinxupquote{/tmp/sock0}} created from secondary with \sphinxcode{\sphinxupquote{-chardev}}
option.

For other options, please refer to
\sphinxhref{https://qemu.weilnetz.de/doc/qemu-doc.html}{QEMU User Documentation}.

\begin{sphinxadmonition}{note}{Note:}
In general, you need to prepare several qemu images for launcing
several VMs, but installing DPDK and SPP for several images is bother
and time consuming.

You can shortcut this tasks by creating a template image and copy it
to the VMs. It is just one time for installing for template.
\end{sphinxadmonition}

After VM is booted, you install DPDK and SPP in the VM as in the host.
IP address of the VM is assigned while it is created and you can find
the address in a file generated from libvirt if you use Ubuntu.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{5}
\PYG{g+gp}{\PYGZdl{}} cat /var/lib/libvirt/dnsmasq/virbr0.status
\PYG{g+go}{[}
\PYG{g+go}{    \PYGZob{}}
\PYG{g+go}{        \PYGZdq{}ip\PYGZhy{}address\PYGZdq{}: \PYGZdq{}192.168.122.100\PYGZdq{},}
\PYG{g+go}{        ...}

\PYG{g+gp}{\PYGZsh{}} Login VM, install DPDK and SPP
\PYG{g+gp}{\PYGZdl{}} ssh user@192.168.122.100
\PYG{g+go}{...}
\end{sphinxVerbatim}

It is recommended to configure \sphinxcode{\sphinxupquote{/etc/default/grub}} for hugepages and
reboot the VM after installation.

Finally, login to the VM, bind ports to DPDK and launch \sphinxcode{\sphinxupquote{spp-ctl}}
and \sphinxcode{\sphinxupquote{spp\_primamry}}.
You should add \sphinxcode{\sphinxupquote{-b}} option to be accessed from SPP CLI on host.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{5}
\PYG{g+gp}{\PYGZdl{}} ssh user@192.168.122.100
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl \PYGZhy{}b \PYG{l+m}{192}.168.122.100
\PYG{g+go}{...}
\end{sphinxVerbatim}

Confirm that virtio interfaces are under the management of DPDK before
launching DPDK processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{6}
\PYG{g+gp}{\PYGZdl{}} ssh user@192.168.122.100
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} sudo ./src/primary/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{1} \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}m \PYG{l+m}{1024} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}huge\PYGZhy{}dir\PYG{o}{=}/dev/hugepages \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type\PYG{o}{=}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}base\PYGZhy{}virtaddr 0x100000000
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix \PYGZdl{}SPP\PYGZus{}FILE\PYGZus{}PREFIX \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{} \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}p 0x03 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}n 6 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}s 192.168.122.100:5555}
\end{sphinxVerbatim}

You can configure SPP running on the VM from SPP CLI.
Use \sphinxcode{\sphinxupquote{server}} command to switch node under the management.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} show list of spp\PYGZhy{}ctl nodes
spp \PYGZgt{} server
1: 192.168.1.100:7777 *
2: 192.168.122.100:7777

\PYGZsh{} change node under the management
spp \PYGZgt{} server 2
Switch spp\PYGZhy{}ctl to \PYGZdq{}2: 192.168.122.100:7777\PYGZdq{}.

\PYGZsh{} confirm node is switched
spp \PYGZgt{} server
1: 192.168.1.100:7777
2: 192.168.122.100:7777 *

\PYGZsh{} configure SPP on VM
spp \PYGZgt{} status
...
\end{sphinxVerbatim}

Now, you are ready to setup your network environment for DPDK and non-DPDK
applications with SPP.
SPP enables users to configure service function chaining between applications
running on host and VMs.
Usecases of network configuration are explained in the next chapter.


\subsubsection{Using virsh}
\label{\detokenize{gsg/howto_use:using-virsh}}\label{\detokenize{gsg/howto_use:spp-gsg-howto-virsh}}
First of all, please check version of qemu.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} qemu\PYGZhy{}system\PYGZhy{}x86\PYGZus{}64 \PYGZhy{}\PYGZhy{}version
\end{sphinxVerbatim}

You should install qemu 2.7 or higher for using vhost-user client mode.
Refer \sphinxhref{https://wiki.qemu.org/index.php/Hosts/Linux}{instruction}
to install.

\sphinxcode{\sphinxupquote{virsh}} is a command line interface that can be used to create, destroy,
stop start and edit VMs and configure.

You also need to install following packages to run \sphinxcode{\sphinxupquote{virt-install}}.
\begin{itemize}
\item {} 
libvirt-bin

\item {} 
virtinst

\item {} 
bridge-utils

\end{itemize}


\paragraph{virt-install}
\label{\detokenize{gsg/howto_use:virt-install}}
Install OS image with \sphinxcode{\sphinxupquote{virt-install}} command.
\sphinxcode{\sphinxupquote{-{-}location}} is a URL of installer. Use Ubuntu 16.04 for amd64 in this
case.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
http://archive.ubuntu.com/ubuntu/dists/xenial/main/installer\PYGZhy{}amd64/
\end{sphinxVerbatim}

This is an example of \sphinxcode{\sphinxupquote{virt-install}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{virt\PYGZhy{}install \PYGZbs{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}name VM\PYGZus{}NAME \PYGZbs{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}ram 4096 \PYGZbs{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}disk path=/var/lib/libvirt/images/VM\PYGZus{}NAME.img,size=30 \PYGZbs{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}vcpus 4 \PYGZbs{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}os\PYGZhy{}type linux \PYGZbs{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}os\PYGZhy{}variant ubuntu16.04 \PYGZbs{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}network network=default \PYGZbs{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}graphics none \PYGZbs{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}console pty,target\PYGZus{}type=serial \PYGZbs{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}location \PYGZsq{}http://archive.ubuntu.com/ubuntu/dists/xenial/main/...\PYGZsq{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}extra\PYGZhy{}args \PYGZsq{}console=ttyS0,115200n8 serial\PYGZsq{}}
\end{sphinxVerbatim}

You might need to enable serial console as following.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}}sudo systemctl \PYG{n+nb}{enable} serial\PYGZhy{}getty@ttyS0.service
\PYG{g+gp}{\PYGZdl{}}sudo systemctl start serial\PYGZhy{}getty@ttyS0.service
\end{sphinxVerbatim}


\paragraph{Edit Config}
\label{\detokenize{gsg/howto_use:edit-config}}
Edit configuration of VM with virsh command. The name of VMs are found from
\sphinxcode{\sphinxupquote{virsh list}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Find the name of VM
\PYG{g+gp}{\PYGZdl{}} sudo virsh list \PYGZhy{}\PYGZhy{}all

\PYG{g+gp}{\PYGZdl{}} sudo virsh edit VM\PYGZus{}NAME
\end{sphinxVerbatim}

You need to define namespace \sphinxcode{\sphinxupquote{qemu}} to use tags such as
\sphinxcode{\sphinxupquote{\textless{}qemu:commandline\textgreater{}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
xmlns:qemu=\PYGZsq{}http://libvirt.org/schemas/domain/qemu/1.0\PYGZsq{}
\end{sphinxVerbatim}

In addition, you need to add attributes for specific resources for DPDK and SPP.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\textless{}memoryBacking\textgreater{}}}

\item {} 
\sphinxcode{\sphinxupquote{\textless{}qemu:commandline\textgreater{}}}

\end{itemize}

Take care about the index numbers of devices should be the same value such as
\sphinxcode{\sphinxupquote{chr0}} or \sphinxcode{\sphinxupquote{sock0}} in \sphinxcode{\sphinxupquote{virtio-net-pci}} device. This index is referred as
ID of vhost port from SPP. MAC address defined in the attribute is used while
registering destinations for classifier’s table.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}virtio\PYGZhy{}net\PYGZhy{}pci,netdev=vhost\PYGZhy{}net0,mac=52:54:00:12:34:56\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
\end{sphinxVerbatim}

Here is an example of XML config for using with SPP.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{n+nt}{\PYGZlt{}domain} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}kvm\PYGZsq{}} \PYG{n+na}{xmlns:qemu=}\PYG{l+s}{\PYGZsq{}http://libvirt.org/schemas/domain/qemu/1.0\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}name}\PYG{n+nt}{\PYGZgt{}}spp\PYGZhy{}vm1\PYG{n+nt}{\PYGZlt{}/name\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}uuid}\PYG{n+nt}{\PYGZgt{}}d90f5420\PYGZhy{}861a\PYGZhy{}4479\PYGZhy{}8559\PYGZhy{}62d7a1545cb9\PYG{n+nt}{\PYGZlt{}/uuid\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}memory} \PYG{n+na}{unit=}\PYG{l+s}{\PYGZsq{}KiB\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}4194304\PYG{n+nt}{\PYGZlt{}/memory\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}currentMemory} \PYG{n+na}{unit=}\PYG{l+s}{\PYGZsq{}KiB\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}4194304\PYG{n+nt}{\PYGZlt{}/currentMemory\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}memoryBacking}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}hugepages}\PYG{n+nt}{/\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}/memoryBacking\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}vcpu} \PYG{n+na}{placement=}\PYG{l+s}{\PYGZsq{}static\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}4\PYG{n+nt}{\PYGZlt{}/vcpu\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}os}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}type} \PYG{n+na}{arch=}\PYG{l+s}{\PYGZsq{}x86\PYGZus{}64\PYGZsq{}} \PYG{n+na}{machine=}\PYG{l+s}{\PYGZsq{}pc\PYGZhy{}i440fx\PYGZhy{}2.3\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}hvm\PYG{n+nt}{\PYGZlt{}/type\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}boot} \PYG{n+na}{dev=}\PYG{l+s}{\PYGZsq{}hd\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}/os\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}features}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}acpi}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}apic}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}pae}\PYG{n+nt}{/\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}/features\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}clock} \PYG{n+na}{offset=}\PYG{l+s}{\PYGZsq{}utc\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}on\PYGZus{}poweroff}\PYG{n+nt}{\PYGZgt{}}destroy\PYG{n+nt}{\PYGZlt{}/on\PYGZus{}poweroff\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}on\PYGZus{}reboot}\PYG{n+nt}{\PYGZgt{}}restart\PYG{n+nt}{\PYGZlt{}/on\PYGZus{}reboot\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}on\PYGZus{}crash}\PYG{n+nt}{\PYGZgt{}}restart\PYG{n+nt}{\PYGZlt{}/on\PYGZus{}crash\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}devices}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}emulator}\PYG{n+nt}{\PYGZgt{}}/usr/local/bin/qemu\PYGZhy{}system\PYGZhy{}x86\PYGZus{}64\PYG{n+nt}{\PYGZlt{}/emulator\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}disk} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}file\PYGZsq{}} \PYG{n+na}{device=}\PYG{l+s}{\PYGZsq{}disk\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}driver} \PYG{n+na}{name=}\PYG{l+s}{\PYGZsq{}qemu\PYGZsq{}} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}raw\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}source} \PYG{n+na}{file=}\PYG{l+s}{\PYGZsq{}/var/lib/libvirt/images/spp\PYGZhy{}vm1.qcow2\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}target} \PYG{n+na}{dev=}\PYG{l+s}{\PYGZsq{}hda\PYGZsq{}} \PYG{n+na}{bus=}\PYG{l+s}{\PYGZsq{}ide\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}address} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}drive\PYGZsq{}} \PYG{n+na}{controller=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}} \PYG{n+na}{bus=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}} \PYG{n+na}{target=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}} \PYG{n+na}{unit=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/disk\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}disk} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}block\PYGZsq{}} \PYG{n+na}{device=}\PYG{l+s}{\PYGZsq{}cdrom\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}driver} \PYG{n+na}{name=}\PYG{l+s}{\PYGZsq{}qemu\PYGZsq{}} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}raw\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}target} \PYG{n+na}{dev=}\PYG{l+s}{\PYGZsq{}hdc\PYGZsq{}} \PYG{n+na}{bus=}\PYG{l+s}{\PYGZsq{}ide\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}readonly}\PYG{n+nt}{/\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}address} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}drive\PYGZsq{}} \PYG{n+na}{controller=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}} \PYG{n+na}{bus=}\PYG{l+s}{\PYGZsq{}1\PYGZsq{}} \PYG{n+na}{target=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}} \PYG{n+na}{unit=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/disk\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}controller} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}usb\PYGZsq{}} \PYG{n+na}{index=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}address} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}pci\PYGZsq{}} \PYG{n+na}{domain=}\PYG{l+s}{\PYGZsq{}0x0000\PYGZsq{}} \PYG{n+na}{bus=}\PYG{l+s}{\PYGZsq{}0x00\PYGZsq{}} \PYG{n+na}{slot=}\PYG{l+s}{\PYGZsq{}0x01\PYGZsq{}}
      \PYG{n+na}{function=}\PYG{l+s}{\PYGZsq{}0x2\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/controller\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}controller} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}pci\PYGZsq{}} \PYG{n+na}{index=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}} \PYG{n+na}{model=}\PYG{l+s}{\PYGZsq{}pci\PYGZhy{}root\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}controller} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}ide\PYGZsq{}} \PYG{n+na}{index=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}address} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}pci\PYGZsq{}} \PYG{n+na}{domain=}\PYG{l+s}{\PYGZsq{}0x0000\PYGZsq{}} \PYG{n+na}{bus=}\PYG{l+s}{\PYGZsq{}0x00\PYGZsq{}} \PYG{n+na}{slot=}\PYG{l+s}{\PYGZsq{}0x01\PYGZsq{}}
      \PYG{n+na}{function=}\PYG{l+s}{\PYGZsq{}0x1\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/controller\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}interface} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}network\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}mac} \PYG{n+na}{address=}\PYG{l+s}{\PYGZsq{}52:54:00:99:aa:7f\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}source} \PYG{n+na}{network=}\PYG{l+s}{\PYGZsq{}default\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}model} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}rtl8139\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}address} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}pci\PYGZsq{}} \PYG{n+na}{domain=}\PYG{l+s}{\PYGZsq{}0x0000\PYGZsq{}} \PYG{n+na}{bus=}\PYG{l+s}{\PYGZsq{}0x00\PYGZsq{}} \PYG{n+na}{slot=}\PYG{l+s}{\PYGZsq{}0x02\PYGZsq{}}
      \PYG{n+na}{function=}\PYG{l+s}{\PYGZsq{}0x0\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/interface\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}serial} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}pty\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}target} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}isa\PYGZhy{}serial\PYGZsq{}} \PYG{n+na}{port=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/serial\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}console} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}pty\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}target} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}serial\PYGZsq{}} \PYG{n+na}{port=}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/console\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}memballoon} \PYG{n+na}{model=}\PYG{l+s}{\PYGZsq{}virtio\PYGZsq{}}\PYG{n+nt}{\PYGZgt{}}
      \PYG{n+nt}{\PYGZlt{}address} \PYG{n+na}{type=}\PYG{l+s}{\PYGZsq{}pci\PYGZsq{}} \PYG{n+na}{domain=}\PYG{l+s}{\PYGZsq{}0x0000\PYGZsq{}} \PYG{n+na}{bus=}\PYG{l+s}{\PYGZsq{}0x00\PYGZsq{}} \PYG{n+na}{slot=}\PYG{l+s}{\PYGZsq{}0x03\PYGZsq{}}
      \PYG{n+na}{function=}\PYG{l+s}{\PYGZsq{}0x0\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/memballoon\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}/devices\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}qemu:commandline}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}\PYGZhy{}cpu\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}host\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}\PYGZhy{}object\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg}
    \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}memory\PYGZhy{}backend\PYGZhy{}file,id=mem,size=4096M,mem\PYGZhy{}path=/run/hugepages/kvm,share=on\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}\PYGZhy{}numa\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}node,memdev=mem\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}\PYGZhy{}mem\PYGZhy{}prealloc\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}\PYGZhy{}chardev\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}socket,id=chr0,path=/tmp/sock0,server\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}\PYGZhy{}device\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg}
    \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}virtio\PYGZhy{}net\PYGZhy{}pci,netdev=vhost\PYGZhy{}net0,mac=52:54:00:12:34:56\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}\PYGZhy{}netdev\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}vhost\PYGZhy{}user,id=vhost\PYGZhy{}net0,chardev=chr0,vhostforce\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}\PYGZhy{}chardev\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}socket,id=chr1,path=/tmp/sock1,server\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}\PYGZhy{}device\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg}
    \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}virtio\PYGZhy{}net\PYGZhy{}pci,netdev=vhost\PYGZhy{}net1,mac=52:54:00:12:34:57\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}\PYGZhy{}netdev\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}qemu:arg} \PYG{n+na}{value=}\PYG{l+s}{\PYGZsq{}vhost\PYGZhy{}user,id=vhost\PYGZhy{}net1,chardev=chr1,vhostforce\PYGZsq{}}\PYG{n+nt}{/\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}/qemu:commandline\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/domain\PYGZgt{}}
\end{sphinxVerbatim}


\paragraph{Launch VM}
\label{\detokenize{gsg/howto_use:launch-vm}}
After updating XML configuration, launch VM with \sphinxcode{\sphinxupquote{virsh start}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} virsh start VM\PYGZus{}NAME
\end{sphinxVerbatim}

It is required to add network configurations for processes running on the VMs.
If this configuration is skipped, processes cannot communicate with others
via SPP.

On the VMs, add an interface and disable offload.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Add interface
\PYG{g+gp}{\PYGZdl{}} sudo ifconfig IF\PYGZus{}NAME inet IPADDR netmask NETMASK up

\PYG{g+gp}{\PYGZsh{}} Disable offload
\PYG{g+gp}{\PYGZdl{}} sudo ethtool \PYGZhy{}K IF\PYGZus{}NAME tx off
\end{sphinxVerbatim}

On host machine, it is also required to disable offload.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Disable offload \PYG{k}{for} VM
\PYG{g+gp}{\PYGZdl{}} sudo ethtool \PYGZhy{}K IF\PYGZus{}NAME tx off
\end{sphinxVerbatim}


\section{Performance Optimization}
\label{\detokenize{gsg/performance_opt:performance-optimization}}\label{\detokenize{gsg/performance_opt:gsg-performance-opt}}\label{\detokenize{gsg/performance_opt::doc}}

\subsection{Reduce Context Switches}
\label{\detokenize{gsg/performance_opt:reduce-context-switches}}
Use the \sphinxcode{\sphinxupquote{isolcpus}} Linux kernel parameter to isolate them
from Linux scheduler to reduce context switches.
It prevents workloads of other processes than DPDK running on
reserved cores with \sphinxcode{\sphinxupquote{isolcpus}} parameter.

For Ubuntu 16.04, define \sphinxcode{\sphinxupquote{isolcpus}} in \sphinxcode{\sphinxupquote{/etc/default/grub}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{GRUB\PYGZus{}CMDLINE\PYGZus{}LINUX\PYGZus{}DEFAULT=“isolcpus=0\PYGZhy{}3,5,7”}
\end{sphinxVerbatim}

The value of this \sphinxcode{\sphinxupquote{isolcpus}} depends on your environment and usage.
This example reserves six cores(0,1,2,3,5,7).


\subsection{Optimizing QEMU Performance}
\label{\detokenize{gsg/performance_opt:optimizing-qemu-performance}}
QEMU process runs threads for vcpu emulation. It is effective strategy
for pinning vcpu threads to decicated cores.

To find vcpu threads, you use \sphinxcode{\sphinxupquote{ps}} command to find PID of QEMU process
and \sphinxcode{\sphinxupquote{pstree}} command for threads launched from QEMU process.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} ps ea
\PYG{g+go}{   PID TTY     STAT  TIME COMMAND}
\PYG{g+go}{192606 pts/11  Sl+   4:42 ./x86\PYGZus{}64\PYGZhy{}softmmu/qemu\PYGZhy{}system\PYGZhy{}x86\PYGZus{}64 \PYGZhy{}cpu host ...}
\end{sphinxVerbatim}

Run \sphinxcode{\sphinxupquote{pstree}} with \sphinxcode{\sphinxupquote{-p}} and this PID to find all threads launched from QEMU.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} pstree \PYGZhy{}p \PYG{l+m}{192606}
\PYG{g+go}{qemu\PYGZhy{}system\PYGZhy{}x86(192606)\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZob{}qemu\PYGZhy{}system\PYGZhy{}x8\PYGZcb{}(192607)}
\PYG{g+go}{                         \textbar{}\PYGZhy{}\PYGZhy{}\PYGZob{}qemu\PYGZhy{}system\PYGZhy{}x8\PYGZcb{}(192623)}
\PYG{g+go}{                         \textbar{}\PYGZhy{}\PYGZhy{}\PYGZob{}qemu\PYGZhy{}system\PYGZhy{}x8\PYGZcb{}(192624)}
\PYG{g+go}{                         \textbar{}\PYGZhy{}\PYGZhy{}\PYGZob{}qemu\PYGZhy{}system\PYGZhy{}x8\PYGZcb{}(192625)}
\PYG{g+go}{                         \textbar{}\PYGZhy{}\PYGZhy{}\PYGZob{}qemu\PYGZhy{}system\PYGZhy{}x8\PYGZcb{}(192626)}
\end{sphinxVerbatim}

Update affinity by using \sphinxcode{\sphinxupquote{taskset}} command to pin vcpu threads.
The vcpu threads is listed from the second entry and later.
In this example, assign PID 192623 to core 4, PID 192624 to core 5
and so on.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo taskset \PYGZhy{}pc \PYG{l+m}{4} \PYG{l+m}{192623}
\PYG{g+go}{pid 192623\PYGZsq{}s current affinity list: 0\PYGZhy{}31}
\PYG{g+go}{pid 192623\PYGZsq{}s new affinity list: 4}
\PYG{g+gp}{\PYGZdl{}} sudo taskset \PYGZhy{}pc \PYG{l+m}{5} \PYG{l+m}{192624}
\PYG{g+go}{pid 192624\PYGZsq{}s current affinity list: 0\PYGZhy{}31}
\PYG{g+go}{pid 192624\PYGZsq{}s new affinity list: 5}
\PYG{g+gp}{\PYGZdl{}} sudo taskset \PYGZhy{}pc \PYG{l+m}{6} \PYG{l+m}{192625}
\PYG{g+go}{pid 192625\PYGZsq{}s current affinity list: 0\PYGZhy{}31}
\PYG{g+go}{pid 192625\PYGZsq{}s new affinity list: 6}
\PYG{g+gp}{\PYGZdl{}} sudo taskset \PYGZhy{}pc \PYG{l+m}{7} \PYG{l+m}{192626}
\PYG{g+go}{pid 192626\PYGZsq{}s current affinity list: 0\PYGZhy{}31}
\PYG{g+go}{pid 192626\PYGZsq{}s new affinity list: 7}
\end{sphinxVerbatim}


\subsection{Reference}
\label{\detokenize{gsg/performance_opt:reference}}\begin{itemize}
\item {} 
{[}1{]} \sphinxhref{https://www.redhat.com/archives/vfio-users/2017-February/msg00010.html}{Best pinning strategy for latency/performance trade-off}

\item {} 
{[}2{]} \sphinxhref{http://dpdk.org/doc/guides/howto/pvp\_reference\_benchmark.html}{PVP reference benchmark setup using testpmd}

\item {} 
{[}3{]} \sphinxhref{http://dpdk.org/doc/guides/linux\_gsg/enable\_func.html}{Enabling Additional Functionality}

\item {} 
{[}4{]} \sphinxhref{http://dpdk.org/doc/guides/linux\_gsg/nic\_perf\_intel\_platform.html}{How to get best performance with NICs on Intel platforms}

\end{itemize}


\chapter{Use Cases}
\label{\detokenize{usecases/index:use-cases}}\label{\detokenize{usecases/index:spp-usecases-index}}\label{\detokenize{usecases/index::doc}}
As described in {\hyperref[\detokenize{design/index:spp-design-index}]{\sphinxcrossref{\DUrole{std,std-ref}{Design}}}},
SPP has several kinds of secondary process for
usecases such as simple forwarding to network entities, capturing or
mirroring packets for monitoring, or connecting VMs or containers for
Service Function Chaining in NFV.

This chapter is focusing on explaining about each of secondary
processes with simple usecases.
Usecase of \sphinxcode{\sphinxupquote{spp\_primary}} is not covered here because it is almost
similar to \sphinxcode{\sphinxupquote{spp\_nfv}} and no need to explain both.

Details of usages of each process is not covered in this chapter.
You can refer the details of SPP processes via CLI from
{\hyperref[\detokenize{commands/index:spp-commands-index}]{\sphinxcrossref{\DUrole{std,std-ref}{SPP Commands}}}},
or via REST API from {\hyperref[\detokenize{api_ref/index:spp-api-ref-index}]{\sphinxcrossref{\DUrole{std,std-ref}{API Reference}}}}.


\section{spp\_nfv}
\label{\detokenize{usecases/spp_nfv:spp-nfv}}\label{\detokenize{usecases/spp_nfv:spp-usecases-nfv}}\label{\detokenize{usecases/spp_nfv::doc}}

\subsection{Single spp\_nfv}
\label{\detokenize{usecases/spp_nfv:single-spp-nfv}}\label{\detokenize{usecases/spp_nfv:spp-usecases-nfv-single-spp-nfv}}
The most simple usecase mainly for testing performance of packet
forwarding on host.
One \sphinxcode{\sphinxupquote{spp\_nfv}} and two physical ports.

In this usecase, try to configure two senarios.
\begin{itemize}
\item {} 
Configure \sphinxcode{\sphinxupquote{spp\_nfv}} as L2fwd

\item {} 
Configure \sphinxcode{\sphinxupquote{spp\_nfv}} for Loopback

\end{itemize}

First of all, Check the status of \sphinxcode{\sphinxupquote{spp\_nfv}} from SPP CLI.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; status}
\PYG{g+go}{\PYGZhy{} status: idling}
\PYG{g+go}{\PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{  \PYGZhy{} master: 1}
\PYG{g+go}{  \PYGZhy{} slave: 2}
\PYG{g+go}{\PYGZhy{} ports:}
\PYG{g+go}{  \PYGZhy{} phy:0}
\PYG{g+go}{  \PYGZhy{} phy:1}
\end{sphinxVerbatim}

This status message explains that \sphinxcode{\sphinxupquote{nfv 1}} has two physical ports.


\subsubsection{Configure spp\_nfv as L2fwd}
\label{\detokenize{usecases/spp_nfv:configure-spp-nfv-as-l2fwd}}
Assing the destination of ports with \sphinxcode{\sphinxupquote{patch}} subcommand and
start forwarding.
Patch from \sphinxcode{\sphinxupquote{phy:0}} to \sphinxcode{\sphinxupquote{phy:1}} and \sphinxcode{\sphinxupquote{phy:1}} to \sphinxcode{\sphinxupquote{phy:0}},
which means it is bi-directional connection.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:0 phy:1}
\PYG{g+go}{Patch ports (phy:0 \PYGZhy{}\PYGZgt{} phy:1).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:1 phy:0}
\PYG{g+go}{Patch ports (phy:1 \PYGZhy{}\PYGZgt{} phy:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}

Confirm that status of \sphinxcode{\sphinxupquote{nfv 1}} is updated to \sphinxcode{\sphinxupquote{running}} and ports are
patches as you defined.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; status}
\PYG{g+go}{\PYGZhy{} status: running}
\PYG{g+go}{\PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{  \PYGZhy{} master: 1}
\PYG{g+go}{  \PYGZhy{} slave: 2}
\PYG{g+go}{\PYGZhy{} ports:}
\PYG{g+go}{  \PYGZhy{} phy:0 \PYGZhy{}\PYGZgt{} phy:1}
\PYG{g+go}{  \PYGZhy{} phy:1 \PYGZhy{}\PYGZgt{} phy:0}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{spp_nfv_l2fwd}.pdf}
\caption{spp\_nfv as l2fwd}\label{\detokenize{usecases/spp_nfv:id1}}\label{\detokenize{usecases/spp_nfv:figure-spp-nfv-as-l2fwd}}\end{figure}

Stop forwarding and reset patch to clear configuration.
\sphinxcode{\sphinxupquote{patch reset}} is to clear all of patch configurations.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; stop}
\PYG{g+go}{Stop forwarding.}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch reset}
\PYG{g+go}{Clear all of patches.}
\end{sphinxVerbatim}


\subsubsection{Configure spp\_nfv for Loopback}
\label{\detokenize{usecases/spp_nfv:configure-spp-nfv-for-loopback}}
Patch \sphinxcode{\sphinxupquote{phy:0}} to \sphinxcode{\sphinxupquote{phy:0}} and \sphinxcode{\sphinxupquote{phy:1}} to \sphinxcode{\sphinxupquote{phy:1}}
for loopback.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:0 phy:0}
\PYG{g+go}{Patch ports (phy:0 \PYGZhy{}\PYGZgt{} phy:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:1 phy:1}
\PYG{g+go}{Patch ports (phy:1 \PYGZhy{}\PYGZgt{} phy:1).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}


\subsection{Dual spp\_nfv}
\label{\detokenize{usecases/spp_nfv:dual-spp-nfv}}
Use case for testing performance of packet forwarding
with two \sphinxcode{\sphinxupquote{spp\_nfv}} on host.
Throughput is expected to be better than
{\hyperref[\detokenize{usecases/spp_nfv:spp-usecases-nfv-single-spp-nfv}]{\sphinxcrossref{\DUrole{std,std-ref}{Single spp\_nfv}}}}
usecase because bi-directional forwarding of single \sphinxcode{\sphinxupquote{spp\_nfv}} is shared
with two of uni-directional forwarding between dual \sphinxcode{\sphinxupquote{spp\_nfv}}.

In this usecase, configure two senarios almost similar to previous section.
\begin{itemize}
\item {} 
Configure Two \sphinxcode{\sphinxupquote{spp\_nfv}} as L2fwd

\item {} 
Configure Two \sphinxcode{\sphinxupquote{spp\_nfv}} for Loopback

\end{itemize}


\subsubsection{Configure Two spp\_nfv as L2fwd}
\label{\detokenize{usecases/spp_nfv:configure-two-spp-nfv-as-l2fwd}}
Assing the destination of ports with \sphinxcode{\sphinxupquote{patch}} subcommand and
start forwarding.
Patch from \sphinxcode{\sphinxupquote{phy:0}} to \sphinxcode{\sphinxupquote{phy:1}} for \sphinxcode{\sphinxupquote{nfv 1}} and
from \sphinxcode{\sphinxupquote{phy:1}} to \sphinxcode{\sphinxupquote{phy:0}} for \sphinxcode{\sphinxupquote{nfv 2}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:0 phy:1}
\PYG{g+go}{Patch ports (phy:0 \PYGZhy{}\PYGZgt{} phy:1).}
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch phy:1 phy:0}
\PYG{g+go}{Patch ports (phy:1 \PYGZhy{}\PYGZgt{} phy:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{Start forwarding.}
\PYG{g+go}{spp \PYGZgt{} nfv 2; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{spp_two_nfv_l2fwd}.pdf}
\caption{Two spp\_nfv as l2fwd}\label{\detokenize{usecases/spp_nfv:id2}}\label{\detokenize{usecases/spp_nfv:figure-spp-two-nfv-as-l2fwd}}\end{figure}


\subsubsection{Configure two spp\_nfv for Loopback}
\label{\detokenize{usecases/spp_nfv:configure-two-spp-nfv-for-loopback}}
Patch \sphinxcode{\sphinxupquote{phy:0}} to \sphinxcode{\sphinxupquote{phy:0}} for \sphinxcode{\sphinxupquote{nfv 1}} and
\sphinxcode{\sphinxupquote{phy:1}} to \sphinxcode{\sphinxupquote{phy:1}} for \sphinxcode{\sphinxupquote{nfv 2}} for loopback.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:0 phy:0}
\PYG{g+go}{Patch ports (phy:0 \PYGZhy{}\PYGZgt{} phy:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch phy:1 phy:1}
\PYG{g+go}{Patch ports (phy:1 \PYGZhy{}\PYGZgt{} phy:1).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{Start forwarding.}
\PYG{g+go}{spp \PYGZgt{} nfv 2; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.620\linewidth]{{spp_two_nfv_loopback}.pdf}
\caption{Two spp\_nfv for loopback}\label{\detokenize{usecases/spp_nfv:id3}}\label{\detokenize{usecases/spp_nfv:figure-spp-two-nfv-loopback}}\end{figure}


\subsection{Dual spp\_nfv with Ring PMD}
\label{\detokenize{usecases/spp_nfv:dual-spp-nfv-with-ring-pmd}}
In this usecase, configure two senarios by using ring PMD.
\begin{itemize}
\item {} 
Uni-Directional L2fwd

\item {} 
Bi-Directional L2fwd

\end{itemize}


\subsubsection{Ring PMD}
\label{\detokenize{usecases/spp_nfv:ring-pmd}}
Ring PMD is an interface for communicating between secondaries on host.
The maximum number of ring PMDs is defined as \sphinxcode{\sphinxupquote{-n}}  option of
\sphinxcode{\sphinxupquote{spp\_primary}} and ring ID is started from 0.

Ring PMD is added by using \sphinxcode{\sphinxupquote{add}} subcommand.
All of ring PMDs is showed with \sphinxcode{\sphinxupquote{status}} subcommand.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; add ring:0}
\PYG{g+go}{Add ring:0.}
\PYG{g+go}{spp \PYGZgt{} nfv 1; status}
\PYG{g+go}{\PYGZhy{} status: idling}
\PYG{g+go}{\PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{  \PYGZhy{} master: 1}
\PYG{g+go}{  \PYGZhy{} slave: 2}
\PYG{g+go}{\PYGZhy{} ports:}
\PYG{g+go}{  \PYGZhy{} phy:0}
\PYG{g+go}{  \PYGZhy{} phy:1}
\PYG{g+go}{  \PYGZhy{} ring:0}
\end{sphinxVerbatim}

Notice that \sphinxcode{\sphinxupquote{ring:0}} is added to \sphinxcode{\sphinxupquote{nfv 1}}.
You can delete it with \sphinxcode{\sphinxupquote{del}} command if you do not need to
use it anymore.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; del ring:0}
\PYG{g+go}{Delete ring:0.}
\PYG{g+go}{spp \PYGZgt{} nfv 1; status}
\PYG{g+go}{\PYGZhy{} status: idling}
\PYG{g+go}{\PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{  \PYGZhy{} master: 1}
\PYG{g+go}{  \PYGZhy{} slave: 2}
\PYG{g+go}{\PYGZhy{} ports:}
\PYG{g+go}{  \PYGZhy{} phy:0}
\PYG{g+go}{  \PYGZhy{} phy:1}
\end{sphinxVerbatim}


\subsubsection{Uni-Directional L2fwd}
\label{\detokenize{usecases/spp_nfv:uni-directional-l2fwd}}
Add a ring PMD and connect two \sphinxcode{\sphinxupquote{spp\_nvf}} processes.
To configure network path, add \sphinxcode{\sphinxupquote{ring:0}} to \sphinxcode{\sphinxupquote{nfv 1}} and \sphinxcode{\sphinxupquote{nfv 2}}.
Then, connect it with \sphinxcode{\sphinxupquote{patch}} subcommand.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; add ring:0}
\PYG{g+go}{Add ring:0.}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add ring:0}
\PYG{g+go}{Add ring:0.}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:0 ring:0}
\PYG{g+go}{Patch ports (phy:0 \PYGZhy{}\PYGZgt{} ring:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch ring:0 phy:1}
\PYG{g+go}{Patch ports (ring:0 \PYGZhy{}\PYGZgt{} phy:1).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{Start forwarding.}
\PYG{g+go}{spp \PYGZgt{} nfv 2; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.720\linewidth]{{spp_unidir_l2fwd}.pdf}
\caption{Uni-Directional l2fwd}\label{\detokenize{usecases/spp_nfv:id4}}\label{\detokenize{usecases/spp_nfv:figure-spp-uni-directional-l2fwd}}\end{figure}


\subsubsection{Bi-Directional L2fwd}
\label{\detokenize{usecases/spp_nfv:bi-directional-l2fwd}}
Add two ring PMDs to two \sphinxcode{\sphinxupquote{spp\_nvf}} processes.
For bi-directional forwarding,
patch \sphinxcode{\sphinxupquote{ring:0}} for a path from \sphinxcode{\sphinxupquote{nfv 1}} to \sphinxcode{\sphinxupquote{nfv 2}}
and \sphinxcode{\sphinxupquote{ring:1}} for another path from \sphinxcode{\sphinxupquote{nfv 2}} to \sphinxcode{\sphinxupquote{nfv 1}}.

First, add \sphinxcode{\sphinxupquote{ring:0}} and \sphinxcode{\sphinxupquote{ring:1}} to \sphinxcode{\sphinxupquote{nfv 1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; add ring:0}
\PYG{g+go}{Add ring:0.}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add ring:1}
\PYG{g+go}{Add ring:1.}
\PYG{g+go}{spp \PYGZgt{} nfv 1; status}
\PYG{g+go}{\PYGZhy{} status: idling}
\PYG{g+go}{\PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{  \PYGZhy{} master: 1}
\PYG{g+go}{  \PYGZhy{} slave: 2}
\PYG{g+go}{\PYGZhy{} ports:}
\PYG{g+go}{  \PYGZhy{} phy:0}
\PYG{g+go}{  \PYGZhy{} phy:1}
\PYG{g+go}{  \PYGZhy{} ring:0}
\PYG{g+go}{  \PYGZhy{} ring:1}
\end{sphinxVerbatim}

Then, add \sphinxcode{\sphinxupquote{ring:0}} and \sphinxcode{\sphinxupquote{ring:1}} to \sphinxcode{\sphinxupquote{nfv 2}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 2; add ring:0}
\PYG{g+go}{Add ring:0.}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add ring:1}
\PYG{g+go}{Add ring:1.}
\PYG{g+go}{spp \PYGZgt{} nfv 2; status}
\PYG{g+go}{\PYGZhy{} status: idling}
\PYG{g+go}{\PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{  \PYGZhy{} master: 1}
\PYG{g+go}{  \PYGZhy{} slave: 3}
\PYG{g+go}{\PYGZhy{} ports:}
\PYG{g+go}{  \PYGZhy{} phy:0}
\PYG{g+go}{  \PYGZhy{} phy:1}
\PYG{g+go}{  \PYGZhy{} ring:0}
\PYG{g+go}{  \PYGZhy{} ring:1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:0 ring:0}
\PYG{g+go}{Patch ports (phy:0 \PYGZhy{}\PYGZgt{} ring:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch ring:1 phy:0}
\PYG{g+go}{Patch ports (ring:1 \PYGZhy{}\PYGZgt{} phy:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch phy:1 ring:1}
\PYG{g+go}{Patch ports (phy:1 \PYGZhy{}\PYGZgt{} ring:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch ring:0 phy:1}
\PYG{g+go}{Patch ports (ring:0 \PYGZhy{}\PYGZgt{} phy:1).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{Start forwarding.}
\PYG{g+go}{spp \PYGZgt{} nfv 2; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.720\linewidth]{{spp_bidir_l2fwd}.pdf}
\caption{Bi-Directional l2fwd}\label{\detokenize{usecases/spp_nfv:id5}}\label{\detokenize{usecases/spp_nfv:figure-spp-bi-directional-l2fwd}}\end{figure}


\subsection{Single spp\_nfv with Vhost PMD}
\label{\detokenize{usecases/spp_nfv:single-spp-nfv-with-vhost-pmd}}

\subsubsection{Vhost PMD}
\label{\detokenize{usecases/spp_nfv:vhost-pmd}}
Vhost PMD is an interface for communicating between on hsot and guest VM.
As described in
{\hyperref[\detokenize{gsg/howto_use:spp-gsg-howto-use}]{\sphinxcrossref{\DUrole{std,std-ref}{How to Use}}}},
vhost must be created by \sphinxcode{\sphinxupquote{add}} subcommand before the VM is launched.


\subsubsection{Setup Vhost PMD}
\label{\detokenize{usecases/spp_nfv:setup-vhost-pmd}}
In this usecase, add \sphinxcode{\sphinxupquote{vhost:0}} to \sphinxcode{\sphinxupquote{nfv 1}} for communicating
with the VM.
First, check if \sphinxcode{\sphinxupquote{/tmp/sock0}} is already exist.
You should remove it already exist to avoid a failure of socket file
creation.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} remove sock0 \PYG{k}{if} already exist
\PYG{g+gp}{\PYGZdl{}} ls /tmp \PYG{p}{\textbar{}} grep sock
\PYG{g+go}{sock0 ...}
\PYG{g+gp}{\PYGZdl{}} sudo rm /tmp/sock0
\end{sphinxVerbatim}

Create \sphinxcode{\sphinxupquote{/tmp/sock0}} from \sphinxcode{\sphinxupquote{nfv 1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; add vhost:0}
\PYG{g+go}{Add vhost:0.}
\end{sphinxVerbatim}


\subsubsection{Setup Network Configuration in spp\_nfv}
\label{\detokenize{usecases/spp_nfv:setup-network-configuration-in-spp-nfv}}\label{\detokenize{usecases/spp_nfv:usecase-spp-nfv-l2fwd-vhost-nw}}
Launch a VM by using the vhost interface created in the previous step.
Lauunching VM is described in
{\hyperref[\detokenize{gsg/howto_use:spp-gsg-howto-use}]{\sphinxcrossref{\DUrole{std,std-ref}{How to Use}}}}.

Patch \sphinxcode{\sphinxupquote{phy:0}} to \sphinxcode{\sphinxupquote{vhost:0}} and \sphinxcode{\sphinxupquote{vhost:1}} to \sphinxcode{\sphinxupquote{phy:1}} from \sphinxcode{\sphinxupquote{nfv 1}}
running on host.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:0 vhost:0}
\PYG{g+go}{Patch ports (phy:0 \PYGZhy{}\PYGZgt{} vhost:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch vhost:1 phy:1}
\PYG{g+go}{Patch ports (vhost:1 \PYGZhy{}\PYGZgt{} phy:1).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}

Finally, start forwarding inside the VM by using two vhost ports
to confirm that network on host is configured.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo \PYG{n+nv}{\PYGZdl{}RE\PYGZus{}SDK}/examples/build/l2fwd \PYGZhy{}l \PYG{l+m}{0}\PYGZhy{}1 \PYGZhy{}\PYGZhy{} \PYGZhy{}p 0x03
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.720\linewidth]{{spp_nfv_l2fwd_vhost}.pdf}
\caption{Single spp\_nfv with vhost PMD}\label{\detokenize{usecases/spp_nfv:id6}}\label{\detokenize{usecases/spp_nfv:figure-spp-nfv-l2fwd-vhost}}\end{figure}


\subsection{Single spp\_nfv with PCAP PMD}
\label{\detokenize{usecases/spp_nfv:single-spp-nfv-with-pcap-pmd}}

\subsubsection{PCAP PMD}
\label{\detokenize{usecases/spp_nfv:pcap-pmd}}
Pcap PMD is an interface for capturing or restoring traffic.
For usign pcap PMD, you should set \sphinxcode{\sphinxupquote{CONFIG\_RTE\_LIBRTE\_PMD\_PCAP}}
and \sphinxcode{\sphinxupquote{CONFIG\_RTE\_PORT\_PCAP}} to \sphinxcode{\sphinxupquote{y}} and compile DPDK before SPP.
Refer to
{\hyperref[\detokenize{gsg/install:setup-install-dpdk-spp}]{\sphinxcrossref{\DUrole{std,std-ref}{Install DPDK and SPP}}}}
for details of setting up.

Pcap PMD has two different streams for rx and tx.
Tx device is for capturing packets and rx is for restoring captured
packets.
For rx device, you can use any of pcap files other than SPP’s pcap PMD.

To start using pcap pmd, just using \sphinxcode{\sphinxupquote{add}} subcommand as ring.
Here is an example for creating pcap PMD \sphinxcode{\sphinxupquote{pcap:1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; add pcap:1}
\end{sphinxVerbatim}

After running it, you can find two of pcap files in \sphinxcode{\sphinxupquote{/tmp}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} ls /tmp \PYG{p}{\textbar{}} grep pcap\PYGZdl{}
\PYG{g+go}{spp\PYGZhy{}rx1.pcap}
\PYG{g+go}{spp\PYGZhy{}tx1.pcap}
\end{sphinxVerbatim}

If you already have a dumped file, you can use it by it putting as
\sphinxcode{\sphinxupquote{/tmp/spp-rx1.pcap}} before running the \sphinxcode{\sphinxupquote{add}} subcommand.
SPP does not overwrite rx pcap file if it already exist,
and it just overwrites tx pcap file.


\subsubsection{Capture Incoming Packets}
\label{\detokenize{usecases/spp_nfv:capture-incoming-packets}}
As the first usecase, add a pcap PMD and capture incoming packets from
\sphinxcode{\sphinxupquote{phy:0}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; add pcap 1}
\PYG{g+go}{Add pcap:1.}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:0 pcap:1}
\PYG{g+go}{Patch ports (phy:0 \PYGZhy{}\PYGZgt{} pcap:1).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{spp_pcap_incoming}.pdf}
\caption{Rapture incoming packets}\label{\detokenize{usecases/spp_nfv:id7}}\label{\detokenize{usecases/spp_nfv:figure-spp-pcap-incoming}}\end{figure}

In this example, we use pktgen.
Once you start forwarding packets from pktgen, you can see
that the size of \sphinxcode{\sphinxupquote{/tmp/spp-tx1.pcap}} is increased rapidly
(or gradually, it depends on the rate).

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{Pktgen:/\PYGZgt{} set 0 size 1024}
\PYG{g+go}{Pktgen:/\PYGZgt{} start 0}
\end{sphinxVerbatim}

To stop capturing, simply stop forwarding of \sphinxcode{\sphinxupquote{spp\_nfv}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; stop}
\PYG{g+go}{Stop forwarding.}
\end{sphinxVerbatim}

You can analyze the dumped pcap file with other tools like as wireshark.


\subsubsection{Restore dumped Packets}
\label{\detokenize{usecases/spp_nfv:restore-dumped-packets}}
In this usecase, use dumped file in previsou section.
Copy \sphinxcode{\sphinxupquote{spp-tx1.pcap}} to \sphinxcode{\sphinxupquote{spp-rx2.pcap}} first.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo cp /tmp/spp\PYGZhy{}tx1.pcap /tmp/spp\PYGZhy{}rx2.pcap
\end{sphinxVerbatim}

Then, add pcap PMD \sphinxcode{\sphinxupquote{pcap:2}} to another \sphinxcode{\sphinxupquote{spp\_nfv}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 2; add pcap:2}
\PYG{g+go}{Add pcap:2.}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{spp_pcap_restoring}.pdf}
\caption{Restore dumped packets}\label{\detokenize{usecases/spp_nfv:id8}}\label{\detokenize{usecases/spp_nfv:figure-spp-pcap-restoring}}\end{figure}

You can find that \sphinxcode{\sphinxupquote{spp-tx2.pcap}} is creaeted and \sphinxcode{\sphinxupquote{spp-rx2.pcap}}
still remained.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} ls \PYGZhy{}al /tmp/spp*.pcap
\PYG{g+go}{\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 root root         24  ...  /tmp/spp\PYGZhy{}rx1.pcap}
\PYG{g+go}{\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 root root 2936703640  ...  /tmp/spp\PYGZhy{}rx2.pcap}
\PYG{g+go}{\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 root root 2936703640  ...  /tmp/spp\PYGZhy{}tx1.pcap}
\PYG{g+go}{\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 root root          0  ...  /tmp/spp\PYGZhy{}tx2.pcap}
\end{sphinxVerbatim}

To confirm packets are restored, patch \sphinxcode{\sphinxupquote{pcap:2}} to \sphinxcode{\sphinxupquote{phy:1}}
and watch received packets on pktgen.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch pcap:2 phy:1}
\PYG{g+go}{Patch ports (pcap:2 \PYGZhy{}\PYGZgt{} phy:1).}
\PYG{g+go}{spp \PYGZgt{} nfv 2; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}

After started forwarding, you can see that packet count is increased.


\section{spp\_vf}
\label{\detokenize{usecases/spp_vf:spp-vf}}\label{\detokenize{usecases/spp_vf:spp-usecases-vf}}\label{\detokenize{usecases/spp_vf::doc}}
\sphinxcode{\sphinxupquote{spp\_vf}} is a secondary process for providing L2 classification as a simple
pusedo SR-IOV features.

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{-{-}file-prefix}} option is not required in this section because there is
not DPDK application other than SPP.
\end{sphinxadmonition}


\subsection{Classify ICMP Packets}
\label{\detokenize{usecases/spp_vf:classify-icmp-packets}}\label{\detokenize{usecases/spp_vf:spp-usecases-vf-cls-icmp}}
To confirm classifying packets, sends ICMP packet from remote node by using
ping and watch the response.
Incoming packets through \sphinxcode{\sphinxupquote{NIC0}} are classified based on destination address.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.800\linewidth]{{vf_cls_icmp_nwconf}.pdf}
\caption{Network Configuration}\label{\detokenize{usecases/spp_vf:id4}}\label{\detokenize{usecases/spp_vf:figure-spp-vf-use-cases-nw-config}}\end{figure}


\subsubsection{Setup}
\label{\detokenize{usecases/spp_vf:setup}}
Launch \sphinxcode{\sphinxupquote{spp-ctl}} and SPP CLI before primary and secondary processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} python3 ./src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZdl{}} python3 ./src/spp.py \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{spp\_primary}} on the second lcore with \sphinxcode{\sphinxupquote{-l 0}} and two ports \sphinxcode{\sphinxupquote{-p 0x03}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/primary/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{1} \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem \PYG{l+m}{512},512 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}huge\PYGZhy{}dir\PYG{o}{=}/run/hugepages/kvm \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type\PYG{o}{=}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}p 0x03 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}n \PYG{l+m}{10} \PYGZhy{}s \PYG{l+m}{192}.168.1.100:5555
\end{sphinxVerbatim}

After \sphinxcode{\sphinxupquote{spp\_primary}} is launched, run secondary process \sphinxcode{\sphinxupquote{spp\_vf}}.
In this case, lcore options is \sphinxcode{\sphinxupquote{-l 2-6}} for one master thread and four
worker threads.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/vf/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}vf \PYG{l+s+se}{\PYGZbs{}}
   \PYGZhy{}l \PYG{l+m}{2}\PYGZhy{}6 \PYG{l+s+se}{\PYGZbs{}}
   \PYGZhy{}n \PYG{l+m}{4} \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type\PYG{o}{=}secondary \PYG{l+s+se}{\PYGZbs{}}
   \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
   \PYGZhy{}\PYGZhy{}client\PYGZhy{}id \PYG{l+m}{1} \PYG{l+s+se}{\PYGZbs{}}
   \PYGZhy{}s \PYG{l+m}{192}.168.1.100:6666 \PYG{l+s+se}{\PYGZbs{}}
\end{sphinxVerbatim}


\subsubsection{Network Configuration}
\label{\detokenize{usecases/spp_vf:network-configuration}}
Configure network as described in \hyperref[\detokenize{usecases/spp_vf:figure-spp-vf-use-cases-nw-config}]{Fig.\@ \ref{\detokenize{usecases/spp_vf:figure-spp-vf-use-cases-nw-config}}}
step by step.

First of all, setup worker threads from \sphinxcode{\sphinxupquote{component}} command with lcore ID
and other options on local host \sphinxcode{\sphinxupquote{host2}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} vf 1; component start cls 3 classifier
spp \PYGZgt{} vf 1; component start fwd1 4 forwarder
spp \PYGZgt{} vf 1; component start fwd2 5 forwarder
spp \PYGZgt{} vf 1; component start mgr 6 merger
\end{sphinxVerbatim}

Add ports for each of components as following.
The number of rx and tx ports are different for each of component’s role.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2

\PYGZsh{} classifier
spp \PYGZgt{} vf 1; port add phy:0 rx cls
spp \PYGZgt{} vf 1; port add ring:0 tx cls
spp \PYGZgt{} vf 1; port add ring:1 tx cls

\PYGZsh{} forwarders
spp \PYGZgt{} vf 1; port add ring:0 rx fwd1
spp \PYGZgt{} vf 1; port add ring:2 tx fwd1
spp \PYGZgt{} vf 1; port add ring:1 rx fwd2
spp \PYGZgt{} vf 1; port add ring:3 tx fwd2

\PYGZsh{} merger
spp \PYGZgt{} vf 1; port add ring:2 rx mgr
spp \PYGZgt{} vf 1; port add ring:3 rx mgr
spp \PYGZgt{} vf 1; port add phy:1 tx mgr
\end{sphinxVerbatim}

You also need to configure MAC address table for classifier. In this case,
you need to register two MAC addresses. Although any MAC can be used,
you use \sphinxcode{\sphinxupquote{52:54:00:12:34:56}} and \sphinxcode{\sphinxupquote{52:54:00:12:34:58}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} vf 1; classifier\PYGZus{}table add mac 52:54:00:12:34:56 ring:0
spp \PYGZgt{} vf 1; classifier\PYGZus{}table add mac 52:54:00:12:34:58 ring:1
\end{sphinxVerbatim}


\subsubsection{Send Packet from Remote Host}
\label{\detokenize{usecases/spp_vf:send-packet-from-remote-host}}
Ensure NICs, \sphinxcode{\sphinxupquote{ens0}} and \sphinxcode{\sphinxupquote{ens1}} in this case, are upped on remote host
\sphinxcode{\sphinxupquote{host1}}. You can up by using ifconfig if the status is down.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{1} on remote host
\PYG{g+gp}{\PYGZsh{}} Configure ip address of ens0
\PYG{g+gp}{\PYGZdl{}} sudo ifconfig ens0 \PYG{l+m}{192}.168.140.1 netmask \PYG{l+m}{255}.255.255.0 up
\end{sphinxVerbatim}

Add arp entries of MAC addresses statically to be resolved.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{1} on remote host
\PYG{g+gp}{\PYGZsh{}} \PYG{n+nb}{set} MAC address
\PYG{g+gp}{\PYGZdl{}} sudo arp \PYGZhy{}i ens0 \PYGZhy{}s \PYG{l+m}{192}.168.140.2 \PYG{l+m}{52}:54:00:12:34:56
\PYG{g+gp}{\PYGZdl{}} sudo arp \PYGZhy{}i ens0 \PYGZhy{}s \PYG{l+m}{192}.168.140.3 \PYG{l+m}{52}:54:00:12:34:58
\end{sphinxVerbatim}

Start tcpdump command for capturing \sphinxcode{\sphinxupquote{ens1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2} on remote host
\PYG{g+gp}{\PYGZdl{}} sudo tcpdump \PYGZhy{}i ens1
\end{sphinxVerbatim}

Then, start ping in other terminals.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{3} on remote host
\PYG{g+gp}{\PYGZsh{}} ping via NIC0
\PYG{g+gp}{\PYGZdl{}} ping \PYG{l+m}{192}.168.140.2
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{4} on remote host
\PYG{g+gp}{\PYGZsh{}} ping via NIC0
\PYG{g+gp}{\PYGZdl{}} ping \PYG{l+m}{192}.168.140.3
\end{sphinxVerbatim}

You can see ICMP Echo requests are received from ping on terminal 2.


\subsubsection{Shutdown spp\_vf Components}
\label{\detokenize{usecases/spp_vf:shutdown-spp-vf-components}}\label{\detokenize{usecases/spp_vf:spp-vf-use-cases-shutdown-comps}}
Basically, you can shutdown all of SPP processes with \sphinxcode{\sphinxupquote{bye all}}
command.
This section describes graceful shutting down.
First, delete entries of \sphinxcode{\sphinxupquote{classifier\_table}} and ports of components.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} Delete MAC address from Classifier
spp \PYGZgt{} vf 1; classifier\PYGZus{}table del mac 52:54:00:12:34:56 ring:0
spp \PYGZgt{} vf 1; classifier\PYGZus{}table del mac 52:54:00:12:34:58 ring:1
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} classifier
spp \PYGZgt{} vf 1; port del phy:0 rx cls
spp \PYGZgt{} vf 1; port del ring:0 tx cls
spp \PYGZgt{} vf 1; port del ring:1 tx cls

\PYGZsh{} forwarders
spp \PYGZgt{} vf 1; port del ring:0 rx fwd1
spp \PYGZgt{} vf 1; port del vhost:0 tx fwd1
spp \PYGZgt{} vf 1; port del ring:1 rx fwd2
spp \PYGZgt{} vf 1; port del vhost:2 tx fwd2

\PYGZsh{} mergers
spp \PYGZgt{} vf 1; port del ring:2 rx mgr
spp \PYGZgt{} vf 1; port del ring:3 rx mgr
spp \PYGZgt{} vf 1; port del phy:0 tx mgr
\end{sphinxVerbatim}

Then, stop components.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} vf 1; component stop cls
spp \PYGZgt{} vf 1; component stop fwd1
spp \PYGZgt{} vf 1; component stop fwd2
spp \PYGZgt{} vf 1; component stop mgr
\end{sphinxVerbatim}

You can confirm that worker threads are cleaned from \sphinxcode{\sphinxupquote{status}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} vf 1; status
Basic Information:
  \PYGZhy{} client\PYGZhy{}id: 1
  \PYGZhy{} ports: [phy:0, phy:1]
  \PYGZhy{} lcore\PYGZus{}ids:
    \PYGZhy{} master: 2
    \PYGZhy{} slaves: [3, 4, 5, 6]
Classifier Table:
  No entries.
Components:
  \PYGZhy{} core:3 \PYGZsq{}\PYGZsq{} (type: unuse)
  \PYGZhy{} core:4 \PYGZsq{}\PYGZsq{} (type: unuse)
  \PYGZhy{} core:5 \PYGZsq{}\PYGZsq{} (type: unuse)
  \PYGZhy{} core:6 \PYGZsq{}\PYGZsq{} (type: unuse)
\end{sphinxVerbatim}

Finally, terminate \sphinxcode{\sphinxupquote{spp\_vf}} by using \sphinxcode{\sphinxupquote{exit}} or \sphinxcode{\sphinxupquote{bye sec}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf 1; exit}
\end{sphinxVerbatim}


\subsection{SSH Login to VMs}
\label{\detokenize{usecases/spp_vf:ssh-login-to-vms}}\label{\detokenize{usecases/spp_vf:spp-usecases-vf-ssh}}
This usecase is to classify packets for ssh connections as another example.
Incoming packets are classified based on destination addresses and reterned
packets are aggregated before going out.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.580\linewidth]{{vf_ssh_overview}.pdf}
\caption{Simple SSH Login}\label{\detokenize{usecases/spp_vf:id5}}\label{\detokenize{usecases/spp_vf:figure-spp-usecase-vf-ssh-overview}}\end{figure}


\subsubsection{Setup}
\label{\detokenize{usecases/spp_vf:id1}}
Launch \sphinxcode{\sphinxupquote{spp-ctl}} and SPP CLI before primary and secondary processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} python3 ./src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZdl{}} python3 ./src/spp.py \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{spp\_primary}} on the second lcore with \sphinxcode{\sphinxupquote{-l 1}} and two ports \sphinxcode{\sphinxupquote{-p 0x03}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/primary/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{1} \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem \PYG{l+m}{512},512 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}huge\PYGZhy{}dir\PYG{o}{=}/run/hugepages/kvm \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type\PYG{o}{=}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}p 0x03 \PYGZhy{}n \PYG{l+m}{10} \PYGZhy{}s \PYG{l+m}{192}.168.1.100:5555
\end{sphinxVerbatim}

Then, run secondary process \sphinxcode{\sphinxupquote{spp\_vf}} with \sphinxcode{\sphinxupquote{-l 0,2-13}} which indicates
to use twelve lcores.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/vf/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}vf \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{0},2\PYGZhy{}13 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}n \PYG{l+m}{4} \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type\PYG{o}{=}secondary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}client\PYGZhy{}id \PYG{l+m}{1} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}s \PYG{l+m}{192}.168.1.100:6666 \PYGZhy{}\PYGZhy{}vhost\PYGZhy{}client
\end{sphinxVerbatim}


\subsubsection{Network Configuration}
\label{\detokenize{usecases/spp_vf:id2}}
Detailed netowrk configuration of \hyperref[\detokenize{usecases/spp_vf:figure-spp-usecase-vf-ssh-overview}]{Fig.\@ \ref{\detokenize{usecases/spp_vf:figure-spp-usecase-vf-ssh-overview}}}
is described below.
In this usecase, use two NICs on each of host1 and host2 for redundancy.

Incoming packets through NIC0 or NIC1 are classified based on destionation
address.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{vf_ssh_nwconfig}.pdf}
\caption{Network Configuration SSH with spp\_vhost}\label{\detokenize{usecases/spp_vf:id6}}\label{\detokenize{usecases/spp_vf:figure-network-config}}\end{figure}

You need to input a little bit large amount of commands for the
configuration, or use \sphinxcode{\sphinxupquote{playback}} command to load from config files.
You can load network configuration  from recipes in \sphinxcode{\sphinxupquote{recipes/usecases/}}
as following.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} Load config from recipe
spp \PYGZgt{} playback recipes/usecases/spp\PYGZus{}vf/ssh/1\PYGZhy{}start\PYGZus{}components.rcp
spp \PYGZgt{} playback recipes/usecases/spp\PYGZus{}vf/ssh/2\PYGZhy{}add\PYGZus{}port\PYGZus{}path1.rcp
....
\end{sphinxVerbatim}

First of all, start components with names such as \sphinxcode{\sphinxupquote{cls1}}, \sphinxcode{\sphinxupquote{fwd1}} or so.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} vf 1; component start cls1 2 classifier
spp \PYGZgt{} vf 1; component start fwd1 3 forwarder
spp \PYGZgt{} vf 1; component start fwd2 4 forwarder
spp \PYGZgt{} vf 1; component start fwd3 5 forwarder
spp \PYGZgt{} vf 1; component start fwd4 6 forwarder
spp \PYGZgt{} vf 1; component start mgr1 7 merger
\end{sphinxVerbatim}

Each of components must have rx and tx ports for forwarding.
Add ports for each of components as following.
You notice that classifier has two tx ports and merger has two rx ports.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZsh{}} classifier
\PYG{g+go}{spp \PYGZgt{} vf 1; port add phy:0 rx cls1}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add ring:0 tx cls1}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add ring:1 tx cls1}

\PYG{g+gp}{\PYGZsh{}} forwarders
\PYG{g+go}{spp \PYGZgt{} vf 1; port add ring:0 rx fwd1}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add vhost:0 tx fwd1}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add ring:1 rx fwd2}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add vhost:2 tx fwd2}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add vhost:0 rx fwd3}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add ring:2 tx fwd3}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add vhost:2 rx fwd4}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add ring:3 tx fwd4}

\PYG{g+gp}{\PYGZsh{}} merger
\PYG{g+go}{spp \PYGZgt{} vf 1; port add ring:2 rx mgr1}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add ring:3 rx mgr1}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add phy:0 tx mgr1}
\end{sphinxVerbatim}

Classifier component decides the destination with MAC address by referring
\sphinxcode{\sphinxupquote{classifier\_table}}. MAC address and corresponging port is registered to the
table. In this usecase, you need to register two MAC addresses of targetting
VM for mgr1, and also mgr2 later.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} Register MAC addresses for mgr1
spp \PYGZgt{} vf 1; classifier\PYGZus{}table add mac 52:54:00:12:34:56 ring:0
spp \PYGZgt{} vf 1; classifier\PYGZus{}table add mac 52:54:00:12:34:58 ring:1
\end{sphinxVerbatim}

Configuration for the second login path is almost the same as the first path.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} vf 1; component start cls2 8 classifier
spp \PYGZgt{} vf 1; component start fwd5 9 forwarder
spp \PYGZgt{} vf 1; component start fwd6 10 forwarder
spp \PYGZgt{} vf 1; component start fwd7 11 forwarder
spp \PYGZgt{} vf 1; component start fwd8 12 forwarder
spp \PYGZgt{} vf 1; component start mgr2 13 merger
\end{sphinxVerbatim}

Add ports to each of components.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} classifier
spp \PYGZgt{} vf 1; port add phy:1 rx cls2
spp \PYGZgt{} vf 1; port add ring:4 tx cls2
spp \PYGZgt{} vf 1; port add ring:5 tx cls2

\PYGZsh{} forwarders
spp \PYGZgt{} vf 1; port add ring:4 rx fwd5
spp \PYGZgt{} vf 1; port add vhost:1 tx fwd5
spp \PYGZgt{} vf 1; port add ring:5 rx fwd6
spp \PYGZgt{} vf 1; port add vhost:3 tx fwd6
spp \PYGZgt{} vf 1; port add vhost:1 rx fwd7
spp \PYGZgt{} vf 1; port add ring:6 tx fwd7
spp \PYGZgt{} vf 1; port add vhost:3 rx fwd8
spp \PYGZgt{} vf 1; port add ring:7 tx fwd8

\PYGZsh{} merger
spp \PYGZgt{} vf 1; port add ring:6 rx mgr2
spp \PYGZgt{} vf 1; port add ring:7 rx mgr2
spp \PYGZgt{} vf 1; port add phy:1 tx mgr2
\end{sphinxVerbatim}

Register MAC address entries to \sphinxcode{\sphinxupquote{classifier\_table}} for \sphinxcode{\sphinxupquote{cls2}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZsh{}} Register MAC address to classifier
\PYG{g+go}{spp \PYGZgt{} vf 1; classifier\PYGZus{}table add mac 52:54:00:12:34:57 ring:4}
\PYG{g+go}{spp \PYGZgt{} vf 1; classifier\PYGZus{}table add mac 52:54:00:12:34:59 ring:5}
\end{sphinxVerbatim}


\subsubsection{Setup VMs}
\label{\detokenize{usecases/spp_vf:setup-vms}}\label{\detokenize{usecases/spp_vf:spp-usecases-vf-ssh-setup-vms}}
Launch two VMs with virsh command.
Setup for virsh is described in {\hyperref[\detokenize{gsg/howto_use:spp-gsg-howto-virsh}]{\sphinxcrossref{\DUrole{std,std-ref}{Using virsh}}}}.
In this case, VMs are named as \sphinxcode{\sphinxupquote{spp-vm1}} and \sphinxcode{\sphinxupquote{spp-vm2}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{5}
\PYG{g+gp}{\PYGZdl{}} virsh start spp\PYGZhy{}vm1  \PYG{c+c1}{\PYGZsh{} VM1}
\PYG{g+gp}{\PYGZdl{}} virsh start spp\PYGZhy{}vm2  \PYG{c+c1}{\PYGZsh{} VM2}
\end{sphinxVerbatim}

After VMs are launched, login to \sphinxcode{\sphinxupquote{spp-vm1}} first to configure.

\begin{sphinxadmonition}{note}{Note:}
To avoid asked for unknown keys while login VMs, use
\sphinxcode{\sphinxupquote{-o StrictHostKeyChecking=no}} option for ssh.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} ssh \PYGZhy{}o \PYG{n+nv}{StrictHostKeyChecking}\PYG{o}{=}no sppuser at \PYG{l+m}{192}.168.122.31
\end{sphinxVerbatim}
\end{sphinxadmonition}

Up interfaces and disable TCP offload to avoid ssh login is failed.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{5}
\PYG{g+gp}{\PYGZsh{}} up interfaces
\PYG{g+gp}{\PYGZdl{}} sudo ifconfig ens4 inet \PYG{l+m}{192}.168.140.21 netmask \PYG{l+m}{255}.255.255.0 up
\PYG{g+gp}{\PYGZdl{}} sudo ifconfig ens5 inet \PYG{l+m}{192}.168.150.22 netmask \PYG{l+m}{255}.255.255.0 up

\PYG{g+gp}{\PYGZsh{}} disable TCP offload
\PYG{g+gp}{\PYGZdl{}} sudo ethtool \PYGZhy{}K ens4 tx off
\PYG{g+gp}{\PYGZdl{}} sudo ethtool \PYGZhy{}K ens5 tx off
\end{sphinxVerbatim}

Configuration of \sphinxcode{\sphinxupquote{spp-vm2}} is almost similar to \sphinxcode{\sphinxupquote{spp-vm1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{5}
\PYG{g+gp}{\PYGZsh{}} up interfaces
\PYG{g+gp}{\PYGZdl{}} sudo ifconfig ens4 inet \PYG{l+m}{192}.168.140.31 netmask \PYG{l+m}{255}.255.255.0 up
\PYG{g+gp}{\PYGZdl{}} sudo ifconfig ens5 inet \PYG{l+m}{192}.168.150.32 netmask \PYG{l+m}{255}.255.255.0 up

\PYG{g+gp}{\PYGZsh{}} disable TCP offload
\PYG{g+gp}{\PYGZdl{}} sudo ethtool \PYGZhy{}K ens4 tx off
\PYG{g+gp}{\PYGZdl{}} sudo ethtool \PYGZhy{}K ens5 tx off
\end{sphinxVerbatim}


\subsubsection{Login to VMs}
\label{\detokenize{usecases/spp_vf:login-to-vms}}
Now, you can login to VMs from the remote host1.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{5}
\PYG{g+gp}{\PYGZsh{}} spp\PYGZhy{}vm1 via NIC0
\PYG{g+gp}{\PYGZdl{}} ssh sppuser@192.168.140.21

\PYG{g+gp}{\PYGZsh{}} spp\PYGZhy{}vm1 via NIC1
\PYG{g+gp}{\PYGZdl{}} ssh sppuser@192.168.150.22

\PYG{g+gp}{\PYGZsh{}} spp\PYGZhy{}vm2 via NIC0
\PYG{g+gp}{\PYGZdl{}} ssh sppuser@192.168.140.31

\PYG{g+gp}{\PYGZsh{}} spp\PYGZhy{}vm2 via NIC1
\PYG{g+gp}{\PYGZdl{}} ssh sppuser@192.168.150.32
\end{sphinxVerbatim}


\subsubsection{Shutdown spp\_vf Components}
\label{\detokenize{usecases/spp_vf:spp-usecases-vf-ssh-shutdown}}\label{\detokenize{usecases/spp_vf:id3}}
Basically, you can shutdown all of SPP processes with \sphinxcode{\sphinxupquote{bye all}}
command.
This section describes graceful shutting down.

First, delete entries of \sphinxcode{\sphinxupquote{classifier\_table}} and ports of components
for the first SSH login path.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} Delete MAC address from table
spp \PYGZgt{} vf 1; classifier\PYGZus{}table del mac 52:54:00:12:34:56 ring:0
spp \PYGZgt{} vf 1; classifier\PYGZus{}table del mac 52:54:00:12:34:58 ring:1
\end{sphinxVerbatim}

Delete ports.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} classifier
spp \PYGZgt{} vf 1; port del phy:0 rx cls1
spp \PYGZgt{} vf 1; port del ring:0 tx cls1
spp \PYGZgt{} vf 1; port del ring:1 tx cls1

\PYGZsh{} forwarders
spp \PYGZgt{} vf 1; port del ring:0 rx fwd1
spp \PYGZgt{} vf 1; port del vhost:0 tx fwd1
spp \PYGZgt{} vf 1; port del ring:1 rx fwd2
spp \PYGZgt{} vf 1; port del vhost:2 tx fwd2
spp \PYGZgt{} vf 1; port del vhost:0 rx fwd3
spp \PYGZgt{} vf 1; port del ring:2 tx fwd3
spp \PYGZgt{} vf 1; port del vhost:2 rx fwd4
spp \PYGZgt{} vf 1; port del ring:3 tx fwd4

\PYGZsh{} merger
spp \PYGZgt{} vf 1; port del ring:2 rx mgr1
spp \PYGZgt{} vf 1; port del ring:3 rx mgr1
spp \PYGZgt{} vf 1; port del phy:0 tx mgr1
\end{sphinxVerbatim}

Then, stop components.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} Stop component to spp\PYGZus{}vf
spp \PYGZgt{} vf 1; component stop cls1
spp \PYGZgt{} vf 1; component stop fwd1
spp \PYGZgt{} vf 1; component stop fwd2
spp \PYGZgt{} vf 1; component stop fwd3
spp \PYGZgt{} vf 1; component stop fwd4
spp \PYGZgt{} vf 1; component stop mgr1
\end{sphinxVerbatim}

Second, do termination for the second path.
Delete entries from the table and ports from each of components.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} Delete MAC address from Classifier
spp \PYGZgt{} vf 1; classifier\PYGZus{}table del mac 52:54:00:12:34:57 ring:4
spp \PYGZgt{} vf 1; classifier\PYGZus{}table del mac 52:54:00:12:34:59 ring:5
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} classifier2
spp \PYGZgt{} vf 1; port del phy:1 rx cls2
spp \PYGZgt{} vf 1; port del ring:4 tx cls2
spp \PYGZgt{} vf 1; port del ring:5 tx cls2

\PYGZsh{} forwarder
spp \PYGZgt{} vf 1; port del ring:4 rx fwd5
spp \PYGZgt{} vf 1; port del vhost:1 tx fwd5
spp \PYGZgt{} vf 1; port del ring:5 rx fwd6
spp \PYGZgt{} vf 1; port del vhost:3 tx fwd6
spp \PYGZgt{} vf 1; port del vhost:1 rx fwd7
spp \PYGZgt{} vf 1; port del ring:6 tx fwd7
spp \PYGZgt{} vf 1; port del vhost:3 tx fwd8
spp \PYGZgt{} vf 1; port del ring:7 rx fwd8

\PYGZsh{} merger
spp \PYGZgt{} vf 1; port del ring:6 rx mgr2
spp \PYGZgt{} vf 1; port del ring:7 rx mgr2
spp \PYGZgt{} vf 1; port del phy:1 tx mgr2
\end{sphinxVerbatim}

Then, stop components.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} Stop component to spp\PYGZus{}vf
spp \PYGZgt{} vf 1; component stop cls2
spp \PYGZgt{} vf 1; component stop fwd5
spp \PYGZgt{} vf 1; component stop fwd6
spp \PYGZgt{} vf 1; component stop fwd7
spp \PYGZgt{} vf 1; component stop fwd8
spp \PYGZgt{} vf 1; component stop mgr2
\end{sphinxVerbatim}


\subsubsection{Exit spp\_vf}
\label{\detokenize{usecases/spp_vf:exit-spp-vf}}
Terminate spp\_vf.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} vf 1; exit
\end{sphinxVerbatim}


\section{spp\_mirror}
\label{\detokenize{usecases/spp_mirror:spp-mirror}}\label{\detokenize{usecases/spp_mirror:spp-usecases-mirror}}\label{\detokenize{usecases/spp_mirror::doc}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{-{-}file-prefix}} option is not required in this section because there is
not DPDK application other than SPP.
\end{sphinxadmonition}


\subsection{Duplicate Packets}
\label{\detokenize{usecases/spp_mirror:duplicate-packets}}
Simply duplicate incoming packets and send to two destinations.
Remote \sphinxcode{\sphinxupquote{host1}} sends ARP packets by using ping command and
\sphinxcode{\sphinxupquote{spp\_mirror}} running on local \sphinxcode{\sphinxupquote{host2}} duplicates packets to
destination ports.


\subsubsection{Network Configuration}
\label{\detokenize{usecases/spp_mirror:network-configuration}}
Detailed configuration is described in
\hyperref[\detokenize{usecases/spp_mirror:figure-spp-mirror-use-cases-nw-config}]{Fig.\@ \ref{\detokenize{usecases/spp_mirror:figure-spp-mirror-use-cases-nw-config}}}.
In this diagram, incoming packets from \sphinxcode{\sphinxupquote{phy:0}} are mirrored.
In \sphinxcode{\sphinxupquote{spp\_mirror}} process, worker thread \sphinxcode{\sphinxupquote{mir}} copies incoming packets and
sends to two destinations \sphinxcode{\sphinxupquote{phy:1}} and \sphinxcode{\sphinxupquote{phy:2}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{mirror_dup_nwconf}.pdf}
\caption{Duplicate packets with spp\_mirror}\label{\detokenize{usecases/spp_mirror:id4}}\label{\detokenize{usecases/spp_mirror:figure-spp-mirror-use-cases-nw-config}}\end{figure}


\subsubsection{Setup SPP}
\label{\detokenize{usecases/spp_mirror:setup-spp}}
Change directory to spp and confirm that it is already compiled.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\end{sphinxVerbatim}

Launch \sphinxcode{\sphinxupquote{spp-ctl}} before launching SPP primary and secondary processes.
You also need to launch \sphinxcode{\sphinxupquote{spp.py}}  if you use \sphinxcode{\sphinxupquote{spp\_mirror}} from CLI.
\sphinxcode{\sphinxupquote{-b}} option is for binding IP address to communicate other SPP processes,
but no need to give it explicitly if \sphinxcode{\sphinxupquote{127.0.0.1}} or \sphinxcode{\sphinxupquote{localhost}} .

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZsh{}} Launch spp\PYGZhy{}ctl
\PYG{g+gp}{\PYGZdl{}} python3 ./src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZsh{}} Launch SPP CLI
\PYG{g+gp}{\PYGZdl{}} python3 ./src/spp.py \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\end{sphinxVerbatim}

Start \sphinxcode{\sphinxupquote{spp\_primary}} with core list option \sphinxcode{\sphinxupquote{-l 1}} and
three ports \sphinxcode{\sphinxupquote{-p 0x07}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/primary/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{1} \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem \PYG{l+m}{512},512 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}huge\PYGZhy{}dir\PYG{o}{=}/run/hugepages/kvm \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type\PYG{o}{=}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}p 0x07 \PYGZhy{}n \PYG{l+m}{10} \PYGZhy{}s \PYG{l+m}{192}.168.1.100:5555
\end{sphinxVerbatim}


\subsubsection{Launch spp\_mirror}
\label{\detokenize{usecases/spp_mirror:launch-spp-mirror}}
Run secondary process \sphinxcode{\sphinxupquote{spp\_mirror}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/mirror/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/app/spp\PYGZus{}mirror \PYG{l+s+se}{\PYGZbs{}}
 \PYGZhy{}l \PYG{l+m}{0},2 \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
 \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type secondary \PYG{l+s+se}{\PYGZbs{}}
 \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
 \PYGZhy{}\PYGZhy{}client\PYGZhy{}id \PYG{l+m}{1} \PYG{l+s+se}{\PYGZbs{}}
 \PYGZhy{}s \PYG{l+m}{192}.168.1.100:6666 \PYG{l+s+se}{\PYGZbs{}}
\end{sphinxVerbatim}

Start mirror component with core ID 2.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} mirror 1; component start mir 2 mirror}
\end{sphinxVerbatim}

Add \sphinxcode{\sphinxupquote{phy:0}} as rx port, and \sphinxcode{\sphinxupquote{phy:1}} and \sphinxcode{\sphinxupquote{phy:2}} as tx ports.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
\PYGZsh{} add ports to mir
spp \PYGZgt{} mirror 1; port add phy:0 rx mir
spp \PYGZgt{} mirror 1; port add phy:1 tx mir
spp \PYGZgt{} mirror 1; port add phy:2 tx mir
\end{sphinxVerbatim}


\subsubsection{Duplicate Packets}
\label{\detokenize{usecases/spp_mirror:id1}}
To check packets are mirrored, you run tcpdump for \sphinxcode{\sphinxupquote{ens1}} and \sphinxcode{\sphinxupquote{ens2}}.
As you run ping for \sphinxcode{\sphinxupquote{ens0}} next, you will see the same ARP requests trying
to resolve \sphinxcode{\sphinxupquote{192.168.140.21}} on terminal 1 and 2.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{1} at host1
\PYG{g+gp}{\PYGZsh{}} capture on ens1
\PYG{g+gp}{\PYGZdl{}} sudo tcpdump \PYGZhy{}i ens1
\PYG{g+go}{tcpdump: verbose output suppressed, use \PYGZhy{}v or \PYGZhy{}vv for full protocol decode}
\PYG{g+go}{listening on ens1, link\PYGZhy{}type EN10MB (Ethernet), capture size 262144 bytes}
\PYG{g+go}{21:18:44.183261 ARP, Request who\PYGZhy{}has 192.168.140.21 tell R740n15, length 28}
\PYG{g+go}{21:18:45.202182 ARP, Request who\PYGZhy{}has 192.168.140.21 tell R740n15, length 28}
\PYG{g+go}{....}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2} at host1
\PYG{g+gp}{\PYGZsh{}} capture on ens2
\PYG{g+gp}{\PYGZdl{}} sudo tcpdump \PYGZhy{}i ens2
\PYG{g+go}{tcpdump: verbose output suppressed, use \PYGZhy{}v or \PYGZhy{}vv for full protocol decode}
\PYG{g+go}{listening on ens2, link\PYGZhy{}type EN10MB (Ethernet), capture size 262144 bytes}
\PYG{g+go}{21:18:44.183261 ARP, Request who\PYGZhy{}has 192.168.140.21 tell R740n15, length 28}
\PYG{g+go}{21:18:45.202182 ARP, Request who\PYGZhy{}has 192.168.140.21 tell R740n15, length 28}
\PYG{g+go}{...}
\end{sphinxVerbatim}

Start to send ARP request with ping.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{3} at host1
\PYG{g+gp}{\PYGZsh{}} send packet from NIC0
\PYG{g+gp}{\PYGZdl{}} ping \PYG{l+m}{192}.168.140.21 \PYGZhy{}I ens0
\end{sphinxVerbatim}


\subsubsection{Stop Mirroring}
\label{\detokenize{usecases/spp_mirror:stop-mirroring}}
Delete ports for components.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} Delete port for mir
spp \PYGZgt{} mirror 1; port del phy:0 rx mir
spp \PYGZgt{} mirror 1; port del phy:1 tx mir
spp \PYGZgt{} mirror 1; port del phy:2 tx mir
\end{sphinxVerbatim}

Next, stop components.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Stop mirror
\PYG{g+go}{spp \PYGZgt{} mirror 1; component stop mir 2 mirror}

\PYG{g+go}{spp \PYGZgt{} mirror 1; status}
\PYG{g+go}{Basic Information:}
\PYG{g+go}{  \PYGZhy{} client\PYGZhy{}id: 1}
\PYG{g+go}{  \PYGZhy{} ports: [phy:0, phy:1]}
\PYG{g+go}{  \PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{    \PYGZhy{} master: 0}
\PYG{g+go}{    \PYGZhy{} slave: 2}
\PYG{g+go}{Components:}
\PYG{g+go}{  \PYGZhy{} core:2 \PYGZsq{}\PYGZsq{} (type: unuse)}
\end{sphinxVerbatim}

Finally, terminate \sphinxcode{\sphinxupquote{spp\_mirror}} to finish this usecase.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror 1; exit}
\end{sphinxVerbatim}


\subsection{Monitoring Packets}
\label{\detokenize{usecases/spp_mirror:monitoring-packets}}\label{\detokenize{usecases/spp_mirror:spp-usecases-mirror-monitor}}
Duplicate classified packets for monitoring before going to a VM.
In this usecase, we are only interested in packets going to \sphinxcode{\sphinxupquote{VM1}}.
Although you might be able to run packet monitor app on host,
run monitor on \sphinxcode{\sphinxupquote{VM3}} considering more NFV like senario.
You use \sphinxcode{\sphinxupquote{spp\_mirror}} for copying, and \sphinxcode{\sphinxupquote{spp\_vf}} classifying packets.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{mirror_monitor_overview}.pdf}
\caption{Monitoring with spp\_mirror}\label{\detokenize{usecases/spp_mirror:id5}}\label{\detokenize{usecases/spp_mirror:figure-usecase-monitor-overview}}\end{figure}


\subsubsection{Setup SPP and VMs}
\label{\detokenize{usecases/spp_mirror:setup-spp-and-vms}}
Launch \sphinxcode{\sphinxupquote{spp-ctl}} before launching SPP primary and secondary processes.
You also need to launch \sphinxcode{\sphinxupquote{spp.py}}  if you use \sphinxcode{\sphinxupquote{spp\_vf}} from CLI.
\sphinxcode{\sphinxupquote{-b}} option is for binding IP address to communicate other SPP processes,
but no need to give it explicitly if \sphinxcode{\sphinxupquote{127.0.0.1}} or \sphinxcode{\sphinxupquote{localhost}} although
doing explicitly in this example to be more understandable.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} python3 ./src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZdl{}} python3 ./src/spp.py \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\end{sphinxVerbatim}

Start spp\_primary with core list option \sphinxcode{\sphinxupquote{-l 1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZsh{}} Type the following in different terminal
\PYG{g+gp}{\PYGZdl{}} sudo ./src/primary/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{1} \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem \PYG{l+m}{512},512 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}huge\PYGZhy{}dir\PYG{o}{=}/run/hugepages/kvm \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type\PYG{o}{=}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}p 0x03 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}n \PYG{l+m}{10} \PYGZhy{}s \PYG{l+m}{192}.168.1.100:5555
\end{sphinxVerbatim}


\subsubsection{Netowrk Configuration}
\label{\detokenize{usecases/spp_mirror:netowrk-configuration}}
Detailed configuration of \hyperref[\detokenize{usecases/spp_mirror:figure-usecase-monitor-overview}]{Fig.\@ \ref{\detokenize{usecases/spp_mirror:figure-usecase-monitor-overview}}}
is described in \hyperref[\detokenize{usecases/spp_mirror:figure-usecase-monitor-nwconfig}]{Fig.\@ \ref{\detokenize{usecases/spp_mirror:figure-usecase-monitor-nwconfig}}}.
In this senario, worker thread \sphinxcode{\sphinxupquote{mir}} copies incoming packets
from though \sphinxcode{\sphinxupquote{ring:0}}.
Then, sends to orignal destination \sphinxcode{\sphinxupquote{VM1}} and anohter one \sphinxcode{\sphinxupquote{VM3}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.800\linewidth]{{mirror_monitor_nwconf}.pdf}
\caption{Network configuration of monitoring packets}\label{\detokenize{usecases/spp_mirror:id6}}\label{\detokenize{usecases/spp_mirror:figure-usecase-monitor-nwconfig}}\end{figure}

Launch \sphinxcode{\sphinxupquote{VM1}}, \sphinxcode{\sphinxupquote{VM2}} and \sphinxcode{\sphinxupquote{spp\_vf}} with core list \sphinxcode{\sphinxupquote{-l 0,2-8}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/vf/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}vf \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{0},2\PYGZhy{}8 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}n \PYG{l+m}{4} \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type secondary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}client\PYGZhy{}id \PYG{l+m}{1} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}s \PYG{l+m}{192}.168.1.100:6666 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}vhost\PYGZhy{}client
\end{sphinxVerbatim}

Start components in \sphinxcode{\sphinxupquote{spp\_vf}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} vf 1; component start cls 2 classifier
spp \PYGZgt{} vf 1; component start mgr 3 merge
spp \PYGZgt{} vf 1; component start fwd1 4 forward
spp \PYGZgt{} vf 1; component start fwd2 5 forward
spp \PYGZgt{} vf 1; component start fwd3 6 forward
spp \PYGZgt{} vf 1; component start fwd4 7 forward
spp \PYGZgt{} vf 1; component start fwd5 8 forward
\end{sphinxVerbatim}

Add ports for components.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} vf 1; port add phy:0 rx cls
spp \PYGZgt{} vf 1; port add ring:0 tx cls
spp \PYGZgt{} vf 1; port add ring:1 tx cls

spp \PYGZgt{} vf 1; port add ring:2 rx mgr
spp \PYGZgt{} vf 1; port add ring:3 rx mgr
spp \PYGZgt{} vf 1; port add phy:0 tx mgr

spp \PYGZgt{} vf 1; port add ring:5 rx fwd1
spp \PYGZgt{} vf 1; port add vhost:0 tx fwd1

spp \PYGZgt{} vf 1; port add ring:1 rx fwd2
spp \PYGZgt{} vf 1; port add vhost:2 tx fwd2

spp \PYGZgt{} vf 1; port add vhost:1 rx fwd3
spp \PYGZgt{} vf 1; port add ring:2 tx fwd3

spp \PYGZgt{} vf 1; port add vhost:3 rx fwd4
spp \PYGZgt{} vf 1; port add ring:3 tx fwd4

spp \PYGZgt{} vf 1; port add ring:4 rx fwd5
spp \PYGZgt{} vf 1; port add vhost:4 tx fwd5
\end{sphinxVerbatim}

Add classifier table entries.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} vf 1; classifier\PYGZus{}table add mac 52:54:00:12:34:56 ring:0
spp \PYGZgt{} vf 1; classifier\PYGZus{}table add mac 52:54:00:12:34:58 ring:1
\end{sphinxVerbatim}


\subsubsection{Launch spp\_mirror}
\label{\detokenize{usecases/spp_mirror:id2}}
Run \sphinxcode{\sphinxupquote{spp\_mirror}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{6}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/mirror/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/app/spp\PYGZus{}mirror \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}l \PYG{l+m}{0},9 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}n \PYG{l+m}{4} \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type secondary \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}client\PYGZhy{}id \PYG{l+m}{2} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}s \PYG{l+m}{192}.168.1.100:6666 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}vhost\PYGZhy{}client
\end{sphinxVerbatim}

Start mirror component with lcore ID 9.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} mirror 2; component start mir 9 mirror}
\end{sphinxVerbatim}

Add \sphinxcode{\sphinxupquote{ring:0}} as rx port, \sphinxcode{\sphinxupquote{ring:4}} and \sphinxcode{\sphinxupquote{ring:5}} as tx ports.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} mirror 2; port add ring:0 rx mir
spp \PYGZgt{} mirror 2; port add ring:4 tx mir
spp \PYGZgt{} mirror 2; port add ring:5 tx mir
\end{sphinxVerbatim}


\subsubsection{Receive Packet on VM3}
\label{\detokenize{usecases/spp_mirror:receive-packet-on-vm3}}
You can capture incoming packets on \sphinxcode{\sphinxupquote{VM3}} and compare it with on \sphinxcode{\sphinxupquote{VM1}}.
To capture incoming packets , use tcpdump for the interface,
\sphinxcode{\sphinxupquote{ens4}} in this case.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{5}
\PYG{g+gp}{\PYGZsh{}} capture on ens4 of VM1
\PYG{g+gp}{\PYGZdl{}} tcpdump \PYGZhy{}i ens4
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{7}
\PYG{g+gp}{\PYGZsh{}} capture on ens4 of VM3
\PYG{g+gp}{\PYGZdl{}} tcpdump \PYGZhy{}i ens4
\end{sphinxVerbatim}

You send packets from the remote \sphinxcode{\sphinxupquote{host1}} and confirm packets are received.
IP address is the same as {\hyperref[\detokenize{usecases/spp_vf:spp-usecases-vf}]{\sphinxcrossref{\DUrole{std,std-ref}{Usecase of spp\_vf}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Send packets from host1
\PYG{g+gp}{\PYGZdl{}} ping \PYG{l+m}{192}.168.140.21
\end{sphinxVerbatim}


\subsubsection{Stop Mirroring}
\label{\detokenize{usecases/spp_mirror:id3}}
Graceful shutdown of secondary processes is same as previous usecases.


\section{spp\_pcap}
\label{\detokenize{usecases/spp_pcap:spp-pcap}}\label{\detokenize{usecases/spp_pcap:spp-usecases-pcap}}\label{\detokenize{usecases/spp_pcap::doc}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{-{-}file-prefix}} option is not required in this section because there is
not DPDK application other than SPP.
\end{sphinxadmonition}


\subsection{Packet Capture}
\label{\detokenize{usecases/spp_pcap:packet-capture}}
This section describes a usecase for capturing packets with \sphinxcode{\sphinxupquote{spp\_pcap}}.
See inside of the captured file with \sphinxcode{\sphinxupquote{tcpdump}} command.
\hyperref[\detokenize{usecases/spp_pcap:figure-simple-capture}]{Fig.\@ \ref{\detokenize{usecases/spp_pcap:figure-simple-capture}}} shows the overview of scenario in which
incoming packets via \sphinxcode{\sphinxupquote{phy:0}} are dumped as compressed pcap files by using
\sphinxcode{\sphinxupquote{spp\_pcap}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{spp_pcap_overview}.pdf}
\caption{Packet capture with spp\_pcap}\label{\detokenize{usecases/spp_pcap:id1}}\label{\detokenize{usecases/spp_pcap:figure-simple-capture}}\end{figure}


\subsubsection{Launch spp\_pcap}
\label{\detokenize{usecases/spp_pcap:launch-spp-pcap}}\label{\detokenize{usecases/spp_pcap:spp-pcap-use-case-launch-pcap}}
Change directory if you are not in SPP’s directory,
and compile if not done yet.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\end{sphinxVerbatim}

Launch spp-ctl and SPP CLI in different terminals.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} python3 ./src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZdl{}} python3 ./src/spp.py \PYGZhy{}b \PYG{l+m}{192}.168.1.100
\end{sphinxVerbatim}

Then, run \sphinxcode{\sphinxupquote{spp\_primary}} with one physical port.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/primary/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}n \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem \PYG{l+m}{512},512 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}huge\PYGZhy{}dir /run/hugepages/kvm \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type primary \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}p 0x01 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}n \PYG{l+m}{8} \PYGZhy{}s \PYG{l+m}{192}.168.1.100:5555
\end{sphinxVerbatim}

After \sphinxcode{\sphinxupquote{spp\_primary}} is launched successfully, run \sphinxcode{\sphinxupquote{spp\_pcap}} in other
terminal. In this usecase, you use default values for optional arguments.
Output directory of captured file is \sphinxcode{\sphinxupquote{/tmp}} and the size of file is
\sphinxcode{\sphinxupquote{1GiB}}.
You notice that six lcores are assigned with \sphinxcode{\sphinxupquote{-l 1-6}}.
It means that you use one locre for master, one for receiver, and four for
writer threads.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} sudo ./src/pcap/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/spp\PYGZus{}pcap \PYG{l+s+se}{\PYGZbs{}}
   \PYGZhy{}l \PYG{l+m}{1}\PYGZhy{}6 \PYGZhy{}n \PYG{l+m}{4} \PYGZhy{}\PYGZhy{}proc\PYGZhy{}type\PYG{o}{=}secondary \PYG{l+s+se}{\PYGZbs{}}
   \PYGZhy{}\PYGZhy{} \PYG{l+s+se}{\PYGZbs{}}
   \PYGZhy{}\PYGZhy{}client\PYGZhy{}id \PYG{l+m}{1} \PYGZhy{}s \PYG{l+m}{192}.168.1.100:6666 \PYG{l+s+se}{\PYGZbs{}}
   \PYGZhy{}c phy:0
\end{sphinxVerbatim}

You can confirm lcores and worker threads running on from \sphinxcode{\sphinxupquote{status}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} pcap 1; status
Basic Information:
  \PYGZhy{} client\PYGZhy{}id: 1
  \PYGZhy{} status: idle
  \PYGZhy{} lcore\PYGZus{}ids:
    \PYGZhy{} master: 1
    \PYGZhy{} slaves: [2, 3, 4, 5, 6]
Components:
  \PYGZhy{} core:2 receive
    \PYGZhy{} rx: phy:0
  \PYGZhy{} core:3 write
    \PYGZhy{} filename:
  \PYGZhy{} core:4 write
    \PYGZhy{} filename:
  \PYGZhy{} core:5 write
    \PYGZhy{} filename:
  \PYGZhy{} core:6 write
    \PYGZhy{} filename:
\end{sphinxVerbatim}


\subsubsection{Start Capture}
\label{\detokenize{usecases/spp_pcap:start-capture}}\label{\detokenize{usecases/spp_pcap:spp-pcap-use-case-start-capture}}
If you already started to send packets to \sphinxcode{\sphinxupquote{phy:0}} from outside,
you are ready to start capturing packets.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} pcap 1; start
Start packet capture.
\end{sphinxVerbatim}

As you run \sphinxcode{\sphinxupquote{start}} command, PCAP files are generated for each of
\sphinxcode{\sphinxupquote{writer}} threads for capturing.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} pcap 1; status
Basic Information:
  \PYGZhy{} client\PYGZhy{}id: 1
  \PYGZhy{} status: running
  \PYGZhy{} lcore\PYGZus{}ids:
    \PYGZhy{} master: 1
    \PYGZhy{} slaves: [2, 3, 4, 5, 6]
Components:
  \PYGZhy{} core:2 receive
    \PYGZhy{} rx: phy:0
  \PYGZhy{} core:3 write
    \PYGZhy{} filename: /tmp/spp\PYGZus{}pcap.20190214161550.phy0.1.1.pcap.lz4
  \PYGZhy{} core:4 write
    \PYGZhy{} filename: /tmp/spp\PYGZus{}pcap.20190214161550.phy0.2.1.pcap.lz4
  \PYGZhy{} core:5 write
    \PYGZhy{} filename: /tmp/spp\PYGZus{}pcap.20190214161550.phy0.3.1.pcap.lz4
  \PYGZhy{} core:6 write
    \PYGZhy{} filename: /tmp/spp\PYGZus{}pcap.20190214161550.phy0.4.1.pcap.lz4
\end{sphinxVerbatim}


\subsubsection{Stop Capture}
\label{\detokenize{usecases/spp_pcap:stop-capture}}\label{\detokenize{usecases/spp_pcap:spp-pcap-use-case-stop-capture}}
Stop capturing and confirm that compressed PCAP files are generated.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} pcap 1; stop
spp \PYGZgt{} ls /tmp
....
spp\PYGZus{}pcap.20190214175446.phy0.1.1.pcap.lz4
spp\PYGZus{}pcap.20190214175446.phy0.1.2.pcap.lz4
spp\PYGZus{}pcap.20190214175446.phy0.1.3.pcap.lz4
spp\PYGZus{}pcap.20190214175446.phy0.2.1.pcap.lz4
spp\PYGZus{}pcap.20190214175446.phy0.2.2.pcap.lz4
spp\PYGZus{}pcap.20190214175446.phy0.2.3.pcap.lz4
....
\end{sphinxVerbatim}

Index in the filename, such as \sphinxcode{\sphinxupquote{1.1}} or \sphinxcode{\sphinxupquote{1.2}}, is a combination of
\sphinxcode{\sphinxupquote{writer}} thread ID and sequenceal number.
In this case, it means each of four threads generate three files.


\subsubsection{Shutdown spp\_pcap}
\label{\detokenize{usecases/spp_pcap:shutdown-spp-pcap}}\label{\detokenize{usecases/spp_pcap:spp-pcap-use-case-shutdown}}
Run \sphinxcode{\sphinxupquote{exit}} or \sphinxcode{\sphinxupquote{bye sec}} command to terminate \sphinxcode{\sphinxupquote{spp\_pcap}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} terminal 2
spp \PYGZgt{} pcap 1; exit
\end{sphinxVerbatim}


\subsubsection{Inspect PCAP Files}
\label{\detokenize{usecases/spp_pcap:inspect-pcap-files}}\label{\detokenize{usecases/spp_pcap:spp-pcap-use-case-inspect-file}}
You can inspect captured PCAP files by using utilities.


\paragraph{Merge PCAP Files}
\label{\detokenize{usecases/spp_pcap:merge-pcap-files}}
Extract and merge compressed PCAP files.

For extract several LZ4 files at once, use \sphinxcode{\sphinxupquote{-d}} and \sphinxcode{\sphinxupquote{-m}} options.
\sphinxcode{\sphinxupquote{-d}} is for decompression and \sphinxcode{\sphinxupquote{-m}} is for multiple files.

You had better not to merge divided files into single file, but still
several files because the size of merged file might be huge.
Each of extracted PCAP file is 1GiB in default, so total size of extracted
files is 12GiB in this case. To avoid the situation, merge files for each of
threads and generate four PCAP files of 3GiB.

First, extract LZ4 files of writer thread ID 1.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} lz4 \PYGZhy{}d \PYGZhy{}m /tmp/spp\PYGZus{}pcap.20190214175446.phy0.1.*
\end{sphinxVerbatim}

And confirm that the files are extracted.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} ls /tmp \PYG{p}{\textbar{}} grep pcap\PYGZdl{}
\PYG{g+go}{spp\PYGZus{}pcap.20190214175446.phy0.1.1.pcap}
\PYG{g+go}{spp\PYGZus{}pcap.20190214175446.phy0.1.2.pcap}
\PYG{g+go}{spp\PYGZus{}pcap.20190214175446.phy0.1.3.pcap}
\end{sphinxVerbatim}

Run \sphinxcode{\sphinxupquote{mergecap}} command to merge extracted files to current directory
as \sphinxcode{\sphinxupquote{spp\_pcap1.pcap}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} mergecap /tmp/spp\PYGZus{}pcap.20190214175446.phy0.1.*.pcap \PYGZhy{}w spp\PYGZus{}pcap1.pcap
\end{sphinxVerbatim}


\paragraph{Inspect PCAP file}
\label{\detokenize{usecases/spp_pcap:inspect-pcap-file}}
You can use any of applications, for instance \sphinxcode{\sphinxupquote{wireshark}} or \sphinxcode{\sphinxupquote{tcpdump}},
for inspecting PCAP file.
To inspect the merged PCAP file, read packet data from \sphinxcode{\sphinxupquote{tcpdump}} command
in this usecase. \sphinxcode{\sphinxupquote{-r}} option is to dump packet data in human readable format.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} tcpdump \PYGZhy{}r spp\PYGZus{}pcap1.pcap \PYG{p}{\textbar{}} less
\PYG{g+go}{17:54:52.559783 IP 192.168.0.100.1234 \PYGZgt{} 192.168.1.1.5678: Flags [.], ...}
\PYG{g+go}{17:54:52.559784 IP 192.168.0.100.1234 \PYGZgt{} 192.168.1.1.5678: Flags [.], ...}
\PYG{g+go}{17:54:52.559785 IP 192.168.0.100.1234 \PYGZgt{} 192.168.1.1.5678: Flags [.], ...}
\PYG{g+go}{17:54:52.559785 IP 192.168.0.100.1234 \PYGZgt{} 192.168.1.1.5678: Flags [.], ...}
\end{sphinxVerbatim}


\section{Multiple Nodes}
\label{\detokenize{usecases/multi_nodes:multiple-nodes}}\label{\detokenize{usecases/multi_nodes:usecase-multi-node}}\label{\detokenize{usecases/multi_nodes::doc}}
SPP provides multi-node support for configuring network across several nodes
from SPP CLI. You can configure each of nodes step by step.

In \hyperref[\detokenize{usecases/multi_nodes:figure-spp-multi-nodes-vhost}]{Fig.\@ \ref{\detokenize{usecases/multi_nodes:figure-spp-multi-nodes-vhost}}}, there are four nodes on which
SPP and service VMs are running. Host1 behaves as a patch panel for connecting
between other nodes. A request is sent from a VM on host2 to a VM on host3 or
host4. Host4 is a backup server for host3 and replaced with host3 by changing
network configuration. Blue lines are paths for host3 and red lines are for
host4, and changed alternatively.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{spp_multi_nodes_vhost}.pdf}
\caption{Multiple nodes example}\label{\detokenize{usecases/multi_nodes:id1}}\label{\detokenize{usecases/multi_nodes:figure-spp-multi-nodes-vhost}}\end{figure}


\subsection{Launch SPP on Multiple Nodes}
\label{\detokenize{usecases/multi_nodes:launch-spp-on-multiple-nodes}}
Before SPP CLI, launch spp-ctl on each of nodes. You should give IP address
with \sphinxcode{\sphinxupquote{-b}} option to be accessed from outside of the node.
This is an example for launching spp-ctl on host1.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Launch on host1
\PYG{g+gp}{\PYGZdl{}} python3 src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl \PYGZhy{}b \PYG{l+m}{192}.168.11.101
\end{sphinxVerbatim}

You also need to launch it on host2, host3 and host4 in each of terminals.

After all of spp-ctls are lauched, launch SPP CLI with four \sphinxcode{\sphinxupquote{-b}} options
for each of hosts. SPP CLI is able to be launched on any of nodes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Launch SPP CLI
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py \PYGZhy{}b \PYG{l+m}{192}.168.11.101 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}b \PYG{l+m}{192}.168.11.102 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}b \PYG{l+m}{192}.168.11.103 \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}b \PYG{l+m}{192}.168.11.104 \PYG{l+s+se}{\PYGZbs{}}
\end{sphinxVerbatim}

Or you can add nodes after launching SPP CLI. Here is an example of
launching it with first node, and adding the rest of nodes after.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Launch SPP CLI
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py \PYGZhy{}b \PYG{l+m}{192}.168.11.101
\PYG{g+go}{Welcome to the spp.  Type help or ? to list commands.}

\PYG{g+go}{spp \PYGZgt{} server add 192.168.11.102}
\PYG{g+go}{Registered spp\PYGZhy{}ctl \PYGZdq{}192.168.11.102:7777\PYGZdq{}.}
\PYG{g+go}{spp \PYGZgt{} server add 192.168.11.103}
\PYG{g+go}{Registered spp\PYGZhy{}ctl \PYGZdq{}192.168.11.103:7777\PYGZdq{}.}
\PYG{g+go}{spp \PYGZgt{} server add 192.168.11.104}
\PYG{g+go}{Registered spp\PYGZhy{}ctl \PYGZdq{}192.168.11.104:7777\PYGZdq{}.}
\end{sphinxVerbatim}

If you have succeeded to launch all of \sphinxcode{\sphinxupquote{spp-ctl}} processes before,
you can find them by running \sphinxcode{\sphinxupquote{sever list}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Launch SPP CLI
\PYG{g+go}{spp \PYGZgt{} server list}
\PYG{g+go}{  1: 192.168.1.101:7777 *}
\PYG{g+go}{  2: 192.168.1.102:7777}
\PYG{g+go}{  3: 192.168.1.103:7777}
\PYG{g+go}{  4: 192.168.1.104:7777}
\end{sphinxVerbatim}

You might notice that first entry is marked with \sphinxcode{\sphinxupquote{*}}. It means that
the current node under the management is the first node.


\subsection{Switch Nodes}
\label{\detokenize{usecases/multi_nodes:switch-nodes}}
SPP CLI manages a node marked with \sphinxcode{\sphinxupquote{*}}. If you configure other nodes,
change the managed node with \sphinxcode{\sphinxupquote{server}} command.
Here is an example to switch to third node.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Launch SPP CLI
\PYG{g+go}{spp \PYGZgt{} server 3}
\PYG{g+go}{Switch spp\PYGZhy{}ctl to \PYGZdq{}3: 192.168.1.103:7777\PYGZdq{}.}
\end{sphinxVerbatim}

And the result after changed to host3.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} server list}
\PYG{g+go}{  1: 192.168.1.101:7777}
\PYG{g+go}{  2: 192.168.1.102:7777}
\PYG{g+go}{  3: 192.168.1.103:7777 *}
\PYG{g+go}{  4: 192.168.1.104:7777}
\end{sphinxVerbatim}

You can also confirm this change by checking IP address of spp-ctl from
\sphinxcode{\sphinxupquote{status}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} status}
\PYG{g+go}{\PYGZhy{} spp\PYGZhy{}ctl:}
\PYG{g+go}{  \PYGZhy{} address: 192.168.1.103:7777}
\PYG{g+go}{\PYGZhy{} primary:}
\PYG{g+go}{  \PYGZhy{} status: not running}
\PYG{g+go}{...}
\end{sphinxVerbatim}


\subsection{Configure Patch Panel Node}
\label{\detokenize{usecases/multi_nodes:configure-patch-panel-node}}
First of all of the network configuration, setup blue lines on host1
described in \hyperref[\detokenize{usecases/multi_nodes:figure-spp-multi-nodes-vhost}]{Fig.\@ \ref{\detokenize{usecases/multi_nodes:figure-spp-multi-nodes-vhost}}}.
You should confirm the managed server is host1.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} server list}
\PYG{g+go}{  1: 192.168.1.101:7777 *}
\PYG{g+go}{  2: 192.168.1.102:7777}
\PYG{g+go}{  ...}
\end{sphinxVerbatim}

Patch two sets of physical ports and start forwarding.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:1 phy:2}
\PYG{g+go}{Patch ports (phy:1 \PYGZhy{}\PYGZgt{} phy:2).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:3 phy:0}
\PYG{g+go}{Patch ports (phy:3 \PYGZhy{}\PYGZgt{} phy:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}


\subsection{Configure Service VM Nodes}
\label{\detokenize{usecases/multi_nodes:configure-service-vm-nodes}}
It is almost similar as
{\hyperref[\detokenize{usecases/spp_nfv:usecase-spp-nfv-l2fwd-vhost-nw}]{\sphinxcrossref{\DUrole{std,std-ref}{Setup Network Configuration in spp\_nfv}}}}
to setup for host2, host3, and host4.

For host2, swith server to host2 and run nfv commands.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} switch to server \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} server 2}
\PYG{g+go}{Switch spp\PYGZhy{}ctl to \PYGZdq{}2: 192.168.1.102:7777\PYGZdq{}.}

\PYG{g+gp}{\PYGZsh{}} configure
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:0 vhost:0}
\PYG{g+go}{Patch ports (phy:0 \PYGZhy{}\PYGZgt{} vhost:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch vhost:0 phy:1}
\PYG{g+go}{Patch ports (vhost:0 \PYGZhy{}\PYGZgt{} phy:1).}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}

Then, swith to host3 and host4 for doing the same configuration.


\subsection{Change Path to Backup Node}
\label{\detokenize{usecases/multi_nodes:change-path-to-backup-node}}
Finally, change path from blue lines to red lines.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} switch to server \PYG{l+m}{1}
\PYG{g+go}{spp \PYGZgt{} server 2}
\PYG{g+go}{Switch spp\PYGZhy{}ctl to \PYGZdq{}2: 192.168.1.102:7777\PYGZdq{}.}

\PYG{g+gp}{\PYGZsh{}} remove blue path
\PYG{g+go}{spp \PYGZgt{} nfv 1; stop}
\PYG{g+go}{Stop forwarding.}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch reset}

\PYG{g+gp}{\PYGZsh{}} configure red path
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch phy:1 phy:4}
\PYG{g+go}{Patch ports (phy:1 \PYGZhy{}\PYGZgt{} phy:4).}
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch phy:5 phy:0}
\PYG{g+go}{Patch ports (phy:5 \PYGZhy{}\PYGZgt{} phy:0).}
\PYG{g+go}{spp \PYGZgt{} nfv 2; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}


\chapter{SPP Commands}
\label{\detokenize{commands/index:spp-commands}}\label{\detokenize{commands/index:spp-commands-index}}\label{\detokenize{commands/index::doc}}
SPP provides commands for managing primary, secondary processes and SPP
controller.


\section{Primary Commands}
\label{\detokenize{commands/primary:primary-commands}}\label{\detokenize{commands/primary:commands-primary}}\label{\detokenize{commands/primary::doc}}
Primary process is managed with \sphinxcode{\sphinxupquote{pri}} command.

\sphinxcode{\sphinxupquote{pri}} command takes a sub command. They must be separated with delimiter
\sphinxcode{\sphinxupquote{;}}. Some of sub commands take additional arguments.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; SUB\PYGZus{}CMD}
\end{sphinxVerbatim}

All of Sub commands are referred with \sphinxcode{\sphinxupquote{help}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} help pri}
\PYG{g+go}{Send a command to primary process.}

\PYG{g+go}{    Show resources and statistics, or clear it.}

\PYG{g+go}{        spp \PYGZgt{} pri; status  \PYGZsh{} show status}

\PYG{g+go}{        spp \PYGZgt{} pri; clear   \PYGZsh{} clear statistics}

\PYG{g+go}{    Launch secondary process..}

\PYG{g+gp}{        \PYGZsh{}} Launch nfv:1
\PYG{g+go}{        spp \PYGZgt{} pri; launch nfv 1 \PYGZhy{}l 1,2 \PYGZhy{}m 512 \PYGZhy{}\PYGZhy{} \PYGZhy{}n 1 \PYGZhy{}s 192.168....}

\PYG{g+gp}{        \PYGZsh{}} Launch vf:2
\PYG{g+go}{        spp \PYGZgt{} pri; launch vf 2 \PYGZhy{}l 1,4\PYGZhy{}7 \PYGZhy{}m 512 \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}client\PYGZhy{}id 2 \PYGZhy{}s ...}
\end{sphinxVerbatim}


\subsection{status}
\label{\detokenize{commands/primary:status}}\label{\detokenize{commands/primary:commands-primary-status}}
Show status fo \sphinxcode{\sphinxupquote{spp\_primary}} and forwarding statistics of each of ports.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; status}
\PYG{g+go}{\PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{  \PYGZhy{} master: 0}
\PYG{g+go}{\PYGZhy{} stats}
\PYG{g+go}{  \PYGZhy{} physical ports:}
\PYG{g+go}{      ID          rx          tx    tx\PYGZus{}drop  mac\PYGZus{}addr}
\PYG{g+go}{       0           0           0           0  56:48:4f:53:54:00}
\PYG{g+go}{       1           0           0           0  56:48:4f:53:54:01}
\PYG{g+go}{  \PYGZhy{} ring ports:}
\PYG{g+go}{      ID          rx          tx     rx\PYGZus{}drop     tx\PYGZus{}drop}
\PYG{g+go}{       0           0           0           0           0}
\PYG{g+go}{       1           0           0           0           0}
\PYG{g+go}{       2           0           0           0           0}
\PYG{g+go}{       ...}
\end{sphinxVerbatim}

If you run \sphinxcode{\sphinxupquote{spp\_primary}} with forwarder thread, status of the forwarder is
also displayed.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; status}
\PYG{g+go}{\PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{  \PYGZhy{} master: 0}
\PYG{g+go}{  \PYGZhy{} slave: 1}
\PYG{g+go}{\PYGZhy{} forwarder:}
\PYG{g+go}{  \PYGZhy{} status: idling}
\PYG{g+go}{  \PYGZhy{} ports:}
\PYG{g+go}{    \PYGZhy{} phy:0}
\PYG{g+go}{    \PYGZhy{} phy:1}
\PYG{g+go}{\PYGZhy{} stats}
\PYG{g+go}{  \PYGZhy{} physical ports:}
\PYG{g+go}{      ID          rx          tx    tx\PYGZus{}drop  mac\PYGZus{}addr}
\PYG{g+go}{       0           0           0           0  56:48:4f:53:54:00}
\PYG{g+go}{       1           0           0           0  56:48:4f:53:54:01}
\PYG{g+go}{  \PYGZhy{} ring ports:}
\PYG{g+go}{      ID          rx          tx     rx\PYGZus{}drop     tx\PYGZus{}drop}
\PYG{g+go}{       0           0           0           0           0}
\PYG{g+go}{       1           0           0           0           0}
\PYG{g+go}{       ...}
\end{sphinxVerbatim}


\subsection{clear}
\label{\detokenize{commands/primary:clear}}\label{\detokenize{commands/primary:commands-primary-clear}}
Clear statistics.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; clear}
\PYG{g+go}{Clear port statistics.}
\end{sphinxVerbatim}


\subsection{add}
\label{\detokenize{commands/primary:add}}\label{\detokenize{commands/primary:commands-primary-add}}
Add a port with resource ID.

For example, adding \sphinxcode{\sphinxupquote{ring:0}} by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; add ring:0}
\PYG{g+go}{Add ring:0.}
\end{sphinxVerbatim}

Or adding \sphinxcode{\sphinxupquote{vhost:0}} by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; add vhost:0}
\PYG{g+go}{Add vhost:0.}
\end{sphinxVerbatim}


\subsection{patch}
\label{\detokenize{commands/primary:patch}}\label{\detokenize{commands/primary:commands-primary-patch}}
Create a path between two ports, source and destination ports.
This command just creates a path and does not start forwarding.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; patch phy:0 ring:0}
\PYG{g+go}{Patch ports (phy:0 \PYGZhy{}\PYGZgt{} ring:0).}
\end{sphinxVerbatim}


\subsection{forward}
\label{\detokenize{commands/primary:forward}}\label{\detokenize{commands/primary:commands-primary-forward}}
Start forwarding.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}

Running status is changed from \sphinxcode{\sphinxupquote{idling}} to \sphinxcode{\sphinxupquote{running}} by
executing it.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; status}
\PYG{g+go}{\PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{  \PYGZhy{} master: 0}
\PYG{g+go}{  \PYGZhy{} slave: 1}
\PYG{g+go}{\PYGZhy{} forwarder:}
\PYG{g+go}{  \PYGZhy{} status: running}
\PYG{g+go}{  \PYGZhy{} ports:}
\PYG{g+go}{    \PYGZhy{} phy:0}
\PYG{g+go}{    \PYGZhy{} phy:1}
\PYG{g+go}{...}
\end{sphinxVerbatim}


\subsection{stop}
\label{\detokenize{commands/primary:stop}}\label{\detokenize{commands/primary:commands-primary-stop}}
Stop forwarding.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; stop}
\PYG{g+go}{Stop forwarding.}
\end{sphinxVerbatim}

Running status is changed from \sphinxcode{\sphinxupquote{running}} to \sphinxcode{\sphinxupquote{idling}} by
executing it.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; status}
\PYG{g+go}{\PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{  \PYGZhy{} master: 0}
\PYG{g+go}{  \PYGZhy{} slave: 1}
\PYG{g+go}{\PYGZhy{} forwarder:}
\PYG{g+go}{  \PYGZhy{} status: idling}
\PYG{g+go}{  \PYGZhy{} ports:}
\PYG{g+go}{    \PYGZhy{} phy:0}
\PYG{g+go}{    \PYGZhy{} phy:1}
\PYG{g+go}{...}
\end{sphinxVerbatim}


\subsection{del}
\label{\detokenize{commands/primary:del}}\label{\detokenize{commands/primary:commands-primary-del}}
Delete a port of given resource UID.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} pri; del ring:0}
\PYG{g+go}{Delete ring:0.}
\end{sphinxVerbatim}


\subsection{launch}
\label{\detokenize{commands/primary:launch}}\label{\detokenize{commands/primary:commands-primary-launch}}
Launch a secondary process.

Spp\_primary is able to launch a secondary process with given type, secondary
ID and options of EAL and application itself. This is a list of supported type
of secondary processes.
\begin{itemize}
\item {} 
nfv

\item {} 
vf

\item {} 
mirror

\item {} 
pcap

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} spp\PYGZus{}nfv with sec ID \PYG{l+m}{1}
\PYG{g+go}{spp \PYGZgt{} pri; launch nfv 1 \PYGZhy{}l 1,2 \PYGZhy{}m 512 \PYGZhy{}\PYGZhy{} \PYGZhy{}n \PYGZhy{}s 192.168.1.100:6666}

\PYG{g+gp}{\PYGZsh{}} spp\PYGZus{}vf with sec ID \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} pri; launch vf 2 \PYGZhy{}l 1,3\PYGZhy{}5 \PYGZhy{}m 512 \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}client\PYGZhy{}id \PYGZhy{}s 192.168.1.100:6666}
\end{sphinxVerbatim}

You notice that \sphinxcode{\sphinxupquote{-{-}proc-type secondary}} is not given for launching secondary
processes. \sphinxcode{\sphinxupquote{launch}} command adds this option before requesting to launch
the process so that you do not need to input this option by yourself.

\sphinxcode{\sphinxupquote{launch}} command supports TAB completion for type, secondary ID and the rest
of options. Some of EAL and application options are just a template, so you
should edit them before launching. Some of default params of options,
for instance, the number of lcores or the amount of memory, are changed from
\sphinxcode{\sphinxupquote{config}} command of {\hyperref[\detokenize{commands/common:commands-common-config}]{\sphinxcrossref{\DUrole{std,std-ref}{Common Commands}}}}.

In terms of log, each of secondary processes are output its log messages to
files under \sphinxcode{\sphinxupquote{log}} directory of project root. The name of log file is defined
with type of process and secondary ID. For instance, \sphinxcode{\sphinxupquote{nfv 2}}, the path of log
file is \sphinxcode{\sphinxupquote{log/spp\_nfv-2.log}}.


\section{Secondary Commands}
\label{\detokenize{commands/secondary/index:secondary-commands}}\label{\detokenize{commands/secondary/index::doc}}

\subsection{spp\_nfv}
\label{\detokenize{commands/secondary/spp_nfv:spp-nfv}}\label{\detokenize{commands/secondary/spp_nfv:commands-spp-nfv}}\label{\detokenize{commands/secondary/spp_nfv::doc}}
Each of \sphinxcode{\sphinxupquote{spp\_nfv}} and \sphinxcode{\sphinxupquote{spp\_vm}} processes is managed with \sphinxcode{\sphinxupquote{nfv}} command.
It is for sending sub commands to secondary with specific ID called
secondary ID.

\sphinxcode{\sphinxupquote{nfv}} command takes an secondary ID and a sub command. They must be
separated with delimiter \sphinxcode{\sphinxupquote{;}}.
Some of sub commands take additional arguments for speicfying resource
owned by secondary process.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv SEC\PYGZus{}ID; SUB\PYGZus{}CMD}
\end{sphinxVerbatim}

All of Sub commands are referred with \sphinxcode{\sphinxupquote{help}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} help nfv}

\PYG{g+go}{Send a command to secondary process specified with ID.}

\PYG{g+go}{    SPP secondary process is specified with secondary ID and takes}
\PYG{g+go}{    sub commands.}

\PYG{g+go}{    spp \PYGZgt{} nfv 1; status}
\PYG{g+go}{    spp \PYGZgt{} nfv 1; add ring:0}
\PYG{g+go}{    spp \PYGZgt{} nfv 1; patch phy:0 ring:0}

\PYG{g+go}{    You can refer all of sub commands by pressing TAB after}
\PYG{g+go}{    \PYGZsq{}nfv 1;\PYGZsq{}.}

\PYG{g+go}{    spp \PYGZgt{} nfv 1;  \PYGZsh{} press TAB}
\PYG{g+go}{    add     del     exit    forward patch   status  stop}
\end{sphinxVerbatim}


\subsubsection{status}
\label{\detokenize{commands/secondary/spp_nfv:status}}\label{\detokenize{commands/secondary/spp_nfv:commands-spp-nfv-status}}
Show running status and ports assigned to the process. If a port is
patched to other port, source and destination ports are shown, or only
source if it is not patched.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; status}
\PYG{g+go}{\PYGZhy{} status: idling}
\PYG{g+go}{\PYGZhy{} lcores: [1, 2]}
\PYG{g+go}{\PYGZhy{} ports:}
\PYG{g+go}{  \PYGZhy{} phy:0 \PYGZhy{}\PYGZgt{} ring:0}
\PYG{g+go}{  \PYGZhy{} phy:1}
\end{sphinxVerbatim}


\subsubsection{add}
\label{\detokenize{commands/secondary/spp_nfv:add}}\label{\detokenize{commands/secondary/spp_nfv:commands-spp-nfv-add}}
Add a port to the secondary with resource ID.

For example, adding \sphinxcode{\sphinxupquote{ring:0}} by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; add ring:0}
\PYG{g+go}{Add ring:0.}
\end{sphinxVerbatim}

Or adding \sphinxcode{\sphinxupquote{vhost:0}} by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; add vhost:0}
\PYG{g+go}{Add vhost:0.}
\end{sphinxVerbatim}


\subsubsection{patch}
\label{\detokenize{commands/secondary/spp_nfv:patch}}\label{\detokenize{commands/secondary/spp_nfv:commands-spp-nfv-patch}}
Create a path between two ports, source and destination ports.
This command just creates a path and does not start forwarding.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:0 ring:0}
\PYG{g+go}{Patch ports (phy:0 \PYGZhy{}\PYGZgt{} ring:0).}
\end{sphinxVerbatim}


\subsubsection{forward}
\label{\detokenize{commands/secondary/spp_nfv:forward}}\label{\detokenize{commands/secondary/spp_nfv:commands-spp-nfv-forward}}
Start forwarding.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{Start forwarding.}
\end{sphinxVerbatim}

Running status is changed from \sphinxcode{\sphinxupquote{idling}} to \sphinxcode{\sphinxupquote{running}} by
executing it.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; status}
\PYG{g+go}{\PYGZhy{} status: running}
\PYG{g+go}{\PYGZhy{} ports:}
\PYG{g+go}{  \PYGZhy{} phy:0}
\PYG{g+go}{  \PYGZhy{} phy:1}
\end{sphinxVerbatim}


\subsubsection{stop}
\label{\detokenize{commands/secondary/spp_nfv:stop}}\label{\detokenize{commands/secondary/spp_nfv:commands-spp-nfv-stop}}
Stop forwarding.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; stop}
\PYG{g+go}{Stop forwarding.}
\end{sphinxVerbatim}

Running status is changed from \sphinxcode{\sphinxupquote{running}} to \sphinxcode{\sphinxupquote{idling}} by
executing it.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; status}
\PYG{g+go}{\PYGZhy{} status: idling}
\PYG{g+go}{\PYGZhy{} ports:}
\PYG{g+go}{  \PYGZhy{} phy:0}
\PYG{g+go}{  \PYGZhy{} phy:1}
\end{sphinxVerbatim}


\subsubsection{del}
\label{\detokenize{commands/secondary/spp_nfv:del}}\label{\detokenize{commands/secondary/spp_nfv:commands-spp-nfv-del}}
Delete a port from the secondary.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; del ring:0}
\PYG{g+go}{Delete ring:0.}
\end{sphinxVerbatim}


\subsubsection{exit}
\label{\detokenize{commands/secondary/spp_nfv:exit}}\label{\detokenize{commands/secondary/spp_nfv:commands-spp-nfv-exit}}
Terminate the secondary. For terminating all secondaries,
use \sphinxcode{\sphinxupquote{bye sec}} command instead of it.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} nfv 1; exit}
\end{sphinxVerbatim}


\subsection{spp\_vf}
\label{\detokenize{commands/secondary/spp_vf:spp-vf}}\label{\detokenize{commands/secondary/spp_vf:commands-spp-vf}}\label{\detokenize{commands/secondary/spp_vf::doc}}
\sphinxcode{\sphinxupquote{spp\_vf}} is a kind of SPP secondary process. It is introduced for
providing SR-IOV like features.

Each of \sphinxcode{\sphinxupquote{spp\_vf}} processes is managed with \sphinxcode{\sphinxupquote{vf}} command. It is for
sending sub commands with specific ID called secondary ID for changing
configuration, assigning or releasing resources.

Secondary ID is referred as \sphinxcode{\sphinxupquote{-{-}client-id}} which is given as an argument
while launching \sphinxcode{\sphinxupquote{spp\_vf}}. It should be unique among all of secondary
processes including \sphinxcode{\sphinxupquote{spp\_nfv}} and others.

\sphinxcode{\sphinxupquote{vf}} command takes an secondary ID and one of sub commands. Secondary ID
and sub command should be separated with delimiter \sphinxcode{\sphinxupquote{;}}, or failed to a
command error. Some of sub commands take additional arguments for
configuration of the process or its resource management.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf SEC\PYGZus{}ID; SUB\PYGZus{}CMD}
\end{sphinxVerbatim}

In this example, \sphinxcode{\sphinxupquote{SEC\_ID}} is a secondary ID and \sphinxcode{\sphinxupquote{SUB\_CMD}} is one of the
following sub commands. Details of each of sub commands are described in the
next sections.
\begin{itemize}
\item {} 
status

\item {} 
component

\item {} 
port

\item {} 
classifier\_table

\end{itemize}

\sphinxcode{\sphinxupquote{spp\_vf}} supports TAB completion. You can complete all of the name
of commands and its arguments. For instance, you find all of sub commands
by pressing TAB after \sphinxcode{\sphinxupquote{vf SEC\_ID;}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf 1;  \PYGZsh{} press TAB key}
\PYG{g+go}{classifier\PYGZus{}table  component      port        status}
\end{sphinxVerbatim}

It tries to complete all of possible arguments. However, \sphinxcode{\sphinxupquote{spp\_vf}} takes
also an arbitrary parameter which cannot be predicted, for example, name of
component MAC address. In this cases, \sphinxcode{\sphinxupquote{spp\_vf}} shows capitalized keyword
for indicating it is an arbitrary parameter. Here is an exmaple of
\sphinxcode{\sphinxupquote{component}} command to initialize a worker thread. Keyword \sphinxcode{\sphinxupquote{NAME}} should
be replaced with your favorite name for the worker of the role.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf 1; component st  \PYGZsh{} press TAB key to show args starting \PYGZsq{}st\PYGZsq{}}
\PYG{g+go}{start  stop}
\PYG{g+go}{spp \PYGZgt{} vf 1; component start NAME  \PYGZsh{} \PYGZsq{}NAME\PYGZsq{} is shown with TAB after start}
\PYG{g+go}{spp \PYGZgt{} vf 1; component start fw1   \PYGZsh{} replace \PYGZsq{}NAME\PYGZsq{} with your favorite name}
\PYG{g+go}{spp \PYGZgt{} vf 1; component start fw1   \PYGZsh{} then, press TAB to show core IDs}
\PYG{g+go}{5  6  7  8}
\end{sphinxVerbatim}

It is another example of replacing keyword. \sphinxcode{\sphinxupquote{port}} is a sub command for
assigning a resource to a worker thread. \sphinxcode{\sphinxupquote{RES\_UID}} is replaced with
resource UID which is a combination of port type and its ID such as
\sphinxcode{\sphinxupquote{ring:0}} or \sphinxcode{\sphinxupquote{vhost:1}} to assign it as RX port of forwarder \sphinxcode{\sphinxupquote{fw1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf 1; port add RES\PYGZus{}UID}
\PYG{g+go}{spp \PYGZgt{} vf 1; port add ring:0 rx fw1}
\end{sphinxVerbatim}

If you are reached to the end of arguments, no candidate keyword is displayed.
It is a completed statement of \sphinxcode{\sphinxupquote{component}} command, and TAB
completion does not work after \sphinxcode{\sphinxupquote{forwarder}} because it is ready to run.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf 1; component start fw1 5 forwarder}
\PYG{g+go}{Succeeded to start component \PYGZsq{}fw1\PYGZsq{} on core:5}
\end{sphinxVerbatim}

It is also completed secondary IDs of \sphinxcode{\sphinxupquote{spp\_vf}} and it is helpful if you run
several \sphinxcode{\sphinxupquote{spp\_vf}} processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf  \PYGZsh{} press TAB after space following \PYGZsq{}vf\PYGZsq{}}
\PYG{g+go}{1;  3;    \PYGZsh{} you find two spp\PYGZus{}vf processes of sec ID 1, 3}
\end{sphinxVerbatim}

By the way, it is also a case of no candidate keyword is displayed if your
command statement is wrong. You might be encountered an error if you run the
wrong command. Please take care.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf 1; compo  \PYGZsh{} no candidate shown for wrong command}
\PYG{g+go}{Invalid command \PYGZdq{}compo\PYGZdq{}.}
\end{sphinxVerbatim}


\subsubsection{status}
\label{\detokenize{commands/secondary/spp_vf:status}}\label{\detokenize{commands/secondary/spp_vf:commands-spp-vf-status}}
Show the information of worker threads and its resources. Status information
consists of three parts.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf 1; status}
\PYG{g+go}{Basic Information:}
\PYG{g+go}{  \PYGZhy{} client\PYGZhy{}id: 3}
\PYG{g+go}{  \PYGZhy{} ports: [phy:0, phy:1, ring:0, ring:1, ring:2, ring:3, ring:4]}
\PYG{g+go}{  \PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{    \PYGZhy{} master: 2}
\PYG{g+go}{    \PYGZhy{} slaves: [3, 4, 5, 6]}
\PYG{g+go}{Classifier Table:}
\PYG{g+go}{  \PYGZhy{} C0:8E:CD:38:EA:A8, ring:4}
\PYG{g+go}{  \PYGZhy{} C0:8E:CD:38:BC:E6, ring:3}
\PYG{g+go}{Components:}
\PYG{g+go}{  \PYGZhy{} core:5 \PYGZsq{}fw1\PYGZsq{} (type: forward)}
\PYG{g+go}{    \PYGZhy{} rx: ring:0}
\PYG{g+go}{    \PYGZhy{} tx: ring:1}
\PYG{g+go}{  \PYGZhy{} core:6 \PYGZsq{}mg\PYGZsq{} (type: merge)}
\PYG{g+go}{  \PYGZhy{} core:7 \PYGZsq{}cls\PYGZsq{} (type: classifier)}
\PYG{g+go}{    \PYGZhy{} rx: ring:2}
\PYG{g+go}{    \PYGZhy{} tx: ring:3}
\PYG{g+go}{    \PYGZhy{} tx: ring:4}
\PYG{g+go}{  \PYGZhy{} core:8 \PYGZsq{}\PYGZsq{} (type: unuse)}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{Basic Information}} is for describing attributes of \sphinxcode{\sphinxupquote{spp\_vf}} itself.
\sphinxcode{\sphinxupquote{client-id}} is a secondary ID of the process and \sphinxcode{\sphinxupquote{ports}} is a list of
all of ports owned the process.

\sphinxcode{\sphinxupquote{Classifier Table}} is a list of entries of \sphinxcode{\sphinxupquote{classifier}} worker thread.
Each of entry is a combination of MAC address and destination port which is
assigned to this thread.

\sphinxcode{\sphinxupquote{Components}} is a list of all of worker threads. Each of workers has a
core ID running on, type of the worker and a list of resources.
Entry of no name with \sphinxcode{\sphinxupquote{unuse}} type means that no worker thread assigned to
the core. In other words, it is ready to be assigned.


\subsubsection{component}
\label{\detokenize{commands/secondary/spp_vf:component}}\label{\detokenize{commands/secondary/spp_vf:commands-spp-vf-component}}
Assign or release a role of forwarding to worker threads running on each of
cores which are reserved with \sphinxcode{\sphinxupquote{-c}} or \sphinxcode{\sphinxupquote{-l}} option while launching
\sphinxcode{\sphinxupquote{spp\_vf}}. The role of the worker is chosen from \sphinxcode{\sphinxupquote{forwarder}}, \sphinxcode{\sphinxupquote{merger}} or
\sphinxcode{\sphinxupquote{classifier}}.

\sphinxcode{\sphinxupquote{forwarder}} role is for simply forwarding from source port to destination
port.
On the other hands, \sphinxcode{\sphinxupquote{merger}} role is for receiving packets from multiple
ports as N:1 communication, or \sphinxcode{\sphinxupquote{classifier}} role is for sending packet to
multiple ports by referring MAC address as 1:N communication.

You are required to give an arbitrary name with as an ID for specifying the role.
This name is also used while releasing the role.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} assign \PYG{l+s+s1}{\PYGZsq{}ROLE\PYGZsq{}} to worker on \PYG{l+s+s1}{\PYGZsq{}CORE\PYGZus{}ID\PYGZsq{}} with a \PYG{l+s+s1}{\PYGZsq{}NAME\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} vf SEC\PYGZus{}ID; component start NAME CORE\PYGZus{}ID ROLE}

\PYG{g+gp}{\PYGZsh{}} release worker \PYG{l+s+s1}{\PYGZsq{}NAME\PYGZsq{}} from the role
\PYG{g+go}{spp \PYGZgt{} vf SEC\PYGZus{}ID; component stop NAME}
\end{sphinxVerbatim}

Here are some examples of assigning roles with \sphinxcode{\sphinxupquote{component}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} assign \PYG{l+s+s1}{\PYGZsq{}forwarder\PYGZsq{}} role with name \PYG{l+s+s1}{\PYGZsq{}fw1\PYGZsq{}} on core \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} vf 2; component start fw1 2 forwarder}

\PYG{g+gp}{\PYGZsh{}} assign \PYG{l+s+s1}{\PYGZsq{}merger\PYGZsq{}} role with name \PYG{l+s+s1}{\PYGZsq{}mgr1\PYGZsq{}} on core \PYG{l+m}{3}
\PYG{g+go}{spp \PYGZgt{} vf 2; component start mgr1 3 merger}

\PYG{g+gp}{\PYGZsh{}} assign \PYG{l+s+s1}{\PYGZsq{}classifier\PYGZsq{}} role with name \PYG{l+s+s1}{\PYGZsq{}cls1\PYGZsq{}} on core \PYG{l+m}{4}
\PYG{g+go}{spp \PYGZgt{} vf 2; component start cls1 4 classifier}
\end{sphinxVerbatim}

In the above examples, each different \sphinxcode{\sphinxupquote{CORE-ID}} is specified to each role.
You can assign several components on the same core, but performance might be
decreased. This is an example for assigning two roles of \sphinxcode{\sphinxupquote{forward}} and
\sphinxcode{\sphinxupquote{merge}} on the same \sphinxcode{\sphinxupquote{core 2}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} assign two roles on the same \PYG{l+s+s1}{\PYGZsq{}core 2\PYGZsq{}}.
\PYG{g+go}{spp \PYGZgt{} vf 2; component start fw1 2 forwarder}
\PYG{g+go}{spp \PYGZgt{} vf 2; component start mgr1 2 merger}
\end{sphinxVerbatim}

Examples of releasing roles.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} release roles
\PYG{g+go}{spp \PYGZgt{} vf 2; component stop fw1}
\PYG{g+go}{spp \PYGZgt{} vf 2; component stop mgr1}
\PYG{g+go}{spp \PYGZgt{} vf 2; component stop cls1}
\end{sphinxVerbatim}


\subsubsection{port}
\label{\detokenize{commands/secondary/spp_vf:port}}\label{\detokenize{commands/secondary/spp_vf:commands-spp-vf-port}}
Add or delete a port to a worker.


\paragraph{Adding port}
\label{\detokenize{commands/secondary/spp_vf:adding-port}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf SEC\PYGZus{}ID; port add RES\PYGZus{}UID DIR NAME}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{RES\_UID}} is with replaced with resource UID such as \sphinxcode{\sphinxupquote{ring:0}} or
\sphinxcode{\sphinxupquote{vhost:1}}. \sphinxcode{\sphinxupquote{spp\_vf}} supports three types of port.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{phy}} : Physical NIC

\item {} 
\sphinxcode{\sphinxupquote{ring}} : Ring PMD

\item {} 
\sphinxcode{\sphinxupquote{vhost}} : Vhost PMD

\end{itemize}

\sphinxcode{\sphinxupquote{DIR}} means the direction of forwarding and it should be \sphinxcode{\sphinxupquote{rx}} or \sphinxcode{\sphinxupquote{tx}}.
\sphinxcode{\sphinxupquote{NAME}} is the same as for \sphinxcode{\sphinxupquote{component}} command.

This is an example for adding ports to a classifer \sphinxcode{\sphinxupquote{cls1}}. In this case,
it is configured to receive packets from \sphinxcode{\sphinxupquote{phy:0}} and send it to \sphinxcode{\sphinxupquote{ring:0}}
or \sphinxcode{\sphinxupquote{ring:1}}. The destination is decided with MAC address of the packets
by referring the table. How to configure the table is described in
{\hyperref[\detokenize{commands/secondary/spp_vf:commands-spp-vf-classifier-table}]{\sphinxcrossref{\DUrole{std,std-ref}{classifier\_table}}}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} recieve from \PYG{l+s+s1}{\PYGZsq{}phy:0\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} vf 2; port add phy:0 rx cls1}

\PYG{g+gp}{\PYGZsh{}} send to \PYG{l+s+s1}{\PYGZsq{}ring:0\PYGZsq{}} and \PYG{l+s+s1}{\PYGZsq{}ring:1\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} vf 2; port add ring:0 tx cls1}
\PYG{g+go}{spp \PYGZgt{} vf 2; port add ring:1 tx cls1}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{spp\_vf}} also supports VLAN features, adding or deleting VLAN tag.
It is used remove VLAN tags from incoming packets from outside of host
machine, or add VLAN tag to outgoing packets.

To configure VLAN features, use additional sub command \sphinxcode{\sphinxupquote{add\_vlantag}}
or \sphinxcode{\sphinxupquote{del\_vlantag}} followed by \sphinxcode{\sphinxupquote{port}} sub command.

To remove VLAN tag, simply add \sphinxcode{\sphinxupquote{del\_vlantag}} sub command without arguments.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf SEC\PYGZus{}ID; port add RES\PYGZus{}UID DIR NAME del\PYGZus{}vlantag}
\end{sphinxVerbatim}

On the other hand, use \sphinxcode{\sphinxupquote{add\_vlantag}} which takes two arguments,
\sphinxcode{\sphinxupquote{VID}} and \sphinxcode{\sphinxupquote{PCP}}, for adding VLAN tag to the packets.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf SEC\PYGZus{}ID; port add RES\PYGZus{}UID DIR NAME add\PYGZus{}vlantag VID PCP}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{VID}} is a VLAN ID and \sphinxcode{\sphinxupquote{PCP}} is a Priority Code Point defined in
\sphinxhref{https://1.ieee802.org/}{IEEE 802.1p}.
It is used for QoS by defining priority ranged from lowest prioroty
\sphinxcode{\sphinxupquote{0}} to the highest \sphinxcode{\sphinxupquote{7}}.

Here is an example of use of VLAN features considering a use case of
a forwarder removes VLAN tag from incoming packets and another forwarder
adds VLAN tag before sending packet outside.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} remove VLAN tag in forwarder \PYG{l+s+s1}{\PYGZsq{}fw1\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} vf 2; port add phy:0 rx fw1 del\PYGZus{}vlantag}

\PYG{g+gp}{\PYGZsh{}} add VLAN tag with VLAN ID and PCP in forwarder \PYG{l+s+s1}{\PYGZsq{}fw2\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} vf 2; port add phy:1 tx fw2 add\PYGZus{}vlantag 101 3}
\end{sphinxVerbatim}

Adding port may cause component to start packet forwarding. Please see
detail in
{\hyperref[\detokenize{design/spp_secondary:spp-design-spp-sec-vf}]{\sphinxcrossref{\DUrole{std,std-ref}{design spp\_vf}}}}.

Until one rx port and one tx port are added, forwarder does not start packet
forwarding. If it is requested to add more than one rx and one tx port, it
replies an error message.
Until at least one rx port and two tx ports are added, classifier does not
start packet forwarding. If it is requested to add more than two rx ports, it
replies an error message.
Until at least two rx ports and one tx port are added, merger does not start
packet forwarding. If it is requested to add more than two tx ports, it replies
an error message.


\paragraph{Deleting port}
\label{\detokenize{commands/secondary/spp_vf:deleting-port}}
Delete a port which is not used anymore.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf SEC\PYGZus{}ID; port del RES\PYGZus{}UID DIR NAME}
\end{sphinxVerbatim}

It is same as the adding port, but no need to add additional sub command
for VLAN features.

Here is an example.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} delete rx port \PYG{l+s+s1}{\PYGZsq{}ring:0\PYGZsq{}} from \PYG{l+s+s1}{\PYGZsq{}cls1\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} vf 2; port del ring:0 rx cls1}

\PYG{g+gp}{\PYGZsh{}} delete tx port \PYG{l+s+s1}{\PYGZsq{}vhost:1\PYGZsq{}} from \PYG{l+s+s1}{\PYGZsq{}mgr1\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} vf 2; port del vhost:1 tx mgr1}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Deleting port may cause component to stop packet forwarding.
Please see detail in {\hyperref[\detokenize{design/spp_secondary:spp-design-spp-sec-vf}]{\sphinxcrossref{\DUrole{std,std-ref}{design spp\_vf}}}}.
\end{sphinxadmonition}


\subsubsection{classifier\_table}
\label{\detokenize{commands/secondary/spp_vf:classifier-table}}\label{\detokenize{commands/secondary/spp_vf:commands-spp-vf-classifier-table}}
Register an entry of a combination of MAC address and port to
a table of classifier.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} add entry
\PYG{g+go}{spp \PYGZgt{} vf SEC\PYGZus{}ID; classifier\PYGZus{}table add mac MAC\PYGZus{}ADDR RES\PYGZus{}UID}

\PYG{g+gp}{\PYGZsh{}} delete entry
\PYG{g+go}{spp \PYGZgt{} vf SEC\PYGZus{}ID; classifier\PYGZus{}table del mac MAC\PYGZus{}ADDRESS RES\PYGZus{}ID}
\end{sphinxVerbatim}

This is an example to register MAC address \sphinxcode{\sphinxupquote{52:54:00:01:00:01}}
with port \sphinxcode{\sphinxupquote{ring:0}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf 1; classifier\PYGZus{}table add mac 52:54:00:01:00:01 ring:0}
\end{sphinxVerbatim}

Classifier supports the \sphinxcode{\sphinxupquote{default}} entry for packets which does not
match any of entries in the table. If you assign \sphinxcode{\sphinxupquote{ring:1}} as default,
simply specify \sphinxcode{\sphinxupquote{default}} instead of MAC address.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf 1; classifier\PYGZus{}table add mac default ring:1}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{classifier\_table}} sub command also supports VLAN features as similar
to \sphinxcode{\sphinxupquote{port}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} add entry with VLAN features
\PYG{g+go}{spp \PYGZgt{} vf SEC\PYGZus{}ID; classifier\PYGZus{}table add vlan VID MAC\PYGZus{}ADDR RES\PYGZus{}UID}

\PYG{g+gp}{\PYGZsh{}} delete entry of VLAN
\PYG{g+go}{spp \PYGZgt{} vf SEC\PYGZus{}ID; classifier\PYGZus{}table del vlan VID MAC\PYGZus{}ADDR RES\PYGZus{}UID}
\end{sphinxVerbatim}

Here is an example for adding entries.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} add entry with VLAN tag
\PYG{g+go}{spp \PYGZgt{} vf 1; classifier\PYGZus{}table add vlan 101 52:54:00:01:00:01 ring:0}

\PYG{g+gp}{\PYGZsh{}} add entry of default with VLAN tag
\PYG{g+go}{spp \PYGZgt{} vf 1; classifier\PYGZus{}table add vlan 101 default ring:1}
\end{sphinxVerbatim}

Delete an entry. This is an example to delete an entry with VLAN tag 101.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} delete entry with VLAN tag
\PYG{g+go}{spp \PYGZgt{} vf 1; classifier\PYGZus{}table del vlan 101 52:54:00:01:00:01 ring:0}
\end{sphinxVerbatim}


\subsubsection{exit}
\label{\detokenize{commands/secondary/spp_vf:exit}}
Terminate the spp\_vf.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} vf 1; exit}
\end{sphinxVerbatim}


\subsection{spp\_mirror}
\label{\detokenize{commands/secondary/spp_mirror:spp-mirror}}\label{\detokenize{commands/secondary/spp_mirror:commands-spp-mirror}}\label{\detokenize{commands/secondary/spp_mirror::doc}}
\sphinxcode{\sphinxupquote{spp\_mirror}} is an implementation of TaaS feature as a SPP secondary process
for port mirroring.

Each of \sphinxcode{\sphinxupquote{spp\_mirror}} processes is managed with \sphinxcode{\sphinxupquote{mirror}} command. Because
basic design of \sphinxcode{\sphinxupquote{spp\_mirror}} is derived from \sphinxcode{\sphinxupquote{spp\_vf}}, its commands are
almost similar to \sphinxcode{\sphinxupquote{spp\_vf}}.

Secondary ID is referred as \sphinxcode{\sphinxupquote{-{-}client-id}} which is given as an argument
while launching \sphinxcode{\sphinxupquote{spp\_mirror}}. It should be unique among all of secondary
processes including \sphinxcode{\sphinxupquote{spp\_nfv}} and others.

\sphinxcode{\sphinxupquote{mirror}} command takes an secondary ID and one of sub commands. Secondary ID
and sub command should be separated with delimiter \sphinxcode{\sphinxupquote{;}}, or failed to a
command error. Some of sub commands take additional arguments for
configuration of the process or its resource management.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror SEC\PYGZus{}ID; SUB\PYGZus{}CMD}
\end{sphinxVerbatim}

In this example, \sphinxcode{\sphinxupquote{SEC\_ID}} is a secondary ID and \sphinxcode{\sphinxupquote{SUB\_CMD}} is one of the
following sub commands. Details of each of sub commands are described in the
next sections.
\begin{itemize}
\item {} 
status

\item {} 
component

\item {} 
port

\end{itemize}

\sphinxcode{\sphinxupquote{spp\_mirror}} supports TAB completion. You can complete all of the name
of commands and its arguments. For instance, you find all of sub commands
by pressing TAB after \sphinxcode{\sphinxupquote{mirror SEC\_ID;}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror 1;  \PYGZsh{} press TAB key}
\PYG{g+go}{component      port        status}
\end{sphinxVerbatim}

It tries to complete all of possible arguments. However, \sphinxcode{\sphinxupquote{spp\_mirror}} takes
also an arbitrary parameter which cannot be predicted, for example, name of
component. In this cases, \sphinxcode{\sphinxupquote{spp\_mirror}} shows capitalized keyword for
indicating it is an arbitrary parameter. Here is an exmaple of \sphinxcode{\sphinxupquote{component}}
command to initialize a worker thread. Keyword \sphinxcode{\sphinxupquote{NAME}} should be replaced with
your favorite name for the worker of the role.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror 1; component st  \PYGZsh{} press TAB key to show args starting \PYGZsq{}st\PYGZsq{}}
\PYG{g+go}{start  stop}
\PYG{g+go}{spp \PYGZgt{} mirror 1; component start NAME  \PYGZsh{} \PYGZsq{}NAME\PYGZsq{} is shown with TAB after start}
\PYG{g+go}{spp \PYGZgt{} mirror 1; component start mr1   \PYGZsh{} replace \PYGZsq{}NAME\PYGZsq{} with favorite name}
\PYG{g+go}{spp \PYGZgt{} mirror 1; component start mr1   \PYGZsh{} then, press TAB to show core IDs}
\PYG{g+go}{5  6  7}
\end{sphinxVerbatim}

It is another example of replacing keyword. \sphinxcode{\sphinxupquote{port}} is a sub command for
assigning a resource to a worker thread. \sphinxcode{\sphinxupquote{RES\_UID}} is replaced with
resource UID which is a combination of port type and its ID such as
\sphinxcode{\sphinxupquote{ring:0}} or \sphinxcode{\sphinxupquote{vhost:1}} to assign it as RX port of forwarder \sphinxcode{\sphinxupquote{mr1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror 1; port add RES\PYGZus{}UID}
\PYG{g+go}{spp \PYGZgt{} mirror 1; port add ring:0 rx mr1}
\end{sphinxVerbatim}

If you are reached to the end of arguments, no candidate keyword is displayed.
It is a completed statement of \sphinxcode{\sphinxupquote{component}} command, and TAB
completion does not work after \sphinxcode{\sphinxupquote{mirror}} because it is ready to run.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror 1; component start mr1 5 mirror}
\PYG{g+go}{Succeeded to start component \PYGZsq{}mr1\PYGZsq{} on core:5}
\end{sphinxVerbatim}

It is also completed secondary IDs of \sphinxcode{\sphinxupquote{spp\_mirror}} and it is helpful if you run
several \sphinxcode{\sphinxupquote{spp\_mirror}} processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror  \PYGZsh{} press TAB after space following \PYGZsq{}mirror\PYGZsq{}}
\PYG{g+go}{1;  3;    \PYGZsh{} you find two spp\PYGZus{}mirror processes of sec ID 1, 3}
\end{sphinxVerbatim}

By the way, it is also a case of no candidate keyword is displayed if your
command statement is wrong. You might be encountered an error if you run the
wrong command. Please take care.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror 1; compa  \PYGZsh{} no candidate shown for wrong command}
\PYG{g+go}{Invalid command \PYGZdq{}compa\PYGZdq{}.}
\end{sphinxVerbatim}


\subsubsection{status}
\label{\detokenize{commands/secondary/spp_mirror:status}}\label{\detokenize{commands/secondary/spp_mirror:commands-spp-mirror-status}}
Show the information of worker threads and its resources. Status information
consists of three parts.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror 1; status}
\PYG{g+go}{Basic Information:}
\PYG{g+go}{  \PYGZhy{} client\PYGZhy{}id: 3}
\PYG{g+go}{  \PYGZhy{} ports: [phy:0, phy:1, ring:0, ring:1, ring:2, ring:3, ring:4]}
\PYG{g+go}{ \PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{   \PYGZhy{} master: 1}
\PYG{g+go}{   \PYGZhy{} slaves: [2, 3, 4]}
\PYG{g+go}{Components:}
\PYG{g+go}{  \PYGZhy{} core:5 \PYGZsq{}mr1\PYGZsq{} (type: mirror)}
\PYG{g+go}{    \PYGZhy{} rx: ring:0}
\PYG{g+go}{    \PYGZhy{} tx: [ring:1, ring:2]}
\PYG{g+go}{  \PYGZhy{} core:6 \PYGZsq{}mr2\PYGZsq{} (type: mirror)}
\PYG{g+go}{    \PYGZhy{} rx: ring:3}
\PYG{g+go}{    \PYGZhy{} tx: [ring:4, ring:5]}
\PYG{g+go}{  \PYGZhy{} core:7 \PYGZsq{}\PYGZsq{} (type: unuse)}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{Basic Information}} is for describing attributes of \sphinxcode{\sphinxupquote{spp\_mirror}} itself.
\sphinxcode{\sphinxupquote{client-id}} is a secondary ID of the process and \sphinxcode{\sphinxupquote{ports}} is a list of
all of ports owned the process.

\sphinxcode{\sphinxupquote{Components}} is a list of all of worker threads. Each of workers has a
core ID running on, type of the worker and a list of resources.
Entry of no name with \sphinxcode{\sphinxupquote{unuse}} type means that no worker thread assigned to
the core. In other words, it is ready to be assinged.


\subsubsection{component}
\label{\detokenize{commands/secondary/spp_mirror:component}}\label{\detokenize{commands/secondary/spp_mirror:commands-spp-mirror-component}}
Assing or release a role of forwarding to worker threads running on each of
cores which are reserved with \sphinxcode{\sphinxupquote{-c}} or \sphinxcode{\sphinxupquote{-l}} option while launching
\sphinxcode{\sphinxupquote{spp\_mirror}}. Unlike \sphinxcode{\sphinxupquote{spp\_vf}}, \sphinxcode{\sphinxupquote{spp\_mirror}} only has one role, \sphinxcode{\sphinxupquote{mirror}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} assign \PYG{l+s+s1}{\PYGZsq{}ROLE\PYGZsq{}} to worker on \PYG{l+s+s1}{\PYGZsq{}CORE\PYGZus{}ID\PYGZsq{}} with a \PYG{l+s+s1}{\PYGZsq{}NAME\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} mirror SEC\PYGZus{}ID; component start NAME CORE\PYGZus{}ID ROLE}

\PYG{g+gp}{\PYGZsh{}} release worker \PYG{l+s+s1}{\PYGZsq{}NAME\PYGZsq{}} from the role
\PYG{g+go}{spp \PYGZgt{} mirror SEC\PYGZus{}ID; component stop NAME}
\end{sphinxVerbatim}

Here is an example of assigning role with \sphinxcode{\sphinxupquote{component}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} assign \PYG{l+s+s1}{\PYGZsq{}mirror\PYGZsq{}} role with name \PYG{l+s+s1}{\PYGZsq{}mr1\PYGZsq{}} on core \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} mirror 2; component start mr1 2 mirror}
\end{sphinxVerbatim}

And an examples of releasing role.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} release mirror role
\PYG{g+go}{spp \PYGZgt{} mirror 2; component stop mr1}
\end{sphinxVerbatim}


\subsubsection{port}
\label{\detokenize{commands/secondary/spp_mirror:port}}\label{\detokenize{commands/secondary/spp_mirror:commands-spp-mirror-port}}
Add or delete a port to a worker.


\paragraph{Adding port}
\label{\detokenize{commands/secondary/spp_mirror:adding-port}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror SEC\PYGZus{}ID; port add RES\PYGZus{}UID DIR NAME}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{RES\_UID}} is with replaced with resource UID such as \sphinxcode{\sphinxupquote{ring:0}} or
\sphinxcode{\sphinxupquote{vhost:1}}. \sphinxcode{\sphinxupquote{spp\_mirror}} supports three types of port.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{phy}} : Physical NIC

\item {} 
\sphinxcode{\sphinxupquote{ring}} : Ring PMD

\item {} 
\sphinxcode{\sphinxupquote{vhost}} : Vhost PMD

\end{itemize}

\sphinxcode{\sphinxupquote{DIR}} means the direction of forwarding and it should be \sphinxcode{\sphinxupquote{rx}} or \sphinxcode{\sphinxupquote{tx}}.
\sphinxcode{\sphinxupquote{NAME}} is the same as for \sphinxcode{\sphinxupquote{component}} command.

This is an example for adding ports to \sphinxcode{\sphinxupquote{mr1}}. In this case, it is configured
to receive packets from \sphinxcode{\sphinxupquote{ring:0}} and send it to \sphinxcode{\sphinxupquote{vhost:0}} and \sphinxcode{\sphinxupquote{vhost:1}}
by duplicating the packets.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} recieve from \PYG{l+s+s1}{\PYGZsq{}phy:0\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} mirror 2; port add ring:0 rx mr1}

\PYG{g+gp}{\PYGZsh{}} send to \PYG{l+s+s1}{\PYGZsq{}ring:0\PYGZsq{}} and \PYG{l+s+s1}{\PYGZsq{}ring:1\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} mirror 2; port add vhost:0 tx mr1}
\PYG{g+go}{spp \PYGZgt{} mirror 2; port add vhost:1 tx mr1}
\end{sphinxVerbatim}

Adding port may cause component to start packet forwarding. Please see
details in
{\hyperref[\detokenize{design/spp_secondary:spp-design-spp-sec-mirror}]{\sphinxcrossref{\DUrole{std,std-ref}{design spp\_mirror}}}}.

Until one rx and two tx ports are registered, \sphinxcode{\sphinxupquote{spp\_mirror}} does not start
forwarding. If it is requested to add more than one rx and two tx ports, it
replies an error message.


\paragraph{Deleting port}
\label{\detokenize{commands/secondary/spp_mirror:deleting-port}}
Delete a port which is not be used anymore. It is almost same as adding port.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror SEC\PYGZus{}ID; port del RES\PYGZus{}UID DIR NAME}
\end{sphinxVerbatim}

Here is some examples.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} delete rx port \PYG{l+s+s1}{\PYGZsq{}ring:0\PYGZsq{}} from \PYG{l+s+s1}{\PYGZsq{}mr1\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} mirror 2; port del ring:0 rx mr1}

\PYG{g+gp}{\PYGZsh{}} delete tx port \PYG{l+s+s1}{\PYGZsq{}vhost:1\PYGZsq{}} from \PYG{l+s+s1}{\PYGZsq{}mr1\PYGZsq{}}
\PYG{g+go}{spp \PYGZgt{} mirror 2; port del vhost:1 tx mr1}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Deleting port may cause component to stop packet forwarding.
Please see detail in {\hyperref[\detokenize{design/spp_secondary:spp-design-spp-sec-mirror}]{\sphinxcrossref{\DUrole{std,std-ref}{design spp\_mirror}}}}.
\end{sphinxadmonition}


\subsubsection{exit}
\label{\detokenize{commands/secondary/spp_mirror:exit}}
Terminate \sphinxcode{\sphinxupquote{spp\_mirror}} process.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} mirror 2; exit}
\end{sphinxVerbatim}


\subsection{spp\_pcap}
\label{\detokenize{commands/secondary/spp_pcap:spp-pcap}}\label{\detokenize{commands/secondary/spp_pcap:commands-spp-pcap}}\label{\detokenize{commands/secondary/spp_pcap::doc}}
\sphinxcode{\sphinxupquote{spp\_pcap}} is a kind of SPP secondary process. It it introduced for
providing packet capture features.

Each of \sphinxcode{\sphinxupquote{spp\_pcap}} processes is managed with \sphinxcode{\sphinxupquote{pcap}} command. It is for
sending sub commands with specific ID called secondary ID for starting or
stopping packet capture.

Secondary ID is referred as \sphinxcode{\sphinxupquote{-{-}client-id}} which is given as an argument
while launching \sphinxcode{\sphinxupquote{spp\_pcap}}. It should be unique among all of secondary
processes including \sphinxcode{\sphinxupquote{spp\_nfv}}, \sphinxcode{\sphinxupquote{spp\_vm}} and others.

\sphinxcode{\sphinxupquote{pcap}} command takes an secondary ID and one of sub commands. Secondary ID
and sub command should be separated with delimiter \sphinxcode{\sphinxupquote{;}}, or failed to a
command error.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap SEC\PYGZus{}ID; SUB\PYGZus{}CMD
\end{sphinxVerbatim}

In this example, \sphinxcode{\sphinxupquote{SEC\_ID}} is a secondary ID and \sphinxcode{\sphinxupquote{SUB\_CMD}} is one of the
following sub commands. Details of each of sub commands are described in the
next sections.
\begin{itemize}
\item {} 
status

\item {} 
start

\item {} 
stop

\item {} 
exit

\end{itemize}

\sphinxcode{\sphinxupquote{spp\_pcap}} supports TAB completion. You can complete all of the name
of commands and its arguments. For instance, you find all of sub commands
by pressing TAB after \sphinxcode{\sphinxupquote{pcap SEC\_ID;}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap 1;  \PYGZsh{} press TAB key
exit  start      status        stop
\end{sphinxVerbatim}

It tries to complete all of possible arguments.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap 1; component st  \PYGZsh{} press TAB key to show args starting \PYGZsq{}st\PYGZsq{}
start  status  stop
\end{sphinxVerbatim}

If you are reached to the end of arguments, no candidate keyword is displayed.
It is a completed statement of \sphinxcode{\sphinxupquote{start}} command, and TAB
completion does not work after \sphinxcode{\sphinxupquote{start}} because it is ready to run.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap 1; start
Succeeded to start capture
\end{sphinxVerbatim}

It is also completed secondary IDs of \sphinxcode{\sphinxupquote{spp\_pcap}} and it is helpful if you
run several \sphinxcode{\sphinxupquote{spp\_pcap}} processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap  \PYGZsh{} press TAB after space following \PYGZsq{}pcap\PYGZsq{}
1;  3;    \PYGZsh{} you find two spp\PYGZus{}pcap processes of sec ID 1, 3
\end{sphinxVerbatim}

By the way, it is also a case of no candidate keyword is displayed if your
command statement is wrong. You might be encountered an error if you run the
wrong command. Please take care.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap 1; ste  \PYGZsh{} no candidate shown for wrong command
Invalid command \PYGZdq{}ste\PYGZdq{}.
\end{sphinxVerbatim}


\subsubsection{status}
\label{\detokenize{commands/secondary/spp_pcap:status}}\label{\detokenize{commands/secondary/spp_pcap:commands-spp-pcap-status}}
Show the information of worker threads of \sphinxcode{\sphinxupquote{receiver}} and \sphinxcode{\sphinxupquote{writer}} threads
and its resources.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap 1; status
Basic Information:
  \PYGZhy{} client\PYGZhy{}id: 1
  \PYGZhy{} status: idling
  \PYGZhy{} lcore\PYGZus{}ids:
    \PYGZhy{} master: 1
    \PYGZhy{} slaves: [2, 3, 4, 5, 6]
Components:
  \PYGZhy{} core:2 receive
    \PYGZhy{} rx: phy:0
  \PYGZhy{} core:3 write
    \PYGZhy{} filename:
  \PYGZhy{} core:4 write
    \PYGZhy{} filename:
  \PYGZhy{} core:5 write
    \PYGZhy{} filename:
  \PYGZhy{} core:6 write
    \PYGZhy{} filename:
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{client-id}} is a secondary ID of the process and \sphinxcode{\sphinxupquote{status}} shows
running status.

Each of lcore has a role of \sphinxcode{\sphinxupquote{receive}} or \sphinxcode{\sphinxupquote{write}}.
\sphinxcode{\sphinxupquote{receiver}} has capture port as input and \sphinxcode{\sphinxupquote{write}} has a capture file
as output, but the \sphinxcode{\sphinxupquote{filename}} is empty while \sphinxcode{\sphinxupquote{idling}} status
because capturing is not started yet.

If you start capturing, you can find each of \sphinxcode{\sphinxupquote{writer}} threads has a
capture file. After capturing is stopped, \sphinxcode{\sphinxupquote{filename}} is returned to
be empty again.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap 2; status
  \PYGZhy{} client\PYGZhy{}id: 2
  \PYGZhy{} status: running
  \PYGZhy{} core:2 receive
    \PYGZhy{} rx: phy:0
  \PYGZhy{} core:3 write
    \PYGZhy{} filename: /tmp/spp\PYGZus{}pcap.20190214161550.phy0.1.1.pcap.lz4
  \PYGZhy{} core:4 write
    \PYGZhy{} filename: /tmp/spp\PYGZus{}pcap.20190214161550.phy0.2.1.pcap.lz4
  \PYGZhy{} core:5 write
    \PYGZhy{} filename: /tmp/spp\PYGZus{}pcap.20190214161550.phy0.3.1.pcap.lz4
  \PYGZhy{} core:6 write
    \PYGZhy{} filename: /tmp/spp\PYGZus{}pcap.20190214161550.phy0.4.1.pcap.lz4
\end{sphinxVerbatim}


\subsubsection{start}
\label{\detokenize{commands/secondary/spp_pcap:start}}\label{\detokenize{commands/secondary/spp_pcap:commands-spp-pcap-start}}
Start packet capture.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} start capture
spp \PYGZgt{} pcap SEC\PYGZus{}ID; start
\end{sphinxVerbatim}

Here is a example of starting capture.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} start capture
spp \PYGZgt{} pcap 1; start
Start packet capture.
\end{sphinxVerbatim}


\subsubsection{stop}
\label{\detokenize{commands/secondary/spp_pcap:stop}}\label{\detokenize{commands/secondary/spp_pcap:commands-spp-pcap-stop}}
Stop packet capture.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} stop capture
spp \PYGZgt{} pcap SEC\PYGZus{}ID; stop
\end{sphinxVerbatim}

Here is a example of stopping capture.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} stop capture
spp \PYGZgt{} pcap 2; stop
Start packet capture.
\end{sphinxVerbatim}


\subsubsection{exit}
\label{\detokenize{commands/secondary/spp_pcap:exit}}\label{\detokenize{commands/secondary/spp_pcap:commands-spp-pcap-exit}}
Terminate the \sphinxcode{\sphinxupquote{spp\_pcap}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap 1; exit
\end{sphinxVerbatim}


\section{Common Commands}
\label{\detokenize{commands/common:common-commands}}\label{\detokenize{commands/common:commands-common}}\label{\detokenize{commands/common::doc}}

\subsection{status}
\label{\detokenize{commands/common:status}}\label{\detokenize{commands/common:commands-common-status}}
Show the status of SPP processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} status}
\PYG{g+go}{\PYGZhy{} spp\PYGZhy{}ctl:}
\PYG{g+go}{  \PYGZhy{} address: 172.30.202.151:7777}
\PYG{g+go}{\PYGZhy{} primary:}
\PYG{g+go}{  \PYGZhy{} status: running}
\PYG{g+go}{\PYGZhy{} secondary:}
\PYG{g+go}{  \PYGZhy{} processes:}
\PYG{g+go}{    1: nfv:1}
\PYG{g+go}{    2: vf:3}
\end{sphinxVerbatim}


\subsection{config}
\label{\detokenize{commands/common:config}}\label{\detokenize{commands/common:commands-common-config}}
Show or update config params.

Config params used for changing behaviour of SPP CLI. For instance, if you
change command prompt, you can set any of prompt with \sphinxcode{\sphinxupquote{config}} command
other than default \sphinxcode{\sphinxupquote{spp \textgreater{}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} set prompt to \PYGZdq{}\PYGZdl{} spp \PYGZdq{}
spp \PYGZgt{} config prompt \PYGZdq{}\PYGZdl{} spp \PYGZdq{}
Set prompt: \PYGZdq{}\PYGZdl{} spp \PYGZdq{}
\PYGZdl{} spp
\end{sphinxVerbatim}


\subsubsection{Show Config}
\label{\detokenize{commands/common:show-config}}
To show the list of config all of params, simply run \sphinxcode{\sphinxupquote{config}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} show list of config
spp \PYGZgt{} config
\PYGZhy{} max\PYGZus{}secondary: \PYGZdq{}16\PYGZdq{}       \PYGZsh{} The maximum number of secondary processes
\PYGZhy{} sec\PYGZus{}nfv\PYGZus{}nof\PYGZus{}lcores: \PYGZdq{}1\PYGZdq{}   \PYGZsh{} Default num of lcores for workers of spp\PYGZus{}nfv
\PYGZhy{} topo\PYGZus{}size: \PYGZdq{}60\PYGZpc{}\PYGZdq{}  \PYGZsh{} Percentage or ratio of topo
\PYGZhy{} sec\PYGZus{}base\PYGZus{}lcore: \PYGZdq{}1\PYGZdq{}       \PYGZsh{} Shared lcore among secondaries
....
\end{sphinxVerbatim}

Or show params only started from \sphinxcode{\sphinxupquote{sec\_}}, add the keyword to the commnad.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} show config started from {}`sec\PYGZus{}{}`
spp \PYGZgt{} config sec\PYGZus{}
\PYGZhy{} sec\PYGZus{}vhost\PYGZus{}cli: \PYGZdq{}\PYGZdq{} \PYGZsh{} Vhost client mode, activated if set any of values
\PYGZhy{} sec\PYGZus{}mem: \PYGZdq{}\PYGZhy{}m 512\PYGZdq{} \PYGZsh{} Mem size
\PYGZhy{} sec\PYGZus{}nfv\PYGZus{}nof\PYGZus{}lcores: \PYGZdq{}1\PYGZdq{}   \PYGZsh{} Default num of lcores for workers of spp\PYGZus{}nfv
\PYGZhy{} sec\PYGZus{}base\PYGZus{}lcore: \PYGZdq{}1\PYGZdq{}       \PYGZsh{} Shared lcore among secondaryes
....
\end{sphinxVerbatim}


\subsubsection{Set Config}
\label{\detokenize{commands/common:set-config}}
One of typical uses of \sphinxcode{\sphinxupquote{config}} command is to change the default params of
other commands. \sphinxcode{\sphinxupquote{pri; launch}} takes several options for launching secondary
process and it is completed by using default params started from \sphinxcode{\sphinxupquote{sec\_}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pri; launch nfv 2  \PYGZsh{} press TAB for completion
spp \PYGZgt{} pri; launch nfv 2 \PYGZhy{}l 1,2 \PYGZhy{}m 512 \PYGZhy{}\PYGZhy{} \PYGZhy{}n 2 \PYGZhy{}s 192.168.11.59:6666
\end{sphinxVerbatim}

The default number of memory size is \sphinxcode{\sphinxupquote{-m 512}} and the definition
\sphinxcode{\sphinxupquote{sec\_mem}} can be changed with \sphinxcode{\sphinxupquote{config}} command.
Here is an example of changing \sphinxcode{\sphinxupquote{-m 512}} to \sphinxcode{\sphinxupquote{-{-}socket-mem 512,0}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} config sec\PYGZus{}mem \PYGZdq{}\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem 512,0\PYGZdq{}
Set sec\PYGZus{}mem: \PYGZdq{}\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem 512,0\PYGZdq{}
\end{sphinxVerbatim}

After updating the param, expanded options is also updated.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pri; launch nfv 2  \PYGZsh{} press TAB for completion
spp \PYGZgt{} pri; launch nfv 2 \PYGZhy{}l 1,2 \PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem 512,0 \PYGZhy{}\PYGZhy{} \PYGZhy{}n 2 \PYGZhy{}s ...
\end{sphinxVerbatim}


\subsection{playback}
\label{\detokenize{commands/common:playback}}\label{\detokenize{commands/common:commands-common-playback}}
Restore network configuration from a recipe file which defines a set
of SPP commands.
You can prepare a recipe file by using \sphinxcode{\sphinxupquote{record}} command or editing
file by hand.

It is recommended to use extension \sphinxcode{\sphinxupquote{.rcp}} to be self-sxplanatory as
a recipe, although you can use any of extensions such as \sphinxcode{\sphinxupquote{.txt}} or
\sphinxcode{\sphinxupquote{.log}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} playback /path/to/my.rcp}
\end{sphinxVerbatim}


\subsection{record}
\label{\detokenize{commands/common:record}}\label{\detokenize{commands/common:commands-common-record}}
Start recording user’s input and create a recipe file for loading
from \sphinxcode{\sphinxupquote{playback}} commnad.
Recording recipe is stopped by executing \sphinxcode{\sphinxupquote{exit}} or \sphinxcode{\sphinxupquote{playback}}
command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} record /path/to/my.rcp}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
It is not supported to stop recording without \sphinxcode{\sphinxupquote{exit}} or \sphinxcode{\sphinxupquote{playback}}
command.
It is planned to support \sphinxcode{\sphinxupquote{stop}} command for stopping record in
next relase.
\end{sphinxadmonition}


\subsection{history}
\label{\detokenize{commands/common:history}}\label{\detokenize{commands/common:commands-common-history}}
Show command history. Command history is recorded in a file named
\sphinxcode{\sphinxupquote{\$HOME/.spp\_history}}. It does not add some command which are no
meaning for history, \sphinxcode{\sphinxupquote{bye}}, \sphinxcode{\sphinxupquote{exit}}, \sphinxcode{\sphinxupquote{history}} and \sphinxcode{\sphinxupquote{redo}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} history}
\PYG{g+go}{  1  ls}
\PYG{g+go}{  2  cat file.txt}
\end{sphinxVerbatim}


\subsection{redo}
\label{\detokenize{commands/common:redo}}\label{\detokenize{commands/common:commands-common-redo}}
Execute command of index of history.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} redo 5  \PYGZsh{} exec 5th command in the history}
\end{sphinxVerbatim}


\subsection{server}
\label{\detokenize{commands/common:server}}\label{\detokenize{commands/common:commands-common-server}}
Switch SPP REST API server.

SPP CLI is able to manage several SPP nodes via REST API servers.
It is also abaivable to register new one, or unregister.

Show all of registered servers by running \sphinxcode{\sphinxupquote{server list}} or simply
\sphinxcode{\sphinxupquote{server}}. Notice that \sphinxcode{\sphinxupquote{*}} means that the first node is under the
control of SPP CLI.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} server}
\PYG{g+go}{  1: 192.168.1.101:7777 *}
\PYG{g+go}{  2: 192.168.1.102:7777}

\PYG{g+go}{spp \PYGZgt{} server list  \PYGZsh{} same as above}
\PYG{g+go}{  1: 192.168.1.101:7777 *}
\PYG{g+go}{  2: 192.168.1.102:7777}
\end{sphinxVerbatim}

Switch to other server by running \sphinxcode{\sphinxupquote{server}} with index or address displayed
in the list. Port number can be omitted if it is default \sphinxcode{\sphinxupquote{7777}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Switch to the second node
\PYG{g+go}{spp \PYGZgt{} server 2}
\PYG{g+go}{Switch spp\PYGZhy{}ctl to \PYGZdq{}2: 192.168.1.102:7777\PYGZdq{}.}

\PYG{g+gp}{\PYGZsh{}} Switch to firt one again with address
\PYG{g+go}{spp \PYGZgt{} server 192.168.1.101  \PYGZsh{} no need for port num}
\PYG{g+go}{Switch spp\PYGZhy{}ctl to \PYGZdq{}1: 192.168.1.101:7777\PYGZdq{}.}
\end{sphinxVerbatim}

Register new one by using \sphinxcode{\sphinxupquote{add}} command, or unregister by \sphinxcode{\sphinxupquote{del}} command
with address. For unregistering, node is also specified with index.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Register
\PYG{g+go}{spp \PYGZgt{} server add 192.168.122.177}
\PYG{g+go}{Registered spp\PYGZhy{}ctl \PYGZdq{}192.168.122.177:7777\PYGZdq{}.}

\PYG{g+gp}{\PYGZsh{}} Unregister second one
\PYG{g+go}{spp \PYGZgt{} server del 2  \PYGZsh{} or 192.168.1.102}
\PYG{g+go}{Unregistered spp\PYGZhy{}ctl \PYGZdq{}192.168.1.102:7777\PYGZdq{}.}
\end{sphinxVerbatim}

You cannot unregister node under the control, or switch to other one before.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} server del 1}
\PYG{g+go}{Cannot del server \PYGZdq{}1\PYGZdq{} in use!}
\end{sphinxVerbatim}


\subsection{env}
\label{\detokenize{commands/common:env}}\label{\detokenize{commands/common:commands-common-env}}
Show environmental variables. It is mainly used to find variables related to
SPP.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} show all env varibles.
\PYG{g+go}{spp \PYGZgt{} env}

\PYG{g+gp}{\PYGZsh{}} show env varibles starts with \PYG{l+s+sb}{{}`}SPP\PYG{l+s+sb}{{}`}.
\PYG{g+go}{spp \PYGZgt{} env SPP}
\end{sphinxVerbatim}


\subsection{pwd}
\label{\detokenize{commands/common:pwd}}\label{\detokenize{commands/common:commands-common-pwd}}
Show current path.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp\PYGZgt{} pwd}
\PYG{g+go}{/path/to/curdir}
\end{sphinxVerbatim}


\subsection{cd}
\label{\detokenize{commands/common:cd}}\label{\detokenize{commands/common:commands-common-cd}}
Change current directory.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp\PYGZgt{} cd /path/to/dir}
\end{sphinxVerbatim}


\subsection{ls}
\label{\detokenize{commands/common:ls}}\label{\detokenize{commands/common:commands-common-ls}}
Show a list of directory contents.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp\PYGZgt{} ls /path/to/dir}
\end{sphinxVerbatim}


\subsection{mkdir}
\label{\detokenize{commands/common:mkdir}}\label{\detokenize{commands/common:commands-common-mkdir}}
Make a directory.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp\PYGZgt{} mkdir /path/to/dir}
\end{sphinxVerbatim}


\subsection{cat}
\label{\detokenize{commands/common:cat}}\label{\detokenize{commands/common:commands-common-cat}}
Show contents of a file.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp\PYGZgt{} cat /path/to/file}
\end{sphinxVerbatim}


\subsection{less}
\label{\detokenize{commands/common:less}}\label{\detokenize{commands/common:commands-common-less}}
Show contents of a file.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp\PYGZgt{} less /path/to/file}
\end{sphinxVerbatim}


\subsection{bye}
\label{\detokenize{commands/common:bye}}\label{\detokenize{commands/common:commands-common-bye}}
\sphinxcode{\sphinxupquote{bye}} command is for terminating SPP processes.
It supports two types of termination as sub commands.
\begin{itemize}
\item {} 
sec

\item {} 
all

\end{itemize}

First one is for terminating only secondary processes at once.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} bye sec}
\PYG{g+go}{Closing secondary ...}
\PYG{g+go}{Exit nfv 1}
\PYG{g+go}{Exit vf 3.}
\end{sphinxVerbatim}

Second one is for all SPP processes other than controller.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} bye all}
\PYG{g+go}{Closing secondary ...}
\PYG{g+go}{Exit nfv 1}
\PYG{g+go}{Exit vf 3.}
\PYG{g+go}{Closing primary ...}
\PYG{g+go}{Exit primary}
\end{sphinxVerbatim}


\subsection{exit}
\label{\detokenize{commands/common:exit}}\label{\detokenize{commands/common:commands-common-exit}}
Same as \sphinxcode{\sphinxupquote{bye}} command but just for terminating SPP controller and
not for other processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} exit}
\PYG{g+go}{Thank you for using Soft Patch Panel}
\end{sphinxVerbatim}


\subsection{help}
\label{\detokenize{commands/common:help}}\label{\detokenize{commands/common:commands-common-help}}
Show help message for SPP commands.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} help}

\PYG{g+go}{Documented commands (type help \PYGZlt{}topic\PYGZgt{}):}
\PYG{g+go}{========================================}
\PYG{g+go}{bye  exit     inspect   ls      nfv       pwd     server  topo\PYGZus{}resize}
\PYG{g+go}{cat  help     less      mirror  playback  record  status  topo\PYGZus{}subgraph}
\PYG{g+go}{cd   history  load\PYGZus{}cmd  mkdir   pri       redo    topo    vf}

\PYG{g+go}{spp \PYGZgt{} help status}
\PYG{g+go}{Display status info of SPP processes}

\PYG{g+go}{    spp \PYGZgt{} status}

\PYG{g+go}{spp \PYGZgt{} help nfv}
\PYG{g+go}{Send a command to spp\PYGZus{}nfv specified with ID.}

\PYG{g+go}{    Spp\PYGZus{}nfv is specified with secondary ID and takes sub commands.}

\PYG{g+go}{    spp \PYGZgt{} nfv 1; status}
\PYG{g+go}{    spp \PYGZgt{} nfv 1; add ring:0}
\PYG{g+go}{    spp \PYGZgt{} nfv 1; patch phy:0 ring:0}

\PYG{g+go}{    You can refer all of sub commands by pressing TAB after}
\PYG{g+go}{    \PYGZsq{}nfv 1;\PYGZsq{}.}

\PYG{g+go}{    spp \PYGZgt{} nfv 1;  \PYGZsh{} press TAB}
\PYG{g+go}{    add     del     exit    forward patch   status  stop}
\end{sphinxVerbatim}


\section{Experimental Commands}
\label{\detokenize{commands/experimental:experimental-commands}}\label{\detokenize{commands/experimental:commands-experimental}}\label{\detokenize{commands/experimental::doc}}
There are experimental commands in SPP controller.
It might not work for some cases properly because it is not well tested
currently.


\subsection{topo}
\label{\detokenize{commands/experimental:topo}}\label{\detokenize{commands/experimental:commands-experimental-topo}}
Output network topology in several formats.
Support four types of output.
\begin{itemize}
\item {} 
Terminal

\item {} 
Browser (websocket server is required)

\item {} 
Text (dot, json, yaml)

\item {} 
Image file (jpg, png, bmp)

\end{itemize}

This command uses \sphinxhref{https://www.graphviz.org/}{graphviz}
for generating topology file.
You can also generate a dot formatted file or image files supported by
graphviz.

Here is an example for installing required tools for \sphinxcode{\sphinxupquote{topo term}} command
to output in a terminal.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo apt install graphviz \PYG{l+s+se}{\PYGZbs{}}
  imagemagick \PYG{l+s+se}{\PYGZbs{}}
  libsixel\PYGZhy{}bin
\end{sphinxVerbatim}

MacOS is also supported optionally for using topo runs on a remote host.
In this case, iTerm2 and imgcat are required as described in the next
section.

To output in browser with \sphinxcode{\sphinxupquote{topo http}} command, install required packages
by using \sphinxcode{\sphinxupquote{requirements.txt}} as described in
{\hyperref[\detokenize{gsg/install:setup-install-spp}]{\sphinxcrossref{\DUrole{std,std-ref}{install SPP}}}}, or only for them as follwoing.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} pip3 install tornado \PYG{l+s+se}{\PYGZbs{}}
  websocket\PYGZhy{}client
\end{sphinxVerbatim}


\subsubsection{Output to Terminal}
\label{\detokenize{commands/experimental:output-to-terminal}}
Output an image of network configuration in terminal.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} topo term}
\end{sphinxVerbatim}

There are few terminal applications supporting to output image with \sphinxcode{\sphinxupquote{topo}}.
You can use mlterm, xterm or other terminals supported by \sphinxhref{https://github.com/saitoha/libsixel}{img2sixel}.
You can also use \sphinxhref{https://iterm2.com/index.html}{iTerm2} on MacOS.
If you use iTerm2, you need to downloada a shell script
\sphinxcode{\sphinxupquote{imgcat}} from \sphinxhref{https://iterm2.com/documentation-images.html}{iTerm2’s displaying support site}
and save this script as
\sphinxcode{\sphinxupquote{src/controller/3rd\_party/imgcat}} with permission \sphinxcode{\sphinxupquote{775}}.
\sphinxcode{\sphinxupquote{topo}} command tries to \sphinxcode{\sphinxupquote{img2sixel}} first, then \sphinxcode{\sphinxupquote{imgcat}}
in the \sphinxcode{\sphinxupquote{3rd\_party}} directory.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.670\linewidth]{{topo_term_exp}.pdf}
\caption{topo term example}\label{\detokenize{commands/experimental:id1}}\label{\detokenize{commands/experimental:figure-topo-term-exp}}\end{figure}


\subsubsection{Output to Browser}
\label{\detokenize{commands/experimental:output-to-browser}}
Output an image of network configuration in browser.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} topo http}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{topo term}} is useful to understand network configuration intuitively.
However, it should be executed on a node running SPP controller.
You cannnot see the image if you login remote node via ssh and running
SPP controller on remote.

Websocket server is launched from \sphinxcode{\sphinxupquote{src/controller/websocket/spp\_ws.py}}
to accept client messages.
You should start it before using \sphinxcode{\sphinxupquote{topo term}} command.
Then, open url shown in the terminal (default is
\sphinxcode{\sphinxupquote{http://127.0.0.1:8989}}).

Browser and SPP controller behave as clients, but have different roles.
Browser behaves as a viwer and SPP controller behaves as a udpater.
If you update network configuration and run \sphinxcode{\sphinxupquote{topo http}} command,
SPP controller sends a message containing network configuration
as DOT language format.
Once the message is accepted, websocket server sends it to viewer clients
immediately.


\subsubsection{Output to File}
\label{\detokenize{commands/experimental:output-to-file}}
Output a text or image of network configuration to a file.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} topo [FILE\PYGZus{}NAME] [FILE\PYGZus{}TYPE]}
\end{sphinxVerbatim}

You do not need to specify \sphinxcode{\sphinxupquote{FILE\_TYPE}} because \sphinxcode{\sphinxupquote{topo}} is able to
decide file type from \sphinxcode{\sphinxupquote{FILE\_NAME}}. It is optional.
This is a list of supported file type.
\begin{itemize}
\item {} 
dot

\item {} 
js (or json)

\item {} 
yml (or yaml)

\item {} 
jpg

\item {} 
png

\item {} 
bmp

\end{itemize}

To generate a DOT file \sphinxcode{\sphinxupquote{network.dot}}, run \sphinxcode{\sphinxupquote{topo}} command with
file name.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} generate DOT file
\PYG{g+go}{spp \PYGZgt{} topo network.dot}
\PYG{g+go}{Create topology: \PYGZsq{}network.dot\PYGZsq{}}
\PYG{g+gp}{\PYGZsh{}} show contents of the file
\PYG{g+go}{spp \PYGZgt{} cat network.dot}
\PYG{g+go}{digraph spp\PYGZob{}}
\PYG{g+go}{newrank=true;}
\PYG{g+go}{node[shape=\PYGZdq{}rectangle\PYGZdq{}, style=\PYGZdq{}filled\PYGZdq{}];}
\PYG{g+go}{...}
\end{sphinxVerbatim}

To generate a jpg image, run \sphinxcode{\sphinxupquote{topo}} with the name \sphinxcode{\sphinxupquote{network.jpg}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} topo network.jpg}
\PYG{g+go}{spp \PYGZgt{} ls}
\PYG{g+go}{...  network.jpg  ...}
\end{sphinxVerbatim}


\subsection{topo\_subgraph}
\label{\detokenize{commands/experimental:topo-subgraph}}\label{\detokenize{commands/experimental:commands-experimental-topo-subgraph}}
\sphinxcode{\sphinxupquote{topo\_subgraph}} is a supplemental command for managing subgraphs
for \sphinxcode{\sphinxupquote{topo}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} topo\PYGZus{}subgraph VERB LABEL RES\PYGZus{}ID1,RES\PYGZus{}ID2,...}
\end{sphinxVerbatim}

Each of options are:
\begin{itemize}
\item {} 
VERB: \sphinxcode{\sphinxupquote{add}} or \sphinxcode{\sphinxupquote{del}}

\item {} 
LABEL: Arbitrary text, such as \sphinxcode{\sphinxupquote{guest\_vm1}} or \sphinxcode{\sphinxupquote{container1}}

\item {} 
RES\_ID: Series of Resource ID consists of type and ID such as
\sphinxcode{\sphinxupquote{vhost:1}}. Each of resource IDs are separated with \sphinxcode{\sphinxupquote{,}} or
\sphinxcode{\sphinxupquote{;}}.

\end{itemize}

Subgraph is a group of object defined in dot language. Grouping objects
helps your understanding relationship or hierarchy of each of objects.
It is used for grouping resources on VM or container to be more
understandable.

For example, if you create two vhost interfaces for a guest VM and patch
them to physical ports, \sphinxcode{\sphinxupquote{topo term}} shows a network configuration as
following.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.670\linewidth]{{topo_subg_before}.pdf}
\caption{Before using topo\_subgraph}\label{\detokenize{commands/experimental:id2}}\label{\detokenize{commands/experimental:figure-topo-subg-before}}\end{figure}

Two of vhost interfaces are placed outside of \sphinxcode{\sphinxupquote{Host}} while the guest
VM runs on \sphinxcode{\sphinxupquote{Host}}.
However, \sphinxcode{\sphinxupquote{vhost:1}} and \sphinxcode{\sphinxupquote{vhost:2}} should be placed inside \sphinxcode{\sphinxupquote{Host}}
actually. It is required to use subgraph!

To include guest VM and its resources inside the \sphinxcode{\sphinxupquote{Host}},
use \sphinxcode{\sphinxupquote{topo\_subgraph}} with options.
In this case, add subgraph \sphinxcode{\sphinxupquote{guest\_vm}} and includes resoures
\sphinxcode{\sphinxupquote{vhost:1}} and \sphinxcode{\sphinxupquote{vhost:2}} into the subgraph.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} topo\PYGZus{}subgraph add guest\PYGZus{}vm vhost:1,vhost:2}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.670\linewidth]{{topo_subg_after}.pdf}
\caption{After using topo\_subgraph}\label{\detokenize{commands/experimental:id3}}\label{\detokenize{commands/experimental:figure-topo-subg-after}}\end{figure}

All of registered subgraphs are listed by using \sphinxcode{\sphinxupquote{topo\_subgraph}}
with no options.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} topo\PYGZus{}subgraph}
\PYG{g+go}{label: guest\PYGZus{}vm subgraph: \PYGZdq{}vhost:1,vhost:2\PYGZdq{}}
\end{sphinxVerbatim}

If guest VM is shut down and subgraph is not needed anymore,
delete subgraph \sphinxcode{\sphinxupquote{guest\_vm}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} topo\PYGZus{}subgraph del guest\PYGZus{}vm}
\end{sphinxVerbatim}


\subsection{load\_cmd}
\label{\detokenize{commands/experimental:load-cmd}}\label{\detokenize{commands/experimental:commands-experimental-load-cmd}}
Load command plugin dynamically while running SPP controller.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} load\PYGZus{}cmd [CMD\PYGZus{}NAME]}
\end{sphinxVerbatim}

CLI of SPP controller is implemented with \sphinxcode{\sphinxupquote{Shell}} class which is
derived from Python standard library \sphinxcode{\sphinxupquote{Cmd}}.
It means that subcommands of SPP controller must be implemented as
a member method named as \sphinxcode{\sphinxupquote{do\_xxx}}.
For instance, \sphinxcode{\sphinxupquote{status}} subcommand is implemented as \sphinxcode{\sphinxupquote{do\_status}}
method.

\sphinxcode{\sphinxupquote{load\_cmd}} is for providing a way to define user specific command
as a plugin.
Plugin file must be placed in \sphinxcode{\sphinxupquote{spp/src/controller/command}} and
command name must be the same as file name.
In addition, \sphinxcode{\sphinxupquote{do\_xxx}} method must be defined which is called from
SPP controller.

For example, \sphinxcode{\sphinxupquote{hello}} sample plugin is defined as
\sphinxcode{\sphinxupquote{spp/src/controller/command/hello.py}} and \sphinxcode{\sphinxupquote{do\_hello}} is defined
in this plugin.
Comment for \sphinxcode{\sphinxupquote{do\_hello}} is used as help message for \sphinxcode{\sphinxupquote{hello}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k}{def} \PYG{n+nf}{do\PYGZus{}hello}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Say hello to given user}

\PYG{l+s+sd}{    spp \PYGZgt{} hello alice}
\PYG{l+s+sd}{    Hello, alice!}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{if} \PYG{n}{name} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name is required!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{hl} \PYG{o}{=} \PYG{n}{Hello}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}
        \PYG{n}{hl}\PYG{o}{.}\PYG{n}{say}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{hello}} is loaded and called as following.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{spp \PYGZgt{} load\PYGZus{}cmd hello}
\PYG{g+go}{Module \PYGZsq{}command.hello\PYGZsq{} loaded.}
\PYG{g+go}{spp \PYGZgt{} hello alice}
\PYG{g+go}{Hello, alice!}
\end{sphinxVerbatim}


\chapter{Tools}
\label{\detokenize{tools/index:tools}}\label{\detokenize{tools/index:tools-index}}\label{\detokenize{tools/index::doc}}

\section{SPP Container}
\label{\detokenize{tools/sppc/index:spp-container}}\label{\detokenize{tools/sppc/index:spp-container-index}}\label{\detokenize{tools/sppc/index::doc}}
Running SPP and DPDK applications on containers.


\subsection{Overview}
\label{\detokenize{tools/sppc/overview:overview}}\label{\detokenize{tools/sppc/overview:spp-container-overview}}\label{\detokenize{tools/sppc/overview::doc}}
SPP container is a set of tools for running SPP and DPDK applications
with docker.
It consists of shell or python scripts
for building container images and launching app containers
with docker commands.

As shown in \hyperref[\detokenize{tools/sppc/overview:figure-sppc-overview}]{Fig.\@ \ref{\detokenize{tools/sppc/overview:figure-sppc-overview}}}, all of
DPDK applications, including SPP primary and secondary processes,
run inside containers.
SPP controller is just a python script and does not need to be run as
an app container.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{sppc_overview}.pdf}
\caption{SPP container overview}\label{\detokenize{tools/sppc/overview:id1}}\label{\detokenize{tools/sppc/overview:figure-sppc-overview}}\end{figure}


\subsection{Getting Started}
\label{\detokenize{tools/sppc/getting_started:getting-started}}\label{\detokenize{tools/sppc/getting_started:spp-container-gs}}\label{\detokenize{tools/sppc/getting_started::doc}}
In this section, learn how to use SPP container with a simple
usecase.
You use four of terminals for running SPP processes and applications.


\subsubsection{Setup DPDK and SPP}
\label{\detokenize{tools/sppc/getting_started:setup-dpdk-and-spp}}\label{\detokenize{tools/sppc/getting_started:sppc-gs-setup}}
First of all, you need to clone DPDK and setup hugepages for running
DPDK application as described in
{\hyperref[\detokenize{gsg/setup::doc}]{\sphinxcrossref{\DUrole{doc}{Setup}}}}
or DPDK’s
\sphinxhref{https://dpdk.org/doc/guides/linux\_gsg/sys\_reqs.html}{Gettting Started Guide}.
You also need to load kernel modules and bind network ports as in
\sphinxhref{https://dpdk.org/doc/guides/linux\_gsg/linux\_drivers.html}{Linux Drivers}.

Then, as described in
{\hyperref[\detokenize{gsg/install::doc}]{\sphinxcrossref{\DUrole{doc}{Install DPDK and SPP}}}}
, clone and compile SPP in any directory.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} git clone http://dpdk.org/git/apps/spp
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} spp
\end{sphinxVerbatim}


\subsubsection{Build Docker Images}
\label{\detokenize{tools/sppc/getting_started:build-docker-images}}\label{\detokenize{tools/sppc/getting_started:sppc-gs-build-docker-imgs}}
Build tool is a python script for creating a docker image and
currently supporting three types of images for
DPDK sample applications, pktgen-dpdk, or SPP.

Run build tool for creating three type of docker images.
It starts to download the latest Ubuntu docker image and installation
for the latest DPDK, pktgen or SPP.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t dpdk
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t pktgen
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t spp
\end{sphinxVerbatim}

Of course DPDK is required from pktgen and SPP, and it causes a
problem of compatibility between them sometimes.
In this case, you should build SPP with \sphinxcode{\sphinxupquote{-{-}dpdk-branch}} option to tell
the version of DPDK explicitly.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t spp \PYGZhy{}\PYGZhy{}dpdk\PYGZhy{}branch v19.11
\end{sphinxVerbatim}

You can find all of options by \sphinxcode{\sphinxupquote{build/main.py -h}}.

Waiting for a minutes, then you are ready to launch app containers.
All of images are referred from \sphinxcode{\sphinxupquote{docker images}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} docker images
\PYG{g+go}{REPOSITORY           TAG       IMAGE ID         CREATED         SIZE}
\PYG{g+go}{sppc/spp\PYGZhy{}ubuntu      latest    3ec39adb460f     2 days ago      862MB}
\PYG{g+go}{sppc/pktgen\PYGZhy{}ubuntu   latest    ffe65cc70e65     2 days ago      845MB}
\PYG{g+go}{sppc/dpdk\PYGZhy{}ubuntu     latest    0d5910d10e3f     2 days ago      1.66GB}
\PYG{g+go}{\PYGZlt{}none\PYGZgt{}               \PYGZlt{}none\PYGZgt{}    d52d2f86a3c0     2 days ago      551MB}
\PYG{g+go}{ubuntu               latest    452a96d81c30     5 weeks ago     79.6MB}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The Name of container image is defined as a set of target, name and
version of Linux distoribution.
For example, container image targetting dpdk apps on Ubuntu 18.04
is named as \sphinxcode{\sphinxupquote{sppc/dpdk-ubuntu:18.04}}.

There are several Dockerfiles for supporting several applications and
distro versions under \sphinxcode{\sphinxupquote{build/ubuntu/}}.
Build script understands which of Dockerfiles should be used based
on the given options.
If you run build script with options for dpdk and Ubuntu 18.04 as
below, it finds \sphinxcode{\sphinxupquote{build/ubuntu/dpdk/Dockerfile.18.04}} and runs
\sphinxcode{\sphinxupquote{docker build}}.
Options for Linux distribution have default value, \sphinxcode{\sphinxupquote{ubuntu}} and
\sphinxcode{\sphinxupquote{latest}}. So, you do not need to specify them if you use default.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} latest DPDK on latest Ubuntu
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t dpdk \PYGZhy{}\PYGZhy{}dist\PYGZhy{}name ubuntu \PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver latest

\PYG{g+gp}{\PYGZsh{}} it is also the same
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t dpdk

\PYG{g+gp}{\PYGZsh{}} or use Ubuntu \PYG{l+m}{18}.04
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t dpdk \PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver \PYG{l+m}{18}.04
\end{sphinxVerbatim}

Version of other than distro is also configurable by specifying a branch
number via command line options.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t dpdk \PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver \PYG{l+m}{18}.04 \PYGZhy{}\PYGZhy{}dpdk\PYGZhy{}branch v19.11
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t pktgen \PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver \PYG{l+m}{18}.04 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}dpdk\PYGZhy{}branch v18.02 \PYGZhy{}\PYGZhy{}pktgen\PYGZhy{}branch pktgen\PYGZhy{}3.4.9
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t spp \PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver \PYG{l+m}{18}.04 \PYGZhy{}\PYGZhy{}dpdk\PYGZhy{}branch v19.11
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Launch SPP and App Containers}
\label{\detokenize{tools/sppc/getting_started:launch-spp-and-app-containers}}\label{\detokenize{tools/sppc/getting_started:sppc-gs-launch-containers}}
\begin{sphinxadmonition}{note}{Note:}
In usecase described in this chapter, SPP processes other than
\sphinxcode{\sphinxupquote{spp-ctl}} and CLI are containerized, but it is available to run as on
host for communicating with other container applications.
\end{sphinxadmonition}

Before launch containers, you should set IP address of host machine as
\sphinxcode{\sphinxupquote{SPP\_CTL\_IP}} environment variable for controller to be accessed from
inside containers.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Set your host IP address
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{export} \PYG{n+nv}{SPP\PYGZus{}CTL\PYGZus{}IP}\PYG{o}{=}YOUR\PYGZus{}HOST\PYGZus{}IPADDR
\end{sphinxVerbatim}


\paragraph{SPP Controller}
\label{\detokenize{tools/sppc/getting_started:spp-controller}}
Launch \sphinxcode{\sphinxupquote{spp-ctl}} and \sphinxcode{\sphinxupquote{spp.py}} to be ready before primary and secondary
processes.

\begin{sphinxadmonition}{note}{Note:}
SPP controller also provides \sphinxcode{\sphinxupquote{topo term}} command for containers which
shows network topology in a terminal.

However, there are a few terminals supporing this feature.
\sphinxcode{\sphinxupquote{mlterm}} is the most useful and easy to customize.
Refer {\hyperref[\detokenize{commands/experimental::doc}]{\sphinxcrossref{\DUrole{doc}{Experimental Commands}}}} for \sphinxcode{\sphinxupquote{topo}} command.
\end{sphinxadmonition}

\sphinxcode{\sphinxupquote{spp-ctl}} is launched in the terminal 1.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{spp.py}} is launched in the terminal 2.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py
\end{sphinxVerbatim}


\paragraph{SPP Primary Container}
\label{\detokenize{tools/sppc/getting_started:spp-primary-container}}
As \sphinxcode{\sphinxupquote{SPP\_CTL\_IP}} is activated, it is able to run \sphinxcode{\sphinxupquote{app/spp-primary.py}}
with options. In this case, launch \sphinxcode{\sphinxupquote{spp\_primary}} in background mode using
one core and two physical ports in terminal 3.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary.py \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}p 0x03
\end{sphinxVerbatim}


\paragraph{SPP Secondary Container}
\label{\detokenize{tools/sppc/getting_started:spp-secondary-container}}
\sphinxcode{\sphinxupquote{spp\_nfv}} is only supported for running on container currently.

Launch \sphinxcode{\sphinxupquote{spp\_nfv}} in terminal 3 with options for secondary ID is
\sphinxcode{\sphinxupquote{1}} and core list is \sphinxcode{\sphinxupquote{1-2}} for using 2nd and 3rd cores.
It is also run in background mode.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{1} \PYGZhy{}l \PYG{l+m}{1}\PYGZhy{}2
\end{sphinxVerbatim}

If it is succeeded, container is running in background.
You can find it with \sphinxcode{\sphinxupquote{docker ps}} command.


\paragraph{App Container}
\label{\detokenize{tools/sppc/getting_started:app-container}}
Launch DPDK’s \sphinxcode{\sphinxupquote{testpmd}} as an example of app container.

Currently, most of app containers do not support ring PMD.
It means that you should create vhost PMDs from SPP controller
before launching the app container.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add vhost:1}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add vhost:2}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{spp\_nfv}} of ID 1 running inside container creates \sphinxcode{\sphinxupquote{vhost:1}} and
\sphinxcode{\sphinxupquote{vhost:2}}. So assign them to \sphinxcode{\sphinxupquote{testpmd}} with \sphinxcode{\sphinxupquote{-d}} option which is for
attaching vdevs as a comma separated list of resource UIDs in SPP.
\sphinxcode{\sphinxupquote{testpmd}} is launched in foreground mode with \sphinxcode{\sphinxupquote{-fg}} option in this case.

\begin{sphinxadmonition}{note}{Note:}
DPDK app container tries to own ports on host which are shared with host
and containers by default. It causes a confliction between SPP running on
host and containers and unexpected behavior.

To avoid this situation, it is required to use \sphinxcode{\sphinxupquote{-b}} or
\sphinxcode{\sphinxupquote{-{-}pci-blacklist}} EAL option to exclude ports on host. PCI address of
port can be inspected by using \sphinxcode{\sphinxupquote{dpdk-devbind.py -s}}.
\end{sphinxadmonition}

To exclude \sphinxcode{\sphinxupquote{testpmd}} container tries to own physical ports, you should
specify PCI addresses of the ports with \sphinxcode{\sphinxupquote{-b}} or \sphinxcode{\sphinxupquote{-{-}pci-blacklist}}.
You can find PCI addresses from \sphinxcode{\sphinxupquote{dpdk-devbind.py -s}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Check the status of the available devices.
\PYG{g+go}{dpdk\PYGZhy{}devbind \PYGZhy{}\PYGZhy{}status}
\PYG{g+go}{Network devices using DPDK\PYGZhy{}compatible driver}
\PYG{g+go}{============================================}
\PYG{g+go}{0000:0a:00.0 \PYGZsq{}82599ES 10\PYGZhy{}Gigabit\PYGZsq{} drv=igb\PYGZus{}uio unused=ixgbe}
\PYG{g+go}{0000:0a:00.1 \PYGZsq{}82599ES 10\PYGZhy{}Gigabit\PYGZsq{} drv=igb\PYGZus{}uio unused=ixgbe}

\PYG{g+go}{Network devices using kernel driver}
\PYG{g+go}{===================================}
\PYG{g+go}{...}
\end{sphinxVerbatim}

In this case, you should exclude \sphinxcode{\sphinxupquote{0000:0a:00.0}} and \sphinxcode{\sphinxupquote{0000:0a:00.1}}
with \sphinxcode{\sphinxupquote{-b}} option.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/testpmd.py \PYGZhy{}l \PYG{l+m}{3}\PYGZhy{}4 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d vhost:1,vhost:2 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}fg \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}b \PYG{l+m}{0000}:0a:00.0 \PYG{l+m}{0000}:0a:00.1
\PYG{g+go}{ sudo docker run \PYGZhy{}it \PYGZbs{}}
\PYG{g+go}{ ...}
\PYG{g+go}{ \PYGZhy{}b 0000:0a:00.0 \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}b 0000:0a:00.1 \PYGZbs{}}
\PYG{g+go}{ ...}
\end{sphinxVerbatim}


\subsubsection{Run Applications}
\label{\detokenize{tools/sppc/getting_started:run-applications}}\label{\detokenize{tools/sppc/getting_started:sppc-gs-run-apps}}
At the end of this getting started guide, configure network paths
as described in
\hyperref[\detokenize{tools/sppc/getting_started:figure-sppc-gsg-testpmd}]{Fig.\@ \ref{\detokenize{tools/sppc/getting_started:figure-sppc-gsg-testpmd}}}
and start forwarding from testpmd.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.580\linewidth]{{sppc_gsg_testpmd}.pdf}
\caption{SPP and testpmd on containers}\label{\detokenize{tools/sppc/getting_started:id1}}\label{\detokenize{tools/sppc/getting_started:figure-sppc-gsg-testpmd}}\end{figure}

In terminal 2, add \sphinxcode{\sphinxupquote{ring:0}}, connect \sphinxcode{\sphinxupquote{vhost:1}} and \sphinxcode{\sphinxupquote{vhost:2}}
with it.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch vhost:1 ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch ring:0 vhost:2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 1; status}
\PYG{g+go}{\PYGZhy{} status: running}
\PYG{g+go}{\PYGZhy{} lcore\PYGZus{}ids:}
\PYG{g+go}{  \PYGZhy{} master: 1}
\PYG{g+go}{  \PYGZhy{} slave: 2}
\PYG{g+go}{\PYGZhy{} ports:}
\PYG{g+go}{  \PYGZhy{} ring:0 \PYGZhy{}\PYGZgt{} vhost:2}
\PYG{g+go}{  \PYGZhy{} vhost:1 \PYGZhy{}\PYGZgt{} ring:0}
\PYG{g+go}{  \PYGZhy{} vhost:2}
\end{sphinxVerbatim}

Start forwarding on port 0 by \sphinxcode{\sphinxupquote{start tx\_first}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+go}{testpmd\PYGZgt{} start tx\PYGZus{}first}
\PYG{g+go}{io packet forwarding \PYGZhy{} ports=2 \PYGZhy{} cores=1 \PYGZhy{} streams=2 \PYGZhy{} NUMA support...}
\PYG{g+go}{Logical Core 4 (socket 0) forwards packets on 2 streams:}
\PYG{g+go}{  RX P=0/Q=0 (socket 0) \PYGZhy{}\PYGZgt{} TX P=1/Q=0 (socket 0) peer=02:00:00:00:00:01}
\PYG{g+go}{  RX P=1/Q=0 (socket 0) \PYGZhy{}\PYGZgt{} TX P=0/Q=0 (socket 0) peer=02:00:00:00:00:00}
\PYG{g+go}{...}
\end{sphinxVerbatim}

Finally, stop forwarding to show statistics as the result.
In this case, about 35 million packets are forwarded.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+go}{testpmd\PYGZgt{} stop}
\PYG{g+go}{Telling cores to stop...}
\PYG{g+go}{Waiting for lcores to finish...}

\PYG{g+go}{  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Forward statistics for port 0  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{  RX\PYGZhy{}packets: 0              RX\PYGZhy{}dropped: 0             RX\PYGZhy{}total: 0}
\PYG{g+go}{  TX\PYGZhy{}packets: 35077664       TX\PYGZhy{}dropped: 0             TX\PYGZhy{}total: 35077664}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{g+go}{  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Forward statistics for port 1  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{  RX\PYGZhy{}packets: 35077632       RX\PYGZhy{}dropped: 0             RX\PYGZhy{}total: 35077632}
\PYG{g+go}{  TX\PYGZhy{}packets: 32             TX\PYGZhy{}dropped: 0             TX\PYGZhy{}total: 32}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{g+go}{  +++++++++++++++ Accumulated forward statistics for all ports++++++++++++}
\PYG{g+go}{  RX\PYGZhy{}packets: 35077632       RX\PYGZhy{}dropped: 0             RX\PYGZhy{}total: 35077632}
\PYG{g+go}{  TX\PYGZhy{}packets: 35077696       TX\PYGZhy{}dropped: 0             TX\PYGZhy{}total: 35077696}
\PYG{g+go}{  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
\end{sphinxVerbatim}


\subsection{Install}
\label{\detokenize{tools/sppc/install:install}}\label{\detokenize{tools/sppc/install:spp-container-install}}\label{\detokenize{tools/sppc/install::doc}}

\subsubsection{Required Packages}
\label{\detokenize{tools/sppc/install:required-packages}}\label{\detokenize{tools/sppc/install:sppc-install-required}}
You need to install packages required for DPDK, and docker.
\begin{itemize}
\item {} 
DPDK 17.11 or later (supporting container)

\item {} 
docker

\end{itemize}


\subsubsection{Configurations}
\label{\detokenize{tools/sppc/install:configurations}}\label{\detokenize{tools/sppc/install:sppc-install-config}}
You might need some additional non-mandatory configurations.


\paragraph{Run docker without sudo}
\label{\detokenize{tools/sppc/install:run-docker-without-sudo}}
You should run docker as sudo in most of scripts provided in
SPP container because for running DPDK applications.

However, you can run docker without sudo if you do not run DPDK
applications.
It is useful if you run \sphinxcode{\sphinxupquote{docker kill}} for terminating containerized
process, \sphinxcode{\sphinxupquote{docker rm}} or \sphinxcode{\sphinxupquote{docker rmi}} for cleaning resources.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminate container from docker \PYG{n+nb}{command}
\PYG{g+gp}{\PYGZdl{}} docker \PYG{n+nb}{kill} xxxxxx\PYGZus{}yyyyyyy

\PYG{g+gp}{\PYGZsh{}} Remove all of containers
\PYG{g+gp}{\PYGZdl{}} docker rm \PYG{l+s+sb}{{}`}docker ps \PYGZhy{}aq\PYG{l+s+sb}{{}`}

\PYG{g+gp}{\PYGZsh{}} Remove all of images
\PYG{g+gp}{\PYGZdl{}} docker rmi \PYG{l+s+sb}{{}`}docker images \PYGZhy{}aq\PYG{l+s+sb}{{}`}
\end{sphinxVerbatim}

The reason for running docker requires sudo is docker daemon
binds to a unix socket instead of a TCP port.
Unix socket is owned by root and other users can only access it using
sudo.
However, you can run if you add your account to docker group.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} sudo groupadd docker
\PYG{g+gp}{\PYGZdl{}} sudo usermod \PYGZhy{}aG docker \PYG{n+nv}{\PYGZdl{}USER}
\end{sphinxVerbatim}

To activate it, you have to logout and re-login at once.


\paragraph{Network Proxy}
\label{\detokenize{tools/sppc/install:network-proxy}}
If you are behind a proxy, you should configure proxy to build an image
or running container.
SPP container is supportng proxy configuration for getting
it from shell environments.
You confirm that \sphinxcode{\sphinxupquote{http\_proxy}}, \sphinxcode{\sphinxupquote{https\_proxy}}
and \sphinxcode{\sphinxupquote{no\_proxy}} of environmental variables are defined.

It also required to add proxy configurations for docker daemon.
Proxy for docker daemon is defined as \sphinxcode{\sphinxupquote{{[}Service{]}}} entry in
\sphinxcode{\sphinxupquote{/etc/systemd/system/docker.service.d/http-proxy.conf}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{[Service]}
\PYG{g+go}{Environment=\PYGZdq{}HTTP\PYGZus{}PROXY=http:...\PYGZdq{} \PYGZdq{}HTTPS\PYGZus{}PROXY=https...\PYGZdq{} \PYGZdq{}NO\PYGZus{}PROXY=...\PYGZdq{}}
\end{sphinxVerbatim}

To activate it, you should restart docker daemon.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} systemctl daemon\PYGZhy{}reload
\PYG{g+gp}{\PYGZdl{}} systemctl restart docker
\end{sphinxVerbatim}

You can confirm that environments are updated by running
\sphinxcode{\sphinxupquote{docker info}}.


\subsection{Build Images}
\label{\detokenize{tools/sppc/build_img:build-images}}\label{\detokenize{tools/sppc/build_img:spp-container-build-img}}\label{\detokenize{tools/sppc/build_img::doc}}
As explained in {\hyperref[\detokenize{tools/sppc/getting_started::doc}]{\sphinxcrossref{\DUrole{doc}{Getting Started}}}} section,
container image is built with \sphinxcode{\sphinxupquote{build/main.py}}.
This script is for running \sphinxcode{\sphinxupquote{docker build}} with a set of
\sphinxcode{\sphinxupquote{-{-}build-args}} options for building DPDK applications.

This script supports building application from any of repositories.
For example, you can build SPP hosted on your repository
\sphinxcode{\sphinxupquote{https://github.com/your/spp.git}}
with DPDK 18.11 as following.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t spp \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}dpdk\PYGZhy{}branch v18.11 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}spp\PYGZhy{}repo https://github.com/your/spp.git
\end{sphinxVerbatim}

Refer all of options running with \sphinxcode{\sphinxupquote{-h}} option.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}h
\PYG{g+go}{usage: main.py [\PYGZhy{}h] [\PYGZhy{}t TARGET] [\PYGZhy{}ci CONTAINER\PYGZus{}IMAGE]}
\PYG{g+go}{               [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME] [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER]}
\PYG{g+go}{               [\PYGZhy{}\PYGZhy{}dpdk\PYGZhy{}repo DPDK\PYGZus{}REPO] [\PYGZhy{}\PYGZhy{}dpdk\PYGZhy{}branch DPDK\PYGZus{}BRANCH]}
\PYG{g+go}{               [\PYGZhy{}\PYGZhy{}pktgen\PYGZhy{}repo PKTGEN\PYGZus{}REPO] [\PYGZhy{}\PYGZhy{}pktgen\PYGZhy{}branch PKTGEN\PYGZus{}BRANCH]}
\PYG{g+go}{               [\PYGZhy{}\PYGZhy{}spp\PYGZhy{}repo SPP\PYGZus{}REPO] [\PYGZhy{}\PYGZhy{}spp\PYGZhy{}branch SPP\PYGZus{}BRANCH]}
\PYG{g+go}{               [\PYGZhy{}\PYGZhy{}suricata\PYGZhy{}repo SURICATA\PYGZus{}REPO]}
\PYG{g+go}{               [\PYGZhy{}\PYGZhy{}suricata\PYGZhy{}branch SURICATA\PYGZus{}BRANCH]}
\PYG{g+go}{               [\PYGZhy{}\PYGZhy{}only\PYGZhy{}envsh] [\PYGZhy{}\PYGZhy{}dry\PYGZhy{}run]}

\PYG{g+go}{Docker image builder for DPDK applications}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help            show this help message and exit}
\PYG{g+go}{  \PYGZhy{}t TARGET, \PYGZhy{}\PYGZhy{}target TARGET}
\PYG{g+go}{                        Build target (\PYGZsq{}dpdk\PYGZsq{}, \PYGZsq{}pktgen\PYGZsq{}, \PYGZsq{}spp\PYGZsq{} or \PYGZsq{}suricata\PYGZsq{})}
\PYG{g+go}{  \PYGZhy{}ci CONTAINER\PYGZus{}IMAGE, \PYGZhy{}\PYGZhy{}container\PYGZhy{}image CONTAINER\PYGZus{}IMAGE}
\PYG{g+go}{                        Name of container image}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME}
\PYG{g+go}{                        Name of Linux distribution}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER   Version of Linux distribution}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}dpdk\PYGZhy{}repo DPDK\PYGZus{}REPO}
\PYG{g+go}{                        Git URL of DPDK}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}dpdk\PYGZhy{}branch DPDK\PYGZus{}BRANCH}
\PYG{g+go}{                        Specific version or branch of DPDK}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}pktgen\PYGZhy{}repo PKTGEN\PYGZus{}REPO}
\PYG{g+go}{                        Git URL of pktgen\PYGZhy{}dpdk}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}pktgen\PYGZhy{}branch PKTGEN\PYGZus{}BRANCH}
\PYG{g+go}{                        Specific version or branch of pktgen\PYGZhy{}dpdk}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}spp\PYGZhy{}repo SPP\PYGZus{}REPO   Git URL of SPP}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}spp\PYGZhy{}branch SPP\PYGZus{}BRANCH}
\PYG{g+go}{                        Specific version or branch of SPP}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}suricata\PYGZhy{}repo SURICATA\PYGZus{}REPO}
\PYG{g+go}{                        Git URL of DPDK\PYGZhy{}Suricata}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}suricata\PYGZhy{}branch SURICATA\PYGZus{}BRANCH}
\PYG{g+go}{                        Specific version or branch of DPDK\PYGZhy{}Suricata}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}only\PYGZhy{}envsh          Create config \PYGZsq{}env.sh\PYGZsq{} and exit without docker build}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}dry\PYGZhy{}run             Print matrix for checking and exit without docker}
\PYG{g+go}{                        build}
\end{sphinxVerbatim}


\subsubsection{Version Control for Images}
\label{\detokenize{tools/sppc/build_img:version-control-for-images}}\label{\detokenize{tools/sppc/build_img:sppc-build-img-vci}}
SPP container provides version control as combination of
target name, Linux distribution name and version.
Built images are referred such as \sphinxcode{\sphinxupquote{sppc/dpdk-ubuntu:latest}},
\sphinxcode{\sphinxupquote{sppc/spp-ubuntu:16.04}} or so.
\sphinxcode{\sphinxupquote{sppc}} is just a prefix to indicate an image of SPP container.

Build script decides a name from given options or default values.
If you run build script with only target and without distribution
name and version, it uses default values \sphinxcode{\sphinxupquote{ubuntu}} and \sphinxcode{\sphinxupquote{latest}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} build \PYG{l+s+s1}{\PYGZsq{}sppc/dpdk\PYGZhy{}ubuntu:latest\PYGZsq{}}
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t dpdk

\PYG{g+gp}{\PYGZsh{}} build \PYG{l+s+s1}{\PYGZsq{}sppc/spp\PYGZhy{}ubuntu:16.04\PYGZsq{}}
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t spp \PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver \PYG{l+m}{16}.04
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
SPP container does not support distributions other than Ubuntu
currently.
It is because SPP container has no Dockerfiles for building
CentOS, Fedora or so. It will be supported in a future release.

You can build any of distributions with build script
if you prepare Dockerfile by yourself.
How Dockerfiles are managed is described in
{\hyperref[\detokenize{tools/sppc/build_img:sppc-build-img-dockerfiles}]{\sphinxcrossref{\DUrole{std,std-ref}{Dockerfiles}}}} section.
\end{sphinxadmonition}

App container scripts also understand this naming rule.
For launching \sphinxcode{\sphinxupquote{testpmd}} on Ubuntu 18.04,
simply give \sphinxcode{\sphinxupquote{-{-}dist-ver}} to indicate the version and other options
for \sphinxcode{\sphinxupquote{testpmd}} itself.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} launch testpmd on \PYG{l+s+s1}{\PYGZsq{}sppc/dpdk\PYGZhy{}ubuntu:18.04\PYGZsq{}}
\PYG{g+gp}{\PYGZdl{}} python3 app/testpmd.py \PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver \PYG{l+m}{18}.04 \PYGZhy{}l \PYG{l+m}{3}\PYGZhy{}4 ...
\end{sphinxVerbatim}

But, how can we build images for different versions of DPDK,
such as 18.11 and 19.11, on the same distribution?
In this case, you can use \sphinxcode{\sphinxupquote{-{-}container-image}} or \sphinxcode{\sphinxupquote{-ci}} option for
using any of names. It is also referred from app container scripts.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} build image with arbitrary name
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t dpdk \PYGZhy{}ci sppc/dpdk18.11\PYGZhy{}ubuntu:latest \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}dpdk\PYGZhy{}branch v18.11

\PYG{g+gp}{\PYGZsh{}} launch testpmd with \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}ci\PYGZsq{}}
\PYG{g+gp}{\PYGZdl{}} python3 app/testpmd.py \PYGZhy{}ci sppc/dpdk18.11\PYGZhy{}ubuntu:latest \PYGZhy{}l \PYG{l+m}{3}\PYGZhy{}4 ...
\end{sphinxVerbatim}


\subsubsection{Dockerfiles}
\label{\detokenize{tools/sppc/build_img:dockerfiles}}\label{\detokenize{tools/sppc/build_img:sppc-build-img-dockerfiles}}
SPP container includes Dockerfiles for each of distributions and
its versions.
For instance, Dockerfiles for Ubuntu are found in \sphinxcode{\sphinxupquote{build/ubuntu}}
directory.
You notice that each of Dockerfiles has its version as a part of
file name.
In other words, the list of Dockerfiles under the \sphinxcode{\sphinxupquote{ubuntu}} directory
shows all of supported versions of Ubuntu.
You can not find Dockerfiles for CentOS as \sphinxcode{\sphinxupquote{build/centos}} or other
distributions because it is not supported currently.
It is included in a future release.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} tree build/ubuntu/
\PYG{g+go}{build/ubuntu/}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} dpdk}
\PYG{g+go}{\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.16.04}
\PYG{g+go}{\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.18.04}
\PYG{g+go}{\textbar{}    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.latest}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} pktgen}
\PYG{g+go}{\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.16.04}
\PYG{g+go}{\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.18.04}
\PYG{g+go}{\textbar{}    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.latest}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} spp}
\PYG{g+go}{\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.16.04}
\PYG{g+go}{\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.18.04}
\PYG{g+go}{\textbar{}    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.latest}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} suricata}
\PYG{g+go}{     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.16.04}
\PYG{g+go}{     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.18.04}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Dockerfile.latest}
\end{sphinxVerbatim}


\subsubsection{Build suricata image}
\label{\detokenize{tools/sppc/build_img:build-suricata-image}}\label{\detokenize{tools/sppc/build_img:sppc-build-img-suricata}}
Building DPDK, pktgen and SPP is completed by just running \sphinxcode{\sphinxupquote{build/main.py}}
script. However, building suricata requires few additional few steps.

First, build an image with \sphinxcode{\sphinxupquote{main.py}} script as similar to other apps.
In this example, use DPDK v18.11 and Ubuntu 18.04.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 build/main.py \PYGZhy{}t suricata \PYGZhy{}\PYGZhy{}dpdk\PYGZhy{}branch v18.11 \PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver \PYG{l+m}{18}.04
\end{sphinxVerbatim}

After build is completed, you can find image named as
\sphinxcode{\sphinxupquote{sppc/suricata-ubuntu:18.04}} from \sphinxcode{\sphinxupquote{docker images}}.
Run bash command with this image, and execute an installer script in home
directory which is created while building.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} docker run \PYGZhy{}it sppc/suricata\PYGZhy{}ubuntu:18.04 /bin/bash
\PYG{g+gp}{\PYGZsh{}} ./install\PYGZus{}suricata.sh
\end{sphinxVerbatim}

It clones and compiles suricata under home directory. You can find
\sphinxcode{\sphinxupquote{\$HOME/DPDK\_SURICATA-4\_1\_1}} after runing this script is completed.

Although now you are ready to use suricata, it takes a little time for doing
this task everytime you run the app container.
For skipping this task, you can create another image from running container
with \sphinxcode{\sphinxupquote{docker commit}} command.

Logout and create a new docker image with \sphinxcode{\sphinxupquote{docker commit}} image’s
container ID. In this example, new image is named as
\sphinxtitleref{sppc/suricata-ubuntu2:18.04}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} \PYG{n+nb}{exit}
\PYG{g+gp}{\PYGZdl{}} docker ps \PYGZhy{}a
\PYG{g+go}{CONTAINER\PYGZus{}ID  sppc/suricata\PYGZhy{}ubuntu:18.04  \PYGZdq{}/bin/bash\PYGZdq{}  3 minutes ...}
\PYG{g+gp}{\PYGZdl{}} docker commit CONTAINER\PYGZus{}ID sppc/suricata\PYGZhy{}ubuntu2:18.04
\end{sphinxVerbatim}

You can run compiled suricata with the new image with docker as following,
or app container launcher with specific options as described in.
{\hyperref[\detokenize{tools/sppc/app_launcher:sppc-appl-suricata}]{\sphinxcrossref{\DUrole{std,std-ref}{Suricata Container}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} docker run \PYGZhy{}it sppc/suricata\PYGZhy{}ubuntu:18.04 /bin/bash
\PYG{g+gp}{\PYGZsh{}} suricata \PYGZhy{}\PYGZhy{}build\PYGZhy{}info
\end{sphinxVerbatim}


\subsubsection{Inspect Inside of Container}
\label{\detokenize{tools/sppc/build_img:inspect-inside-of-container}}\label{\detokenize{tools/sppc/build_img:sppc-build-img-inspect}}
Container is useful, but just bit annoying to inspect inside
the container because it is cleaned up immediately after process
is finished and there is no clue what is happened in.

\sphinxcode{\sphinxupquote{build/run.sh}} is a helper script to inspect inside the container.
You can run \sphinxcode{\sphinxupquote{bash}} on the container to confirm behaviour of
targetting application, or run any of command.

This script refers \sphinxcode{\sphinxupquote{ubuntu/dpdk/env.sh}} for Ubuntu image  to include
environment variables.
So, it is failed to \sphinxcode{\sphinxupquote{build/run.sh}} if this config file
does not exist.
You can create it from \sphinxcode{\sphinxupquote{build/main.py}} with \sphinxcode{\sphinxupquote{-{-}only-envsh}} option
if you removed it accidentally.


\subsection{App Container Launchers}
\label{\detokenize{tools/sppc/app_launcher:app-container-launchers}}\label{\detokenize{tools/sppc/app_launcher:spp-container-app-launcher}}\label{\detokenize{tools/sppc/app_launcher::doc}}
App container launcher is a python script for running SPP or DPDK
application on a container.
As described by name, for instance, \sphinxcode{\sphinxupquote{pktgen.py}} launches pktgen-dpdk
inside a container.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} tree app/
\PYG{g+go}{app/}
\PYG{g+go}{...}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} helloworld.py}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} l2fwd.py}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} l3fwd.py}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} l3fwd\PYGZhy{}acl.py}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} load\PYGZhy{}balancer.py}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} pktgen.py}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} spp\PYGZhy{}nfv.py}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} spp\PYGZhy{}primary.py}
\PYG{g+go}{\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} suricata.py}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} testpmd.py}
\end{sphinxVerbatim}


\subsubsection{Setup}
\label{\detokenize{tools/sppc/app_launcher:setup}}\label{\detokenize{tools/sppc/app_launcher:sppc-appl-setup}}
You should define \sphinxcode{\sphinxupquote{SPP\_CTL\_IP}} environment variable to SPP controller
be accessed from other SPP processes inside containers.
SPP controller is a CLI tool for accepting user’s commands.

You cannot use \sphinxcode{\sphinxupquote{127.0.0.1}} or \sphinxcode{\sphinxupquote{localhost}} for \sphinxcode{\sphinxupquote{SPP\_CTL\_IP}}
because SPP processes try to find SPP controller inside each of
containers and fail to.
From inside of the container, SPP processes should be known IP address
other than \sphinxcode{\sphinxupquote{127.0.0.1}} or \sphinxcode{\sphinxupquote{localhost}}
of host on which SPP controller running.

SPP controller should be launched before other SPP processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py
\end{sphinxVerbatim}


\subsubsection{SPP Primary Container}
\label{\detokenize{tools/sppc/app_launcher:spp-primary-container}}\label{\detokenize{tools/sppc/app_launcher:sppc-appl-spp-primary}}
SPP primary process is launched from \sphinxcode{\sphinxupquote{app/spp-primary.py}} as an
app container.
It manages resources on host from inside the container.
\sphinxcode{\sphinxupquote{app/spp-primary.py}} calls \sphinxcode{\sphinxupquote{docker run}} with
\sphinxcode{\sphinxupquote{-v}} option to mount hugepages and other devices in the container
to share them between host and containers.

SPP primary process is launched as foreground or background mode.
You can show statistics of packet forwarding if you launch it with
two cores and in foreground mode.
In this case, SPP primary uses one for resource management and
another one for showing statistics.
If you need to minimize the usage of cores, or are not interested in
the statistics,
you should give just one core and run in background mode.
If you run SPP primary in foreground mode with one core,
it shows log messages which is also referred in syslog.

Here is an example for launching SPP primary with core list 0-1 in
foreground mode.
You should give portmask opiton \sphinxcode{\sphinxupquote{-p}} because SPP primary requires
at least one port, or failed to launch.
This example is assumed that host machine has two or more
physical ports.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary \PYGZhy{}l \PYG{l+m}{0}\PYGZhy{}1 \PYGZhy{}p 0x03 \PYGZhy{}fg
\end{sphinxVerbatim}

It is another example with one core and two ports in background mode.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}p 0x03
\end{sphinxVerbatim}

SPP primary is able to run with virtual devices instead of physical NICs
for a case you do not have dedicated NICs for DPDK.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}d vhost:1,vhost:2 \PYGZhy{}p 0x03
\end{sphinxVerbatim}

If you need to inspect a docker command without launching
a container, use \sphinxcode{\sphinxupquote{-{-}dry-run}} option.
It composes docker command and just display it without running the
docker command.

You refer all of options with \sphinxcode{\sphinxupquote{-h}} option.
Options of app container scripts are categorized four types.
First one is EAL option, for example \sphinxcode{\sphinxupquote{-l}}, \sphinxcode{\sphinxupquote{-c}} or \sphinxcode{\sphinxupquote{-m}}.
Second one is app container option which is a common set of options for
app containers connected with SPP. So, containers of SPP processes do
not have app container option.
Third one is application specific option. In this case,
\sphinxcode{\sphinxupquote{-n}}, \sphinxcode{\sphinxupquote{-p}} or \sphinxcode{\sphinxupquote{-ip}}.
Final one is container option, for example \sphinxcode{\sphinxupquote{-{-}dist-name}} or
\sphinxcode{\sphinxupquote{-{-}ci}}.
EAL options and container options are common for all of app container
scripts.
On the other hand, application specific options are different each other.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary.py \PYGZhy{}h
\PYG{g+go}{usage: spp\PYGZhy{}primary.py [\PYGZhy{}h] [\PYGZhy{}l CORE\PYGZus{}LIST] [\PYGZhy{}c CORE\PYGZus{}MASK] [\PYGZhy{}m MEM]}
\PYG{g+go}{                      [\PYGZhy{}\PYGZhy{}vdev [VDEV [VDEV ...]]] [\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem SOCKET\PYGZus{}MEM]}
\PYG{g+go}{                      [\PYGZhy{}b [PCI\PYGZus{}BLACKLIST [PCI\PYGZus{}BLACKLIST ...]]]}
\PYG{g+go}{                      [\PYGZhy{}w [PCI\PYGZus{}WHITELIST [PCI\PYGZus{}WHITELIST ...]]]}
\PYG{g+go}{                      [\PYGZhy{}\PYGZhy{}single\PYGZhy{}file\PYGZhy{}segments] [\PYGZhy{}\PYGZhy{}nof\PYGZhy{}memchan NOF\PYGZus{}MEMCHAN]}
\PYG{g+go}{                      [\PYGZhy{}d DEV\PYGZus{}UIDS] [\PYGZhy{}v [VOLUME [VOLUME ...]]]}
\PYG{g+go}{                      [\PYGZhy{}nq NOF\PYGZus{}QUEUES] [\PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged] [\PYGZhy{}n NOF\PYGZus{}RING]}
\PYG{g+go}{                      [\PYGZhy{}p PORT\PYGZus{}MASK] [\PYGZhy{}ip CTL\PYGZus{}IP] [\PYGZhy{}\PYGZhy{}ctl\PYGZhy{}port CTL\PYGZus{}PORT]}
\PYG{g+go}{                      [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME] [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER]}
\PYG{g+go}{                      [\PYGZhy{}\PYGZhy{}workdir WORKDIR] [\PYGZhy{}\PYGZhy{}name NAME] [\PYGZhy{}ci CONTAINER\PYGZus{}IMAGE]}
\PYG{g+go}{                      [\PYGZhy{}fg] [\PYGZhy{}\PYGZhy{}dry\PYGZhy{}run]}

\PYG{g+go}{Launcher for spp\PYGZhy{}primary application container}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help            show this help message and exit}
\PYG{g+go}{  \PYGZhy{}l CORE\PYGZus{}LIST, \PYGZhy{}\PYGZhy{}core\PYGZhy{}list CORE\PYGZus{}LIST}
\PYG{g+go}{                        Core list}
\PYG{g+go}{  \PYGZhy{}c CORE\PYGZus{}MASK, \PYGZhy{}\PYGZhy{}core\PYGZhy{}mask CORE\PYGZus{}MASK}
\PYG{g+go}{                        Core mask}
\PYG{g+go}{  \PYGZhy{}m MEM, \PYGZhy{}\PYGZhy{}mem MEM     Memory size (default is 1024)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}vdev [VDEV [VDEV ...]]}
\PYG{g+go}{                        Virtual device in the format of DPDK}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem SOCKET\PYGZus{}MEM}
\PYG{g+go}{                        Memory size}
\PYG{g+go}{  \PYGZhy{}b [PCI\PYGZus{}BLACKLIST [PCI\PYGZus{}BLACKLIST ...]], \PYGZhy{}\PYGZhy{}pci\PYGZhy{}blacklist [PCI\PYGZus{}BLACKLIST...}
\PYG{g+go}{                        PCI blacklist for excluding devices}
\PYG{g+go}{  \PYGZhy{}w [PCI\PYGZus{}WHITELIST [PCI\PYGZus{}WHITELIST ...]], \PYGZhy{}\PYGZhy{}pci\PYGZhy{}whitelist [PCI\PYGZus{}WHITELIST...}
\PYG{g+go}{                        PCI whitelist for including devices}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}single\PYGZhy{}file\PYGZhy{}segments}
\PYG{g+go}{                        Create fewer files in hugetlbfs (non\PYGZhy{}legacy mode}
\PYG{g+go}{                        only).}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}nof\PYGZhy{}memchan NOF\PYGZus{}MEMCHAN}
\PYG{g+go}{                        Number of memory channels (default is 4)}
\PYG{g+go}{  \PYGZhy{}d DEV\PYGZus{}UIDS, \PYGZhy{}\PYGZhy{}dev\PYGZhy{}uids DEV\PYGZus{}UIDS}
\PYG{g+go}{                        Virtual devices of SPP in resource UID format}
\PYG{g+go}{  \PYGZhy{}v [VOLUME [VOLUME ...]], \PYGZhy{}\PYGZhy{}volume [VOLUME [VOLUME ...]]}
\PYG{g+go}{                        Bind mount a volume (for docker)}
\PYG{g+go}{  \PYGZhy{}nq NOF\PYGZus{}QUEUES, \PYGZhy{}\PYGZhy{}nof\PYGZhy{}queues NOF\PYGZus{}QUEUES}
\PYG{g+go}{                        Number of queues of virtio (default is 1)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged       Disable docker\PYGZsq{}s privileged mode if it\PYGZsq{}s needed}
\PYG{g+go}{  \PYGZhy{}n NOF\PYGZus{}RING, \PYGZhy{}\PYGZhy{}nof\PYGZhy{}ring NOF\PYGZus{}RING}
\PYG{g+go}{                        Maximum number of Ring PMD}
\PYG{g+go}{  \PYGZhy{}p PORT\PYGZus{}MASK, \PYGZhy{}\PYGZhy{}port\PYGZhy{}mask PORT\PYGZus{}MASK}
\PYG{g+go}{                        Port mask}
\PYG{g+go}{  \PYGZhy{}ip CTL\PYGZus{}IP, \PYGZhy{}\PYGZhy{}ctl\PYGZhy{}ip CTL\PYGZus{}IP}
\PYG{g+go}{                        IP address of spp\PYGZhy{}ctl}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}ctl\PYGZhy{}port CTL\PYGZus{}PORT   Port for primary of spp\PYGZhy{}ctl}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME}
\PYG{g+go}{                        Name of Linux distribution}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER   Version of Linux distribution}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}workdir WORKDIR     Path of directory in which the command is launched}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}name NAME           Name of container}
\PYG{g+go}{  \PYGZhy{}ci CONTAINER\PYGZus{}IMAGE, \PYGZhy{}\PYGZhy{}container\PYGZhy{}image CONTAINER\PYGZus{}IMAGE}
\PYG{g+go}{                        Name of container image}
\PYG{g+go}{  \PYGZhy{}fg, \PYGZhy{}\PYGZhy{}foreground     Run container as foreground mode}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}dry\PYGZhy{}run             Only print matrix, do not run, and exit}
\end{sphinxVerbatim}


\subsubsection{SPP Secondary Container}
\label{\detokenize{tools/sppc/app_launcher:spp-secondary-container}}\label{\detokenize{tools/sppc/app_launcher:sppc-appl-spp-secondary}}
In SPP, there are three types of secondary process, \sphinxcode{\sphinxupquote{spp\_nfv}},
\sphinxcode{\sphinxupquote{spp\_vf}} or so.
However, SPP container does only support \sphinxcode{\sphinxupquote{spp\_nfv}} currently.

\sphinxcode{\sphinxupquote{spp-nfv.py}} launches \sphinxcode{\sphinxupquote{spp\_nfv}} as an app container and requires
options for secondary ID and core list (or core mask).

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{1} \PYGZhy{}l \PYG{l+m}{2}\PYGZhy{}3
\end{sphinxVerbatim}

Refer help for all of options and usges.
It shows only application specific options for simplicity.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}h
\PYG{g+go}{usage: spp\PYGZhy{}nfv.py [\PYGZhy{}h] [\PYGZhy{}l CORE\PYGZus{}LIST] [\PYGZhy{}c CORE\PYGZus{}MASK] [\PYGZhy{}m MEM]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}vdev [VDEV [VDEV ...]]] [\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem SOCKET\PYGZus{}MEM]}
\PYG{g+go}{                  [\PYGZhy{}b [PCI\PYGZus{}BLACKLIST [PCI\PYGZus{}BLACKLIST ...]]]}
\PYG{g+go}{                  [\PYGZhy{}w [PCI\PYGZus{}WHITELIST [PCI\PYGZus{}WHITELIST ...]]]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}single\PYGZhy{}file\PYGZhy{}segments] [\PYGZhy{}\PYGZhy{}nof\PYGZhy{}memchan NOF\PYGZus{}MEMCHAN]}
\PYG{g+go}{                  [\PYGZhy{}d DEV\PYGZus{}UIDS] [\PYGZhy{}v [VOLUME [VOLUME ...]]] [\PYGZhy{}nq NOF\PYGZus{}QUEUES]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged] [\PYGZhy{}i SEC\PYGZus{}ID] [\PYGZhy{}ip CTL\PYGZus{}IP]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}ctl\PYGZhy{}port CTL\PYGZus{}PORT] [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER] [\PYGZhy{}\PYGZhy{}workdir WORKDIR] [\PYGZhy{}\PYGZhy{}name NAME]}
\PYG{g+go}{                  [\PYGZhy{}ci CONTAINER\PYGZus{}IMAGE] [\PYGZhy{}fg] [\PYGZhy{}\PYGZhy{}dry\PYGZhy{}run]}

\PYG{g+go}{Launcher for spp\PYGZhy{}nfv application container}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  ...}
\PYG{g+go}{  \PYGZhy{}i SEC\PYGZus{}ID, \PYGZhy{}\PYGZhy{}sec\PYGZhy{}id SEC\PYGZus{}ID}
\PYG{g+go}{                        Secondary ID}
\PYG{g+go}{  \PYGZhy{}ip CTL\PYGZus{}IP, \PYGZhy{}\PYGZhy{}ctl\PYGZhy{}ip CTL\PYGZus{}IP}
\PYG{g+go}{                        IP address of spp\PYGZhy{}ctl}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}ctl\PYGZhy{}port CTL\PYGZus{}PORT   Port for secondary of spp\PYGZhy{}ctl}
\PYG{g+go}{  ...}
\end{sphinxVerbatim}


\subsubsection{L2fwd Container}
\label{\detokenize{tools/sppc/app_launcher:l2fwd-container}}\label{\detokenize{tools/sppc/app_launcher:sppc-appl-l2fwd}}
\sphinxcode{\sphinxupquote{app/l2fwd.py}} is a launcher script for DPDK \sphinxcode{\sphinxupquote{l2fwd}} sample
application.
It launches \sphinxcode{\sphinxupquote{l2fwd}} on a container with specified
vhost interfaces.

This is an example for launching with two cores (6-7th cores) with
\sphinxcode{\sphinxupquote{-l}} and two vhost interfaces with \sphinxcode{\sphinxupquote{-d}}.
\sphinxcode{\sphinxupquote{l2fwd}} requires \sphinxcode{\sphinxupquote{-{-}port-mask}} or \sphinxcode{\sphinxupquote{-p}} option and the number of
ports should be even number.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/l2fwd.py \PYGZhy{}l \PYG{l+m}{6}\PYGZhy{}7 \PYGZhy{}d vhost:1,vhost:2 \PYGZhy{}p 0x03 \PYGZhy{}fg
\PYG{g+go}{...}
\end{sphinxVerbatim}

Refer help for all of options and usges.
It includes app container options, for example \sphinxcode{\sphinxupquote{-d}} for vhost devices
and \sphinxcode{\sphinxupquote{-nq}} for the number of queues of virtio, because \sphinxcode{\sphinxupquote{l2fwd}} is not
a SPP process.
It shows options without of EAL and container for simplicity.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/l2fwd.py \PYGZhy{}h
\PYG{g+go}{usage: l2fwd.py [\PYGZhy{}h] [\PYGZhy{}l CORE\PYGZus{}LIST] [\PYGZhy{}c CORE\PYGZus{}MASK] [\PYGZhy{}m MEM]}
\PYG{g+go}{                [\PYGZhy{}\PYGZhy{}vdev [VDEV [VDEV ...]]] [\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem SOCKET\PYGZus{}MEM]}
\PYG{g+go}{                [\PYGZhy{}b [PCI\PYGZus{}BLACKLIST [PCI\PYGZus{}BLACKLIST ...]]]}
\PYG{g+go}{                [\PYGZhy{}w [PCI\PYGZus{}WHITELIST [PCI\PYGZus{}WHITELIST ...]]]}
\PYG{g+go}{                [\PYGZhy{}\PYGZhy{}single\PYGZhy{}file\PYGZhy{}segments] [\PYGZhy{}\PYGZhy{}nof\PYGZhy{}memchan NOF\PYGZus{}MEMCHAN]}
\PYG{g+go}{                [\PYGZhy{}d DEV\PYGZus{}UIDS] [\PYGZhy{}v [VOLUME [VOLUME ...]]] [\PYGZhy{}nq NOF\PYGZus{}QUEUES]}
\PYG{g+go}{                [\PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged] [\PYGZhy{}p PORT\PYGZus{}MASK] [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME]}
\PYG{g+go}{                [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER] [\PYGZhy{}\PYGZhy{}workdir WORKDIR] [\PYGZhy{}\PYGZhy{}name NAME]}
\PYG{g+go}{                [\PYGZhy{}ci CONTAINER\PYGZus{}IMAGE] [\PYGZhy{}fg] [\PYGZhy{}\PYGZhy{}dry\PYGZhy{}run]}

\PYG{g+go}{Launcher for l2fwd application container}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  ...}
\PYG{g+go}{  \PYGZhy{}d DEV\PYGZus{}UIDS, \PYGZhy{}\PYGZhy{}dev\PYGZhy{}uids DEV\PYGZus{}UIDS}
\PYG{g+go}{                        Virtual devices of SPP in resource UID format}
\PYG{g+go}{  \PYGZhy{}nq NOF\PYGZus{}QUEUES, \PYGZhy{}\PYGZhy{}nof\PYGZhy{}queues NOF\PYGZus{}QUEUES}
\PYG{g+go}{                        Number of queues of virtio (default is 1)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged       Disable docker\PYGZsq{}s privileged mode if it\PYGZsq{}s needed}
\PYG{g+go}{  \PYGZhy{}p PORT\PYGZus{}MASK, \PYGZhy{}\PYGZhy{}port\PYGZhy{}mask PORT\PYGZus{}MASK}
\PYG{g+go}{                        Port mask}
\PYG{g+go}{  ...}
\end{sphinxVerbatim}


\subsubsection{L3fwd Container}
\label{\detokenize{tools/sppc/app_launcher:l3fwd-container}}\label{\detokenize{tools/sppc/app_launcher:sppc-appl-l3fwd}}
\sphinxhref{https://dpdk.org/doc/guides/sample\_app\_ug/l3\_forward.html}{L3fwd}
application is a simple example of packet processing
using the DPDK.
Differed from l2fwd, the forwarding decision is made based on
information read from input packet.
This application provides LPM (longest prefix match) or
EM (exact match) methods for packet classification.

\sphinxcode{\sphinxupquote{app/l3fwd.py}} launches l3fwd on a container.
As similar to \sphinxcode{\sphinxupquote{l3fwd}} application, this python script takes several
options other than EAL for port configurations and classification methods.
The mandatory options for the application are \sphinxcode{\sphinxupquote{-p}} for portmask
and \sphinxcode{\sphinxupquote{-{-}config}} for rx as a set of combination of
\sphinxcode{\sphinxupquote{(port, queue, locre)}}.

Here is an example for launching l3fwd app container with two vhost
interfaces and printed log messages.
There are two rx ports. \sphinxcode{\sphinxupquote{(0,0,1)}} is for queue of port 0 for which
lcore 1 is assigned, and \sphinxcode{\sphinxupquote{(1,0,2)}} is for port 1.
In this case, you should add \sphinxcode{\sphinxupquote{-nq}} option because the number of both
of rx and tx queues are two while the default number of virtio device
is one.
The number of tx queues, is two in this case, is decided to be the same
value as the number of lcores.
In \sphinxcode{\sphinxupquote{-{-}vdev}} option setup in the script, the number of queues is
defined as \sphinxcode{\sphinxupquote{virtio\_...,queues=2,...}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/l3fwd.py \PYGZhy{}l \PYG{l+m}{1}\PYGZhy{}2 \PYGZhy{}nq \PYG{l+m}{2} \PYGZhy{}d vhost:1,vhost:2 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}p 0x03 \PYGZhy{}\PYGZhy{}config\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}(0,0,1),(1,0,2)\PYGZdq{}} \PYGZhy{}fg
\PYG{g+go}{ sudo docker run \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}it \PYGZbs{}}
\PYG{g+go}{ ...}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}vdev virtio\PYGZus{}user1,queues=2,path=/var/run/usvhost1 \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}vdev virtio\PYGZus{}user2,queues=2,path=/var/run/usvhost2 \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix spp\PYGZhy{}l3fwd\PYGZhy{}container1 \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{} \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}p 0x03 \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}config \PYGZdq{}(0,0,8),(1,0,9)\PYGZdq{} \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}parse\PYGZhy{}ptype ipv4}
\PYG{g+go}{EAL: Detected 16 lcore(s)}
\PYG{g+go}{EAL: Auto\PYGZhy{}detected process type: PRIMARY}
\PYG{g+go}{EAL: Multi\PYGZhy{}process socket /var/run/.spp\PYGZhy{}l3fwd\PYGZhy{}container1\PYGZus{}unix}
\PYG{g+go}{EAL: Probing VFIO support...}
\PYG{g+go}{soft parse\PYGZhy{}ptype is enabled}
\PYG{g+go}{LPM or EM none selected, default LPM on}
\PYG{g+go}{Initializing port 0 ... Creating queues: nb\PYGZus{}rxq=1 nb\PYGZus{}txq=2...}
\PYG{g+go}{LPM: Adding route 0x01010100 / 24 (0)}
\PYG{g+go}{LPM: Adding route 0x02010100 / 24 (1)}
\PYG{g+go}{LPM: Adding route IPV6 / 48 (0)}
\PYG{g+go}{LPM: Adding route IPV6 / 48 (1)}
\PYG{g+go}{txq=8,0,0 txq=9,1,0}
\PYG{g+go}{Initializing port 1 ... Creating queues: nb\PYGZus{}rxq=1 nb\PYGZus{}txq=2...}

\PYG{g+go}{Initializing rx queues on lcore 8 ... rxq=0,0,0}
\PYG{g+go}{Initializing rx queues on lcore 9 ... rxq=1,0,0}
\PYG{g+go}{...}
\end{sphinxVerbatim}

You can increase lcores more than the number of ports, for instance,
four lcores for two ports.
However, remaining 3rd and 4th lcores do nothing and require
\sphinxcode{\sphinxupquote{-nq 4}} for tx queues.

Default classification rule is \sphinxcode{\sphinxupquote{LPM}} and the routing table is defined
in \sphinxcode{\sphinxupquote{dpdk/examples/l3fwd/l3fwd\_lpm.c}} as below.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k}{static} \PYG{k}{struct} \PYG{n}{ipv4\PYGZus{}l3fwd\PYGZus{}lpm\PYGZus{}route} \PYG{n}{ipv4\PYGZus{}l3fwd\PYGZus{}lpm\PYGZus{}route\PYGZus{}array}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{p}{\PYGZob{}}\PYG{n}{IPv4}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{n}{IPv4}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{n}{IPv4}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{n}{IPv4}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{n}{IPv4}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{n}{IPv4}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{n}{IPv4}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{n}{IPv4}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Refer help for all of options and usges.
It shows options without of EAL and container for simplicity.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/l3fwd.py \PYGZhy{}h
\PYG{g+go}{usage: l3fwd.py [\PYGZhy{}h] [\PYGZhy{}l CORE\PYGZus{}LIST] [\PYGZhy{}c CORE\PYGZus{}MASK] [\PYGZhy{}m MEM]}
\PYG{g+go}{                [\PYGZhy{}\PYGZhy{}vdev [VDEV [VDEV ...]]] [\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem SOCKET\PYGZus{}MEM]}
\PYG{g+go}{                [\PYGZhy{}b [PCI\PYGZus{}BLACKLIST [PCI\PYGZus{}BLACKLIST ...]]]}
\PYG{g+go}{                [\PYGZhy{}w [PCI\PYGZus{}WHITELIST [PCI\PYGZus{}WHITELIST ...]]]}
\PYG{g+go}{                [\PYGZhy{}\PYGZhy{}single\PYGZhy{}file\PYGZhy{}segments] [\PYGZhy{}\PYGZhy{}nof\PYGZhy{}memchan NOF\PYGZus{}MEMCHAN]}
\PYG{g+go}{                [\PYGZhy{}d DEV\PYGZus{}UIDS] [\PYGZhy{}v [VOLUME [VOLUME ...]]] [\PYGZhy{}nq NOF\PYGZus{}QUEUES]}
\PYG{g+go}{                [\PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged] [\PYGZhy{}p PORT\PYGZus{}MASK] [\PYGZhy{}\PYGZhy{}config CONFIG] [\PYGZhy{}P] [\PYGZhy{}E]}
\PYG{g+go}{                [\PYGZhy{}L] [\PYGZhy{}dst [ETH\PYGZus{}DEST [ETH\PYGZus{}DEST ...]]] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}jumbo]}
\PYG{g+go}{                [\PYGZhy{}\PYGZhy{}max\PYGZhy{}pkt\PYGZhy{}len MAX\PYGZus{}PKT\PYGZus{}LEN] [\PYGZhy{}\PYGZhy{}no\PYGZhy{}numa] [\PYGZhy{}\PYGZhy{}hash\PYGZhy{}entry\PYGZhy{}num]}
\PYG{g+go}{                [\PYGZhy{}\PYGZhy{}ipv6] [\PYGZhy{}\PYGZhy{}parse\PYGZhy{}ptype PARSE\PYGZus{}PTYPE] [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME]}
\PYG{g+go}{                [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER] [\PYGZhy{}\PYGZhy{}workdir WORKDIR] [\PYGZhy{}\PYGZhy{}name NAME]}
\PYG{g+go}{                [\PYGZhy{}ci CONTAINER\PYGZus{}IMAGE] [\PYGZhy{}fg] [\PYGZhy{}\PYGZhy{}dry\PYGZhy{}run]}

\PYG{g+go}{Launcher for l3fwd application container}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  ...}
\PYG{g+go}{  \PYGZhy{}d DEV\PYGZus{}UIDS, \PYGZhy{}\PYGZhy{}dev\PYGZhy{}uids DEV\PYGZus{}UIDS}
\PYG{g+go}{                        Virtual devices of SPP in resource UID format}
\PYG{g+go}{  \PYGZhy{}nq NOF\PYGZus{}QUEUES, \PYGZhy{}\PYGZhy{}nof\PYGZhy{}queues NOF\PYGZus{}QUEUES}
\PYG{g+go}{                        Number of queues of virtio (default is 1)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged       Disable docker\PYGZsq{}s privileged mode if it\PYGZsq{}s needed}
\PYG{g+go}{  \PYGZhy{}p PORT\PYGZus{}MASK, \PYGZhy{}\PYGZhy{}port\PYGZhy{}mask PORT\PYGZus{}MASK}
\PYG{g+go}{                        (Mandatory) Port mask}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}config CONFIG       (Mandatory) Define set of port, queue, lcore for}
\PYG{g+go}{                        ports}
\PYG{g+go}{  \PYGZhy{}P, \PYGZhy{}\PYGZhy{}promiscous      Set all ports to promiscous mode (default is None)}
\PYG{g+go}{  \PYGZhy{}E, \PYGZhy{}\PYGZhy{}exact\PYGZhy{}match     Enable exact match (default is None)}
\PYG{g+go}{  \PYGZhy{}L, \PYGZhy{}\PYGZhy{}longest\PYGZhy{}prefix\PYGZhy{}match}
\PYG{g+go}{                        Enable longest prefix match (default is None)}
\PYG{g+go}{  \PYGZhy{}dst [ETH\PYGZus{}DEST [ETH\PYGZus{}DEST ...]], \PYGZhy{}\PYGZhy{}eth\PYGZhy{}dest [ETH\PYGZus{}DEST [ETH\PYGZus{}DEST ...]]}
\PYG{g+go}{                        Ethernet dest for port X (X,MM:MM:MM:MM:MM:MM)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}enable\PYGZhy{}jumbo        Enable jumbo frames, [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}jumbo [\PYGZhy{}\PYGZhy{}max\PYGZhy{}pkt\PYGZhy{}len}
\PYG{g+go}{                        PKTLEN]]}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}max\PYGZhy{}pkt\PYGZhy{}len MAX\PYGZus{}PKT\PYGZus{}LEN}
\PYG{g+go}{                        Max packet length (64\PYGZhy{}9600) if jumbo is enabled.}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}numa             Disable NUMA awareness (default is None)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}hash\PYGZhy{}entry\PYGZhy{}num      Specify the hash entry number in hexadecimal}
\PYG{g+go}{                        (default is None)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}ipv6                Specify the hash entry number in hexadecimal}
\PYG{g+go}{                        (default is None)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}parse\PYGZhy{}ptype PARSE\PYGZus{}PTYPE}
\PYG{g+go}{                        Set analyze packet type, ipv4 or ipv6 (default is}
\PYG{g+go}{                        ipv4)}
\PYG{g+go}{  ...}
\end{sphinxVerbatim}


\subsubsection{L3fwd-acl Container}
\label{\detokenize{tools/sppc/app_launcher:l3fwd-acl-container}}\label{\detokenize{tools/sppc/app_launcher:sppc-appl-l3fwd-acl}}
\sphinxhref{https://doc.dpdk.org/guides/sample\_app\_ug/l3\_forward\_access\_ctrl.html}{L3 Forwarding with Access Control}
application is a simple example of packet processing using the DPDK.
The application performs a security check on received packets.
Packets that are in the Access Control List (ACL), which is loaded
during initialization, are dropped. Others are forwarded to the correct
port.

\sphinxcode{\sphinxupquote{app/l3fwd-acl.py}} launches l3fwd-acl on a container.
As similar to \sphinxcode{\sphinxupquote{l3fwd-acl}}, this python script takes several options
other than EAL for port configurations and rules.
The mandatory options for the application are \sphinxcode{\sphinxupquote{-p}} for portmask
and \sphinxcode{\sphinxupquote{-{-}config}} for rx as a set of combination of
\sphinxcode{\sphinxupquote{(port, queue, locre)}}.

Here is an example for launching l3fwd app container with two vhost
interfaces and printed log messages.
There are two rx ports. \sphinxcode{\sphinxupquote{(0,0,1)}} is for queue of port 0 for which
lcore 1 is assigned, and \sphinxcode{\sphinxupquote{(1,0,2)}} is for port 1.
In this case, you should add \sphinxcode{\sphinxupquote{-nq}} option because the number of both
of rx and tx queues are two while the default number of virtio device
is one.
The number of tx queues, is two in this case, is decided to be the same
value as the number of lcores.
In \sphinxcode{\sphinxupquote{-{-}vdev}} option setup in the script, the number of queues is
defined as \sphinxcode{\sphinxupquote{virtio\_...,queues=2,...}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/l3fwd\PYGZhy{}acl.py \PYGZhy{}l \PYG{l+m}{1}\PYGZhy{}2 \PYGZhy{}nq \PYG{l+m}{2} \PYGZhy{}d vhost:1,vhost:2 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}rule\PYGZus{}ipv4\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}./rule\PYGZus{}ipv4.db\PYGZdq{}} \PYGZhy{}\PYGZhy{}rule\PYGZus{}ipv6\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}./rule\PYGZus{}ipv6.db\PYGZdq{}} \PYGZhy{}\PYGZhy{}scalar \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}p 0x03 \PYGZhy{}\PYGZhy{}config\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}(0,0,1),(1,0,2)\PYGZdq{}} \PYGZhy{}fg
\PYG{g+go}{ sudo docker run \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}it \PYGZbs{}}
\PYG{g+go}{ ...}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}vdev virtio\PYGZus{}user1,queues=2,path=/var/run/usvhost1 \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}vdev virtio\PYGZus{}user2,queues=2,path=/var/run/usvhost2 \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}file\PYGZhy{}prefix spp\PYGZhy{}l3fwd\PYGZhy{}container1 \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{} \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}p 0x03 \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}config \PYGZdq{}(0,0,8),(1,0,9)\PYGZdq{} \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}rule\PYGZus{}ipv4=\PYGZdq{}./rule\PYGZus{}ipv4.db\PYGZdq{} \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}rule\PYGZus{}ipv6=\PYGZdq{}./rule\PYGZus{}ipv6.db\PYGZdq{} \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}scalar}
\PYG{g+go}{EAL: Detected 16 lcore(s)}
\PYG{g+go}{EAL: Auto\PYGZhy{}detected process type: PRIMARY}
\PYG{g+go}{EAL: Multi\PYGZhy{}process socket /var/run/.spp\PYGZhy{}l3fwd\PYGZhy{}container1\PYGZus{}unix}
\PYG{g+go}{EAL: Probing VFIO support...}
\PYG{g+go}{soft parse\PYGZhy{}ptype is enabled}
\PYG{g+go}{LPM or EM none selected, default LPM on}
\PYG{g+go}{Initializing port 0 ... Creating queues: nb\PYGZus{}rxq=1 nb\PYGZus{}txq=2...}
\PYG{g+go}{LPM: Adding route 0x01010100 / 24 (0)}
\PYG{g+go}{LPM: Adding route 0x02010100 / 24 (1)}
\PYG{g+go}{LPM: Adding route IPV6 / 48 (0)}
\PYG{g+go}{LPM: Adding route IPV6 / 48 (1)}
\PYG{g+go}{txq=8,0,0 txq=9,1,0}
\PYG{g+go}{Initializing port 1 ... Creating queues: nb\PYGZus{}rxq=1 nb\PYGZus{}txq=2...}

\PYG{g+go}{Initializing rx queues on lcore 8 ... rxq=0,0,0}
\PYG{g+go}{Initializing rx queues on lcore 9 ... rxq=1,0,0}
\PYG{g+go}{...}
\end{sphinxVerbatim}

You can increase lcores more than the number of ports, for instance,
four lcores for two ports.
However, remaining 3rd and 4th lcores do nothing and require
\sphinxcode{\sphinxupquote{-nq 4}} for tx queues.

Refer help for all of options and usges.
It shows options without of EAL and container for simplicity.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/l3fwd\PYGZhy{}acl.py \PYGZhy{}h
\PYG{g+go}{usage: l3fwd\PYGZhy{}acl.py [\PYGZhy{}h] [\PYGZhy{}l CORE\PYGZus{}LIST] [\PYGZhy{}c CORE\PYGZus{}MASK] [\PYGZhy{}m MEM]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem SOCKET\PYGZus{}MEM]}
\PYG{g+go}{                    [\PYGZhy{}b [PCI\PYGZus{}BLACKLIST [PCI\PYGZus{}BLACKLIST ...]]]}
\PYG{g+go}{                    [\PYGZhy{}w [PCI\PYGZus{}WHITELIST [PCI\PYGZus{}WHITELIST ...]]]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}single\PYGZhy{}file\PYGZhy{}segment] [\PYGZhy{}\PYGZhy{}nof\PYGZhy{}memchan NOF\PYGZus{}MEMCHAN]}
\PYG{g+go}{                    [\PYGZhy{}d DEV\PYGZus{}IDS] [\PYGZhy{}nq NOF\PYGZus{}QUEUES] [\PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged]}
\PYG{g+go}{                    [\PYGZhy{}p PORT\PYGZus{}MASK] [\PYGZhy{}\PYGZhy{}config CONFIG] [\PYGZhy{}P]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}rule\PYGZus{}ipv4 RULE\PYGZus{}IPV4] [\PYGZhy{}\PYGZhy{}rule\PYGZus{}ipv6 RULE\PYGZus{}IPV6]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}scalar] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}jumbo]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}max\PYGZhy{}pkt\PYGZhy{}len MAX\PYGZus{}PKT\PYGZus{}LEN] [\PYGZhy{}\PYGZhy{}no\PYGZhy{}numa]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME] [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}workdir WORKDIR] [\PYGZhy{}ci CONTAINER\PYGZus{}IMAGE] [\PYGZhy{}fg]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}dry\PYGZhy{}run]}

\PYG{g+go}{usage: l3fwd\PYGZhy{}acl.py [\PYGZhy{}h] [\PYGZhy{}l CORE\PYGZus{}LIST] [\PYGZhy{}c CORE\PYGZus{}MASK] [\PYGZhy{}m MEM]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}vdev [VDEV [VDEV ...]]] [\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem SOCKET\PYGZus{}MEM]}
\PYG{g+go}{                    [\PYGZhy{}b [PCI\PYGZus{}BLACKLIST [PCI\PYGZus{}BLACKLIST ...]]]}
\PYG{g+go}{                    [\PYGZhy{}w [PCI\PYGZus{}WHITELIST [PCI\PYGZus{}WHITELIST ...]]]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}single\PYGZhy{}file\PYGZhy{}segments] [\PYGZhy{}\PYGZhy{}nof\PYGZhy{}memchan NOF\PYGZus{}MEMCHAN]}
\PYG{g+go}{                    [\PYGZhy{}d DEV\PYGZus{}UIDS] [\PYGZhy{}v [VOLUME [VOLUME ...]]]}
\PYG{g+go}{                    [\PYGZhy{}nq NOF\PYGZus{}QUEUES] [\PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged] [\PYGZhy{}p PORT\PYGZus{}MASK]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}config CONFIG] [\PYGZhy{}P]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}rule\PYGZus{}ipv4 RULE\PYGZus{}IPV4] [\PYGZhy{}\PYGZhy{}rule\PYGZus{}ipv6 RULE\PYGZus{}IPV6]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}scalar] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}jumbo] [\PYGZhy{}\PYGZhy{}max\PYGZhy{}pkt\PYGZhy{}len MAX\PYGZus{}PKT\PYGZus{}LEN]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}no\PYGZhy{}numa] [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME]}
\PYG{g+go}{                    [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER] [\PYGZhy{}\PYGZhy{}workdir WORKDIR] [\PYGZhy{}\PYGZhy{}name NAME]}
\PYG{g+go}{                    [\PYGZhy{}ci CONTAINER\PYGZus{}IMAGE] [\PYGZhy{}fg] [\PYGZhy{}\PYGZhy{}dry\PYGZhy{}run]}

\PYG{g+go}{Launcher for l3fwd\PYGZhy{}acl application container}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  ...}
\PYG{g+go}{  \PYGZhy{}d DEV\PYGZus{}UIDS, \PYGZhy{}\PYGZhy{}dev\PYGZhy{}uids DEV\PYGZus{}UIDS}
\PYG{g+go}{                        Virtual devices of SPP in resource UID format}
\PYG{g+go}{  \PYGZhy{}nq NOF\PYGZus{}QUEUES, \PYGZhy{}\PYGZhy{}nof\PYGZhy{}queues NOF\PYGZus{}QUEUES}
\PYG{g+go}{                        Number of queues of virtio (default is 1)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged       Disable docker\PYGZsq{}s privileged mode if it\PYGZsq{}s needed}
\PYG{g+go}{  \PYGZhy{}p PORT\PYGZus{}MASK, \PYGZhy{}\PYGZhy{}port\PYGZhy{}mask PORT\PYGZus{}MASK}
\PYG{g+go}{                        (Mandatory) Port mask}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}config CONFIG       (Mandatory) Define set of port, queue, lcore for}
\PYG{g+go}{                        ports}
\PYG{g+go}{  \PYGZhy{}P, \PYGZhy{}\PYGZhy{}promiscous      Set all ports to promiscous mode (default is None)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}rule\PYGZus{}ipv4 RULE\PYGZus{}IPV4}
\PYG{g+go}{                        Specifies the IPv4 ACL and route rules file}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}rule\PYGZus{}ipv6 RULE\PYGZus{}IPV6}
\PYG{g+go}{                        Specifies the IPv6 ACL and route rules file}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}scalar              Use a scalar function to perform rule lookup}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}enable\PYGZhy{}jumbo        Enable jumbo frames, [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}jumbo [\PYGZhy{}\PYGZhy{}max\PYGZhy{}pkt\PYGZhy{}len}
\PYG{g+go}{                        PKTLEN]]}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}max\PYGZhy{}pkt\PYGZhy{}len MAX\PYGZus{}PKT\PYGZus{}LEN}
\PYG{g+go}{                        Max packet length (64\PYGZhy{}9600) if jumbo is enabled.}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}numa             Disable NUMA awareness (default is None)}
\PYG{g+go}{  ...}
\end{sphinxVerbatim}


\subsubsection{Testpmd Container}
\label{\detokenize{tools/sppc/app_launcher:testpmd-container}}\label{\detokenize{tools/sppc/app_launcher:sppc-appl-testpmd}}
\sphinxcode{\sphinxupquote{testpmd.py}} is a launcher script for DPDK’s
\sphinxhref{https://dpdk.org/doc/guides/testpmd\_app\_ug/index.html}{testpmd}
application.

It launches \sphinxcode{\sphinxupquote{testpmd}} inside a container with specified
vhost interfaces.

This is an example for launching with three cores (6-8th cores)
and two vhost interfaces.
This example is for launching \sphinxcode{\sphinxupquote{testpmd}} in interactive mode.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/testpmd.py \PYGZhy{}l \PYG{l+m}{6}\PYGZhy{}8 \PYGZhy{}d vhost:1,vhost:2 \PYGZhy{}fg \PYGZhy{}i
\PYG{g+go}{ sudo docker run \PYGZbs{}}
\PYG{g+go}{ ...}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{} \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}interactive}
\PYG{g+go}{ ...}
\PYG{g+go}{Checking link statuses...}
\PYG{g+go}{Done}
\PYG{g+go}{testpmd\PYGZgt{}}
\end{sphinxVerbatim}

Testpmd has many useful options. Please refer to
\sphinxhref{https://dpdk.org/doc/guides/testpmd\_app\_ug/run\_app.html}{Running the Application}
section for instructions.

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{testpmd.py}} does not support all of options of testpmd currently.
You can find all of options with \sphinxcode{\sphinxupquote{-h}} option, but some of them
is not implemented. If you run testpmd with not supported option,
It just prints an error message to mention.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/testpmd.py \PYGZhy{}l \PYG{l+m}{1},2 \PYGZhy{}d vhost:1,vhost:2 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}port\PYGZhy{}topology\PYG{o}{=}chained
\PYG{g+go}{Error: \PYGZsq{}\PYGZhy{}\PYGZhy{}port\PYGZhy{}topology\PYGZsq{} is not supported yet}
\end{sphinxVerbatim}
\end{sphinxadmonition}

Refer help for all of options and usges.
It shows options without of EAL and container.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/testpmd.py \PYGZhy{}h
\PYG{g+go}{usage: testpmd.py [\PYGZhy{}h] [\PYGZhy{}l CORE\PYGZus{}LIST] [\PYGZhy{}c CORE\PYGZus{}MASK] [\PYGZhy{}m MEM]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}vdev [VDEV [VDEV ...]]] [\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem SOCKET\PYGZus{}MEM]}
\PYG{g+go}{                  [\PYGZhy{}b [PCI\PYGZus{}BLACKLIST [PCI\PYGZus{}BLACKLIST ...]]]}
\PYG{g+go}{                  [\PYGZhy{}w [PCI\PYGZus{}WHITELIST [PCI\PYGZus{}WHITELIST ...]]]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}single\PYGZhy{}file\PYGZhy{}segments]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}nof\PYGZhy{}memchan NOF\PYGZus{}MEMCHAN] [\PYGZhy{}d DEV\PYGZus{}UIDS]}
\PYG{g+go}{                  [\PYGZhy{}v [VOLUME [VOLUME ...]]]}
\PYG{g+go}{                  [\PYGZhy{}nq NOF\PYGZus{}QUEUES] [\PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged] [\PYGZhy{}\PYGZhy{}pci] [\PYGZhy{}i] [\PYGZhy{}a]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}tx\PYGZhy{}first] [\PYGZhy{}\PYGZhy{}stats\PYGZhy{}period STATS\PYGZus{}PERIOD]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}nb\PYGZhy{}cores NB\PYGZus{}CORES] [\PYGZhy{}\PYGZhy{}coremask COREMASK]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}portmask PORTMASK] [\PYGZhy{}\PYGZhy{}no\PYGZhy{}numa]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}port\PYGZhy{}numa\PYGZhy{}config PORT\PYGZus{}NUMA\PYGZus{}CONFIG]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}ring\PYGZhy{}numa\PYGZhy{}config RING\PYGZus{}NUMA\PYGZus{}CONFIG]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}socket\PYGZhy{}num SOCKET\PYGZus{}NUM] [\PYGZhy{}\PYGZhy{}mbuf\PYGZhy{}size MBUF\PYGZus{}SIZE]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}total\PYGZhy{}num\PYGZhy{}mbufs TOTAL\PYGZus{}NUM\PYGZus{}MBUFS]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}max\PYGZhy{}pkt\PYGZhy{}len MAX\PYGZus{}PKT\PYGZus{}LEN]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}eth\PYGZhy{}peers\PYGZhy{}configfile ETH\PYGZus{}PEERS\PYGZus{}CONFIGFILE]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}eth\PYGZhy{}peer ETH\PYGZus{}PEER] [\PYGZhy{}\PYGZhy{}pkt\PYGZhy{}filter\PYGZhy{}mode PKT\PYGZus{}FILTER\PYGZus{}MODE]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}pkt\PYGZhy{}filter\PYGZhy{}report\PYGZhy{}hash PKT\PYGZus{}FILTER\PYGZus{}REPORT\PYGZus{}HASH]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}pkt\PYGZhy{}filter\PYGZhy{}size PKT\PYGZus{}FILTER\PYGZus{}SIZE]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}pkt\PYGZhy{}filter\PYGZhy{}flexbytes\PYGZhy{}offset PKT\PYGZus{}FILTER\PYGZus{}FLEXBYTES\PYGZus{}OFFSET]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}pkt\PYGZhy{}filter\PYGZhy{}drop\PYGZhy{}queue PKT\PYGZus{}FILTER\PYGZus{}DROP\PYGZus{}QUEUE]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}disable\PYGZhy{}crc\PYGZhy{}strip] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}lro] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}rx\PYGZhy{}cksum]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}scatter] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}hw\PYGZhy{}vlan]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}hw\PYGZhy{}vlan\PYGZhy{}filter]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}hw\PYGZhy{}vlan\PYGZhy{}strip] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}hw\PYGZhy{}vlan\PYGZhy{}extend]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}drop\PYGZhy{}en] [\PYGZhy{}\PYGZhy{}disable\PYGZhy{}rss]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}port\PYGZhy{}topology PORT\PYGZus{}TOPOLOGY]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}forward\PYGZhy{}mode FORWARD\PYGZus{}MODE] [\PYGZhy{}\PYGZhy{}rss\PYGZhy{}ip] [\PYGZhy{}\PYGZhy{}rss\PYGZhy{}udp]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}rxq RXQ] [\PYGZhy{}\PYGZhy{}rxd RXD] [\PYGZhy{}\PYGZhy{}txq TXQ] [\PYGZhy{}\PYGZhy{}txd TXD]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}burst BURST] [\PYGZhy{}\PYGZhy{}mbcache MBCACHE]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}rxpt RXPT] [\PYGZhy{}\PYGZhy{}rxht RXHT] [\PYGZhy{}\PYGZhy{}rxfreet RXFREET]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}rxwt RXWT] [\PYGZhy{}\PYGZhy{}txpt TXPT] [\PYGZhy{}\PYGZhy{}txht TXHT] [\PYGZhy{}\PYGZhy{}txwt TXWT]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}txfreet TXFREET] [\PYGZhy{}\PYGZhy{}txrst TXRST]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}rx\PYGZhy{}queue\PYGZhy{}stats\PYGZhy{}mapping RX\PYGZus{}QUEUE\PYGZus{}STATS\PYGZus{}MAPPING]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}tx\PYGZhy{}queue\PYGZhy{}stats\PYGZhy{}mapping TX\PYGZus{}QUEUE\PYGZus{}STATS\PYGZus{}MAPPING]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}no\PYGZhy{}flush\PYGZhy{}rx] [\PYGZhy{}\PYGZhy{}txpkts TXPKTS]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}disable\PYGZhy{}link\PYGZhy{}check] [\PYGZhy{}\PYGZhy{}no\PYGZhy{}lsc\PYGZhy{}interrupt]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}no\PYGZhy{}rmv\PYGZhy{}interrupt]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}bitrate\PYGZhy{}stats [BITRATE\PYGZus{}STATS [BITRATE\PYGZus{}STATS ...]]]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}print\PYGZhy{}event PRINT\PYGZus{}EVENT] [\PYGZhy{}\PYGZhy{}mask\PYGZhy{}event MASK\PYGZus{}EVENT]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}flow\PYGZhy{}isolate\PYGZhy{}all] [\PYGZhy{}\PYGZhy{}tx\PYGZhy{}offloads TX\PYGZus{}OFFLOADS]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}hot\PYGZhy{}plug] [\PYGZhy{}\PYGZhy{}vxlan\PYGZhy{}gpe\PYGZhy{}port VXLAN\PYGZus{}GPE\PYGZus{}PORT]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}mlockall] [\PYGZhy{}\PYGZhy{}no\PYGZhy{}mlockall]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME] [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}workdir WORKDIR]}
\PYG{g+go}{                  [\PYGZhy{}\PYGZhy{}name NAME] [\PYGZhy{}ci CONTAINER\PYGZus{}IMAGE] [\PYGZhy{}fg] [\PYGZhy{}\PYGZhy{}dry\PYGZhy{}run]}

\PYG{g+go}{Launcher for testpmd application container}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  ...}
\PYG{g+go}{  \PYGZhy{}d DEV\PYGZus{}UIDS, \PYGZhy{}\PYGZhy{}dev\PYGZhy{}uids DEV\PYGZus{}UIDS}
\PYG{g+go}{                        Virtual devices of SPP in resource UID format}
\PYG{g+go}{  \PYGZhy{}nq NOF\PYGZus{}QUEUES, \PYGZhy{}\PYGZhy{}nof\PYGZhy{}queues NOF\PYGZus{}QUEUES}
\PYG{g+go}{                        Number of queues of virtio (default is 1)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged       Disable docker\PYGZsq{}s privileged mode if it\PYGZsq{}s needed}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}pci                 Enable PCI (default is None)}
\PYG{g+go}{  \PYGZhy{}i, \PYGZhy{}\PYGZhy{}interactive     Run in interactive mode (default is None)}
\PYG{g+go}{  \PYGZhy{}a, \PYGZhy{}\PYGZhy{}auto\PYGZhy{}start      Start forwarding on initialization (default ...)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}tx\PYGZhy{}first            Start forwarding, after sending a burst of packets}
\PYG{g+go}{                        first}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}stats\PYGZhy{}period STATS\PYGZus{}PERIOD}
\PYG{g+go}{                        Period of displaying stats, if interactive is}
\PYG{g+go}{                        disabled}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}nb\PYGZhy{}cores NB\PYGZus{}CORES   Number of forwarding cores}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}coremask COREMASK   Hexadecimal bitmask of the cores, do not include}
\PYG{g+go}{                        master lcore}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}portmask PORTMASK   Hexadecimal bitmask of the ports}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}numa             Disable NUMA\PYGZhy{}aware allocation of RX/TX rings and RX}
\PYG{g+go}{                        mbuf}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}port\PYGZhy{}numa\PYGZhy{}config PORT\PYGZus{}NUMA\PYGZus{}CONFIG}
\PYG{g+go}{                        Specify port allocation as}
\PYG{g+go}{                        (port,socket)[,(port,socket)]}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}ring\PYGZhy{}numa\PYGZhy{}config RING\PYGZus{}NUMA\PYGZus{}CONFIG}
\PYG{g+go}{                        Specify ring allocation as}
\PYG{g+go}{                        (port,flag,socket)[,(port,flag,socket)]}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}socket\PYGZhy{}num SOCKET\PYGZus{}NUM}
\PYG{g+go}{                        Socket from which all memory is allocated in NUMA}
\PYG{g+go}{                        mode}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}mbuf\PYGZhy{}size MBUF\PYGZus{}SIZE}
\PYG{g+go}{                        Size of mbufs used to N (\PYGZlt{} 65536) bytes (default is}
\PYG{g+go}{                        2048)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}total\PYGZhy{}num\PYGZhy{}mbufs TOTAL\PYGZus{}NUM\PYGZus{}MBUFS}
\PYG{g+go}{                        Number of mbufs allocated in mbuf pools, N \PYGZgt{} 1024.}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}max\PYGZhy{}pkt\PYGZhy{}len MAX\PYGZus{}PKT\PYGZus{}LEN}
\PYG{g+go}{                        Maximum packet size to N (\PYGZgt{}= 64) bytes (default is}
\PYG{g+go}{                        1518)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}eth\PYGZhy{}peers\PYGZhy{}configfile ETH\PYGZus{}PEERS\PYGZus{}CONFIGFILE}
\PYG{g+go}{                        Config file of Ether addrs of the peer ports}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}eth\PYGZhy{}peer ETH\PYGZus{}PEER   Set MAC addr of port N as \PYGZsq{}N,XX:XX:XX:XX:XX:XX\PYGZsq{}}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}pkt\PYGZhy{}filter\PYGZhy{}mode PKT\PYGZus{}FILTER\PYGZus{}MODE}
\PYG{g+go}{                        Flow Director mode, \PYGZsq{}none\PYGZsq{}(default), \PYGZsq{}signature\PYGZsq{} or}
\PYG{g+go}{                        \PYGZsq{}perfect\PYGZsq{}}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}pkt\PYGZhy{}filter\PYGZhy{}report\PYGZhy{}hash PKT\PYGZus{}FILTER\PYGZus{}REPORT\PYGZus{}HASH}
\PYG{g+go}{                        Flow Director hash match mode, \PYGZsq{}none\PYGZsq{},}
\PYG{g+go}{                        \PYGZsq{}match\PYGZsq{}(default) or \PYGZsq{}always\PYGZsq{}}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}pkt\PYGZhy{}filter\PYGZhy{}size PKT\PYGZus{}FILTER\PYGZus{}SIZE}
\PYG{g+go}{                        Flow Director memory size (\PYGZsq{}64K\PYGZsq{}, \PYGZsq{}128K\PYGZsq{}, \PYGZsq{}256K\PYGZsq{}).}
\PYG{g+go}{                        The default is 64K.}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}pkt\PYGZhy{}filter\PYGZhy{}flexbytes\PYGZhy{}offset PKT\PYGZus{}FILTER\PYGZus{}FLEXBYTES\PYGZus{}OFFSET}
\PYG{g+go}{                        Flexbytes offset (0\PYGZhy{}32, default is 0x6) defined in}
\PYG{g+go}{                        words counted from the first byte of the dest MAC}
\PYG{g+go}{                        address}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}pkt\PYGZhy{}filter\PYGZhy{}drop\PYGZhy{}queue PKT\PYGZus{}FILTER\PYGZus{}DROP\PYGZus{}QUEUE}
\PYG{g+go}{                        Set the drop\PYGZhy{}queue (default is 127)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}disable\PYGZhy{}crc\PYGZhy{}strip   Disable hardware CRC stripping}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}enable\PYGZhy{}lro          Enable large receive offload}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}enable\PYGZhy{}rx\PYGZhy{}cksum     Enable hardware RX checksum offload}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}enable\PYGZhy{}scatter      Enable scatter (multi\PYGZhy{}segment) RX}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}enable\PYGZhy{}hw\PYGZhy{}vlan      Enable hardware vlan (default is None)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}enable\PYGZhy{}hw\PYGZhy{}vlan\PYGZhy{}filter}
\PYG{g+go}{                        Enable hardware VLAN filter}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}enable\PYGZhy{}hw\PYGZhy{}vlan\PYGZhy{}strip}
\PYG{g+go}{                        Enable hardware VLAN strip}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}enable\PYGZhy{}hw\PYGZhy{}vlan\PYGZhy{}extend}
\PYG{g+go}{                        Enable hardware VLAN extend}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}enable\PYGZhy{}drop\PYGZhy{}en      Enable per\PYGZhy{}queue packet drop if no descriptors}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}disable\PYGZhy{}rss         Disable RSS (Receive Side Scaling}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}port\PYGZhy{}topology PORT\PYGZus{}TOPOLOGY}
\PYG{g+go}{                        Port topology, \PYGZsq{}paired\PYGZsq{} (the default) or \PYGZsq{}chained\PYGZsq{}}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}forward\PYGZhy{}mode FORWARD\PYGZus{}MODE}
\PYG{g+go}{                        Forwarding mode, \PYGZsq{}io\PYGZsq{} (default), \PYGZsq{}mac\PYGZsq{}, \PYGZsq{}mac\PYGZus{}swap\PYGZsq{},}
\PYG{g+go}{                        \PYGZsq{}flowgen\PYGZsq{}, \PYGZsq{}rxonly\PYGZsq{}, \PYGZsq{}txonly\PYGZsq{}, \PYGZsq{}csum\PYGZsq{}, \PYGZsq{}icmpecho\PYGZsq{},}
\PYG{g+go}{                        \PYGZsq{}ieee1588\PYGZsq{}, \PYGZsq{}tm\PYGZsq{}}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}rss\PYGZhy{}ip              Set RSS functions for IPv4/IPv6 only}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}rss\PYGZhy{}udp             Set RSS functions for IPv4/IPv6 and UDP}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}rxq RXQ             Number of RX queues per port, 1\PYGZhy{}65535 (default ...)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}rxd RXD             Number of descriptors in the RX rings}
\PYG{g+go}{                        (default is 128)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}txq TXQ             Number of TX queues per port, 1\PYGZhy{}65535 (default ...)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}txd TXD             Number of descriptors in the TX rings}
\PYG{g+go}{                        (default is 512)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}burst BURST         Number of packets per burst, 1\PYGZhy{}512 (default is 32)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}mbcache MBCACHE     Cache of mbuf memory pools, 0\PYGZhy{}512 (default is 16)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}rxpt RXPT           Prefetch threshold register of RX rings}
\PYG{g+go}{                        (default is 8)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}rxht RXHT           Host threshold register of RX rings (default is 8)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}rxfreet RXFREET     Free threshold of RX descriptors,0\PYGZhy{}\PYGZsq{}rxd\PYGZsq{} (...)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}rxwt RXWT           Write\PYGZhy{}back threshold register of RX rings}
\PYG{g+go}{                        (default is 4)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}txpt TXPT           Prefetch threshold register of TX rings (...)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}txht TXHT           Host threshold register of TX rings (default is 0)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}txwt TXWT           Write\PYGZhy{}back threshold register of TX rings (...)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}txfreet TXFREET     Free threshold of RX descriptors, 0\PYGZhy{}\PYGZsq{}txd\PYGZsq{} (...)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}txrst TXRST         Transmit RS bit threshold of TX rings, 0\PYGZhy{}\PYGZsq{}txd\PYGZsq{}}
\PYG{g+go}{                        (default is 0)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}rx\PYGZhy{}queue\PYGZhy{}stats\PYGZhy{}mapping RX\PYGZus{}QUEUE\PYGZus{}STATS\PYGZus{}MAPPING}
\PYG{g+go}{                        RX queues statistics counters mapping 0\PYGZhy{}15 as}
\PYG{g+go}{                        \PYGZsq{}(port,queue,mapping)[,(port,queue,mapping)]\PYGZsq{}}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}tx\PYGZhy{}queue\PYGZhy{}stats\PYGZhy{}mapping TX\PYGZus{}QUEUE\PYGZus{}STATS\PYGZus{}MAPPING}
\PYG{g+go}{                        TX queues statistics counters mapping 0\PYGZhy{}15 as}
\PYG{g+go}{                        \PYGZsq{}(port,queue,mapping)[,(port,queue,mapping)]\PYGZsq{}}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}flush\PYGZhy{}rx         Don’t flush the RX streams before starting}
\PYG{g+go}{                        forwarding, Used mainly with the PCAP PMD}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}txpkts TXPKTS       TX segment sizes or total packet length, Valid for}
\PYG{g+go}{                        tx\PYGZhy{}only and flowgen}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}disable\PYGZhy{}link\PYGZhy{}check  Disable check on link status when starting/stopping}
\PYG{g+go}{                        ports}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}lsc\PYGZhy{}interrupt    Disable LSC interrupts for all ports}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}rmv\PYGZhy{}interrupt    Disable RMV interrupts for all ports}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}bitrate\PYGZhy{}stats [BITRATE\PYGZus{}STATS [BITRATE\PYGZus{}STATS ...]]}
\PYG{g+go}{                        Logical core N to perform bitrate calculation}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}print\PYGZhy{}event PRINT\PYGZus{}EVENT}
\PYG{g+go}{                        Enable printing the occurrence of the designated}
\PYG{g+go}{                        event, \PYGZlt{}unknown\textbar{}intr\PYGZus{}lsc\textbar{}queue\PYGZus{}state\textbar{}intr\PYGZus{}reset\textbar{}}
\PYG{g+go}{                        vf\PYGZus{}mbox\textbar{}macsec\textbar{}intr\PYGZus{}rmv\textbar{}dev\PYGZus{}probed\textbar{}dev\PYGZus{}released\textbar{}}
\PYG{g+go}{                        all\PYGZgt{}}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}mask\PYGZhy{}event MASK\PYGZus{}EVENT}
\PYG{g+go}{                        Disable printing the occurrence of the designated}
\PYG{g+go}{                        event, \PYGZlt{}unknown\textbar{}intr\PYGZus{}lsc\textbar{}queue\PYGZus{}state\textbar{}intr\PYGZus{}reset\textbar{}}
\PYG{g+go}{                        vf\PYGZus{}mbox\textbar{}macsec\textbar{}intr\PYGZus{}rmv\textbar{}dev\PYGZus{}probed\textbar{}dev\PYGZus{}released\textbar{}}
\PYG{g+go}{                        all\PYGZgt{}}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}flow\PYGZhy{}isolate\PYGZhy{}all    Providing this parameter requests flow API isolated}
\PYG{g+go}{                        mode on all ports at initialization time}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}tx\PYGZhy{}offloads TX\PYGZus{}OFFLOADS}
\PYG{g+go}{                        Hexadecimal bitmask of TX queue offloads (default}
\PYG{g+go}{                        is 0)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}hot\PYGZhy{}plug            Enable device event monitor machenism for hotplug}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}vxlan\PYGZhy{}gpe\PYGZhy{}port VXLAN\PYGZus{}GPE\PYGZus{}PORT}
\PYG{g+go}{                        UDP port number of tunnel VXLAN\PYGZhy{}GPE (default is}
\PYG{g+go}{                        4790)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}mlockall            Enable locking all memory}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}mlockall         Disable locking all memory}
\PYG{g+go}{  ...}
\end{sphinxVerbatim}


\subsubsection{Pktgen-dpdk Container}
\label{\detokenize{tools/sppc/app_launcher:pktgen-dpdk-container}}\label{\detokenize{tools/sppc/app_launcher:sppc-appl-pktgen}}
\sphinxcode{\sphinxupquote{pktgen.py}} is a launcher script for
\sphinxhref{http://pktgen-dpdk.readthedocs.io/en/latest/index.html}{pktgen-dpdk}.
Pktgen is a software based traffic generator powered by the DPDK
fast packet processing framework.
It is not only high-performance for generating 10GB traffic with
64 byte frames, but also very configurable to handle packets with
UDP, TCP, ARP, ICMP, GRE, MPLS and Queue-in-Queue.
It also supports
\sphinxhref{https://www.lua.org/}{Lua}
for detailed configurations.

This \sphinxcode{\sphinxupquote{pktgen.py}} script launches \sphinxcode{\sphinxupquote{pktgen}} app container
with specified vhost interfaces.
Here is an example for launching with seven lcores (8-14th)
and three vhost interfaces.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/pktgen.py \PYGZhy{}l \PYG{l+m}{8}\PYGZhy{}14 \PYGZhy{}d vhost:1,vhost:2,vhost:3 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}fg
\PYG{g+go}{ sudo docker run \PYGZbs{}}
\PYG{g+go}{ ...}
\PYG{g+go}{ sppc/pktgen\PYGZhy{}ubuntu:latest \PYGZbs{}}
\PYG{g+go}{ /root/dpdk/../pktgen\PYGZhy{}dpdk/app/x86\PYGZus{}64\PYGZhy{}native\PYGZhy{}linuxapp\PYGZhy{}gcc/pktgen \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}l 8\PYGZhy{}14 \PYGZbs{}}
\PYG{g+go}{ ...}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{} \PYGZbs{}}
\PYG{g+go}{ \PYGZhy{}m [9:10].0,[11:12].1,[13:14].2}
\PYG{g+go}{ ...}
\end{sphinxVerbatim}

You notice that given lcores \sphinxcode{\sphinxupquote{-l 8-14}} are assigned appropriately.
Lcore 8 is used as master and remaining six lcores are use to worker
threads for three ports as \sphinxcode{\sphinxupquote{-m {[}9:10{]}.0,{[}11:12{]}.1,{[}13:14{]}.2}} equally.
If the number of given lcores is larger than required,
remained lcores are simply not used.

Calculation of core assignment of \sphinxcode{\sphinxupquote{pktgen.py}} currently is supporting
up to four lcores for each of ports.
If you assign fire or more lcores to a port, \sphinxcode{\sphinxupquote{pktgen.py}} terminates
to launch app container.
It is because a usecase more than four lcores is rare and
calculation is to be complicated.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Assign five lcores \PYG{k}{for} a slave is failed to launch
\PYG{g+gp}{\PYGZdl{}} python3 app/pktgen.py \PYGZhy{}l \PYG{l+m}{6}\PYGZhy{}11 \PYGZhy{}d vhost:1
\PYG{g+go}{Error: Too many cores for calculation for port assignment!}
\PYG{g+go}{Please consider to use \PYGZsq{}\PYGZhy{}\PYGZhy{}matrix\PYGZsq{} for assigning directly}
\end{sphinxVerbatim}

Here are other examples of lcore assignment of \sphinxcode{\sphinxupquote{pktgen.py}} to help
your understanding.

\sphinxstylestrong{1. Three lcores for two ports}

Assign one lcore to master and two lcores two slaves for two ports.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/pktgen.py \PYGZhy{}l \PYG{l+m}{6}\PYGZhy{}8 \PYGZhy{}d vhost:1,vhost:2
\PYG{g+go}{ ...}
\PYG{g+go}{ \PYGZhy{}m 7.0,8.1 \PYGZbs{}}
\end{sphinxVerbatim}

\sphinxstylestrong{2. Seven lcores for three ports}

Assign one lcore for master and each of two lcores to
three slaves for three ports.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/pktgen.py \PYGZhy{}l \PYG{l+m}{6}\PYGZhy{}12 \PYGZhy{}d vhost:1,vhost:2,vhost:3
\PYG{g+go}{ ...}
\PYG{g+go}{ \PYGZhy{}m [7:8].0,[9:10].1,[11:12].2 \PYGZbs{}}
\end{sphinxVerbatim}

\sphinxstylestrong{3. Seven lcores for two ports}

Assign one lcore for master and each of three lcores to
two slaves for two ports.
In this case, each of three lcores cannot be assigned rx and tx port
equally, so given two lcores to rx and one core to tx.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/pktgen.py \PYGZhy{}l \PYG{l+m}{6}\PYGZhy{}12 \PYGZhy{}d vhost:1,vhost:2
\PYG{g+go}{ ...}
\PYG{g+go}{ \PYGZhy{}m [7\PYGZhy{}8:9].0,[10\PYGZhy{}11:12].1 \PYGZbs{}}
\end{sphinxVerbatim}

Refer help for all of options and usges.
It shows options without of EAL and container for simplicity.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/pktgen.py \PYGZhy{}h
\PYG{g+go}{usage: pktgen.py [\PYGZhy{}h] [\PYGZhy{}l CORE\PYGZus{}LIST] [\PYGZhy{}c CORE\PYGZus{}MASK] [\PYGZhy{}m MEM]}
\PYG{g+go}{                 [\PYGZhy{}\PYGZhy{}vdev [VDEV [VDEV ...]]] [\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem SOCKET\PYGZus{}MEM]}
\PYG{g+go}{                 [\PYGZhy{}b [PCI\PYGZus{}BLACKLIST [PCI\PYGZus{}BLACKLIST ...]]]}
\PYG{g+go}{                 [\PYGZhy{}w [PCI\PYGZus{}WHITELIST [PCI\PYGZus{}WHITELIST ...]]]}
\PYG{g+go}{                 [\PYGZhy{}\PYGZhy{}single\PYGZhy{}file\PYGZhy{}segments] [\PYGZhy{}\PYGZhy{}nof\PYGZhy{}memchan NOF\PYGZus{}MEMCHAN]}
\PYG{g+go}{                 [\PYGZhy{}d DEV\PYGZus{}UIDS] [\PYGZhy{}v [VOLUME [VOLUME ...]]]}
\PYG{g+go}{                 [\PYGZhy{}nq NOF\PYGZus{}QUEUES] [\PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged] [\PYGZhy{}s PCAP\PYGZus{}FILE]}
\PYG{g+go}{                 [\PYGZhy{}f SCRIPT\PYGZus{}FILE]}
\PYG{g+go}{                 [\PYGZhy{}lf LOG\PYGZus{}FILE] [\PYGZhy{}P] [\PYGZhy{}G] [\PYGZhy{}g SOCK\PYGZus{}ADDRESS] [\PYGZhy{}T] [\PYGZhy{}N]}
\PYG{g+go}{                 [\PYGZhy{}\PYGZhy{}matrix MATRIX] [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME]}
\PYG{g+go}{                 [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER]}
\PYG{g+go}{                 [\PYGZhy{}\PYGZhy{}workdir WORKDIR] [\PYGZhy{}\PYGZhy{}name NAME] [\PYGZhy{}ci CONTAINER\PYGZus{}IMAGE]}
\PYG{g+go}{                 [\PYGZhy{}fg] [\PYGZhy{}\PYGZhy{}dry\PYGZhy{}run]}

\PYG{g+go}{Launcher for pktgen\PYGZhy{}dpdk application container}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  ...}
\PYG{g+go}{  \PYGZhy{}d DEV\PYGZus{}UIDS, \PYGZhy{}\PYGZhy{}dev\PYGZhy{}uids DEV\PYGZus{}UIDS}
\PYG{g+go}{                        Virtual devices of SPP in resource UID format}
\PYG{g+go}{  \PYGZhy{}nq NOF\PYGZus{}QUEUES, \PYGZhy{}\PYGZhy{}nof\PYGZhy{}queues NOF\PYGZus{}QUEUES}
\PYG{g+go}{                        Number of queues of virtio (default is 1)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged       Disable docker\PYGZsq{}s privileged mode if it\PYGZsq{}s needed}
\PYG{g+go}{  \PYGZhy{}s PCAP\PYGZus{}FILE, \PYGZhy{}\PYGZhy{}pcap\PYGZhy{}file PCAP\PYGZus{}FILE}
\PYG{g+go}{                        PCAP packet flow file of port, defined as}
\PYG{g+go}{                        \PYGZsq{}N:filename\PYGZsq{}}
\PYG{g+go}{  \PYGZhy{}f SCRIPT\PYGZus{}FILE, \PYGZhy{}\PYGZhy{}script\PYGZhy{}file SCRIPT\PYGZus{}FILE}
\PYG{g+go}{                        Pktgen script (.pkt) to or a Lua script (.lua)}
\PYG{g+go}{  \PYGZhy{}lf LOG\PYGZus{}FILE, \PYGZhy{}\PYGZhy{}log\PYGZhy{}file LOG\PYGZus{}FILE}
\PYG{g+go}{                        Filename to write a log, as \PYGZsq{}\PYGZhy{}l\PYGZsq{} of pktgen}
\PYG{g+go}{  \PYGZhy{}P, \PYGZhy{}\PYGZhy{}promiscuous     Enable PROMISCUOUS mode on all ports}
\PYG{g+go}{  \PYGZhy{}G, \PYGZhy{}\PYGZhy{}sock\PYGZhy{}default    Enable socket support using default server values}
\PYG{g+go}{                        of localhost:0x5606}
\PYG{g+go}{  \PYGZhy{}g SOCK\PYGZus{}ADDRESS, \PYGZhy{}\PYGZhy{}sock\PYGZhy{}address SOCK\PYGZus{}ADDRESS}
\PYG{g+go}{                        Same as \PYGZhy{}G but with an optional IP address and port}
\PYG{g+go}{                        number}
\PYG{g+go}{  \PYGZhy{}T, \PYGZhy{}\PYGZhy{}term\PYGZhy{}color      Enable color terminal output in VT100}
\PYG{g+go}{  \PYGZhy{}N, \PYGZhy{}\PYGZhy{}numa            Enable NUMA support}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}matrix MATRIX       Matrix of cores and port as \PYGZsq{}\PYGZhy{}m\PYGZsq{} of pktgen, such as}
\PYG{g+go}{                        [1:2].0 or 1.0}
\PYG{g+go}{  ...}
\end{sphinxVerbatim}


\subsubsection{Load-Balancer Container}
\label{\detokenize{tools/sppc/app_launcher:load-balancer-container}}\label{\detokenize{tools/sppc/app_launcher:sppc-appl-load-balancer}}
\sphinxhref{https://dpdk.org/doc/guides/sample\_app\_ug/load\_balancer.html}{Load-Balancer}
is an application distributes packet I/O task with several worker
lcores to share IP addressing.

There are three types of lcore roles in this application, rx, tx and
worker lcores. Rx lcores retrieve packets from NICs and Tx lcores
send it to the destinations.
Worker lcores intermediate them, receive packets from rx lcores,
classify by looking up the address and send it to each of destination
tx lcores.
Each of lcores has a set of references of lcore ID and queue
as described in \sphinxhref{https://dpdk.org/doc/guides/sample\_app\_ug/load\_balancer.html\#explanation}{Application Configuration}.

\sphinxcode{\sphinxupquote{load-balancer.py}} expects four mandatory options.
\begin{itemize}
\item {} 
-rx: “(PORT, QUEUE, LCORE), …”, list of NIC RX ports and
queues handled by the I/O RX lcores. This parameter also implicitly
defines the list of I/O RX lcores.

\item {} 
-tx: “(PORT, LCORE), …”, list of NIC TX ports handled by
the I/O TX lcores. This parameter also implicitly defines the list
of I/O TX lcores.

\item {} 
-w: The list of the worker lcores.

\item {} 
\textendash{}lpm: “IP / PREFIX =\textgreater{} PORT”, list of LPM rules used by the worker
lcores for packet forwarding.

\end{itemize}

Here is an example for one rx, one tx and two worker on lcores 8-10.
Both of rx and rx is assinged to the same lcore 8.
It receives packets from port 0 and forwards it port 0 or 1.
The destination port is defined as \sphinxcode{\sphinxupquote{-{-}lpm}} option.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/load\PYGZhy{}balancer.py \PYGZhy{}fg \PYGZhy{}l \PYG{l+m}{8}\PYGZhy{}10  \PYGZhy{}d vhost:1,vhost:2 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}rx \PYG{l+s+s2}{\PYGZdq{}(0,0,8)\PYGZdq{}} \PYGZhy{}tx \PYG{l+s+s2}{\PYGZdq{}(0,8),(1,8)\PYGZdq{}} \PYGZhy{}w \PYG{l+m}{9},10 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}lpm \PYG{l+s+s2}{\PYGZdq{}1.0.0.0/24=\PYGZgt{}0; 1.0.1.0/24=\PYGZgt{}1;\PYGZdq{}}
\end{sphinxVerbatim}

If you are succeeded to launch the app container,
it shows details of rx, tx, worker lcores and LPM rules
, and starts forwarding.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{...}
\PYG{g+go}{Checking link statusdone}
\PYG{g+go}{Port0 Link Up \PYGZhy{} speed 10000Mbps \PYGZhy{} full\PYGZhy{}duplex}
\PYG{g+go}{Port1 Link Up \PYGZhy{} speed 10000Mbps \PYGZhy{} full\PYGZhy{}duplex}
\PYG{g+go}{Initialization completed.}
\PYG{g+go}{NIC RX ports: 0 (0 )  ;}
\PYG{g+go}{I/O lcore 8 (socket 0): RX ports  (0, 0)  ; Output rings  0x7f9af7347...}
\PYG{g+go}{Worker lcore 9 (socket 0) ID 0: Input rings  0x7f9af7347880  ;}
\PYG{g+go}{Worker lcore 10 (socket 0) ID 1: Input rings  0x7f9af7345680  ;}

\PYG{g+go}{NIC TX ports:  0  1  ;}
\PYG{g+go}{I/O lcore 8 (socket 0): Input rings per TX port  0 (0x7f9af7343480 ...}
\PYG{g+go}{Worker lcore 9 (socket 0) ID 0:}
\PYG{g+go}{Output rings per TX port  0 (0x7f9af7343480)  1 (0x7f9af7341280)  ;}
\PYG{g+go}{Worker lcore 10 (socket 0) ID 1:}
\PYG{g+go}{Output rings per TX port  0 (0x7f9af733f080)  1 (0x7f9af733ce80)  ;}
\PYG{g+go}{LPM rules:}
\PYG{g+go}{    0: 1.0.0.0/24 =\PYGZgt{} 0;}
\PYG{g+go}{    1: 1.0.1.0/24 =\PYGZgt{} 1;}
\PYG{g+go}{Ring sizes: NIC RX = 1024; Worker in = 1024; Worker out = 1024; NIC TX...}
\PYG{g+go}{Burst sizes: I/O RX (rd = 144, wr = 144); Worker (rd = 144, wr = 144);...}
\PYG{g+go}{Logical core 9 (worker 0) main loop.}
\PYG{g+go}{Logical core 10 (worker 1) main loop.}
\PYG{g+go}{Logical core 8 (I/O) main loop.}
\end{sphinxVerbatim}

To stop forwarding, you need to terminate the application
but might not able to with \sphinxstyleemphasis{Ctrl-C}.
In this case, you can use \sphinxcode{\sphinxupquote{docker kill}} command to terminate it.
Find the name of container on which \sphinxcode{\sphinxupquote{load\_balancer}} is running
and kill it.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} docker ps
\PYG{g+go}{CONTAINER ID  IMAGE                   ...  NAMES}
\PYG{g+go}{80ce3711b85e  sppc/dpdk\PYGZhy{}ubuntu:latest ...  competent\PYGZus{}galileo  \PYGZsh{} kill it}
\PYG{g+go}{281aa8f236ef  sppc/spp\PYGZhy{}ubuntu:latest  ...  youthful\PYGZus{}mcnulty}
\PYG{g+gp}{\PYGZdl{}} docker \PYG{n+nb}{kill} competent\PYGZus{}galileo
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
You shold care about the number of worker lcores. If you add lcore 11
and assign it for third worker thread,
it is failed to lauhch the application.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{...}
\PYG{g+go}{EAL: Probing VFIO support...}
\PYG{g+go}{Incorrect value for \PYGZhy{}\PYGZhy{}w argument (\PYGZhy{}8)}

\PYG{g+go}{    load\PYGZus{}balancer \PYGZlt{}EAL PARAMS\PYGZgt{} \PYGZhy{}\PYGZhy{} \PYGZlt{}APP PARAMS\PYGZgt{}}

\PYG{g+go}{Application manadatory parameters:}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}rx \PYGZdq{}(PORT, QUEUE, LCORE), ...\PYGZdq{} : List of NIC RX ports and queues}
\PYG{g+go}{           handled by the I/O RX lcores}
\PYG{g+go}{...}
\end{sphinxVerbatim}

The reason is the number of lcore is considered as invalid in
\sphinxcode{\sphinxupquote{parse\_arg\_w()}} as below.
\sphinxcode{\sphinxupquote{n\_tuples}} is the number of lcores and it should be
\sphinxtitleref{2\textasciicircum{}n}, or returned with error code.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+c1}{// Defined in dpdk/examples/load\PYGZus{}balancer/config.c}
\PYG{k}{static} \PYG{k+kt}{int}
\PYG{n+nf}{parse\PYGZus{}arg\PYGZus{}w}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{arg}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{n}{arg}\PYG{p}{;}
        \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{n\PYGZus{}tuples}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
        \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}tuples} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{n\PYGZus{}tuples} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}
\end{sphinxadmonition}

Here are other examples.

\sphinxstylestrong{1. Separate rx and tx lcores}

Use four lcores 8-11 for rx, tx and two worker threads.
The number of ports is same as the previous example.
You notice that rx and tx have different lcore number, 8 and 9.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/load\PYGZhy{}balancer.py \PYGZhy{}fg \PYGZhy{}l \PYG{l+m}{8}\PYGZhy{}11 \PYGZhy{}d vhost:1,vhost:2 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}rx \PYG{l+s+s2}{\PYGZdq{}(0,0,8)\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}tx \PYG{l+s+s2}{\PYGZdq{}(0,9),(1,9)\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}w \PYG{l+m}{10},11 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}lpm \PYG{l+s+s2}{\PYGZdq{}1.0.0.0/24=\PYGZgt{}0; 1.0.1.0/24=\PYGZgt{}1;\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxstylestrong{2. Assign multiple queues for rx}

To classify for three destination ports, use one rx lcore,
three tx lcores and four worker lcores.
In this case, rx has two queues and using \sphinxcode{\sphinxupquote{-nq 2}}.
You should start queue ID from 0 and to be in serial as \sphinxtitleref{0,1,2,…},
or failed to launch.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/load\PYGZhy{}balancer.py \PYGZhy{}fg \PYGZhy{}l \PYG{l+m}{8}\PYGZhy{}13 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d vhost:1,vhost:2,vhost:3 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}nq \PYG{l+m}{2} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}rx \PYG{l+s+s2}{\PYGZdq{}(0,0,8),(0,1,8)\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}tx \PYG{l+s+s2}{\PYGZdq{}(0,9),(1,9),(2,9)\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}w \PYG{l+m}{10},11,12,13 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}lpm \PYG{l+s+s2}{\PYGZdq{}1.0.0.0/24=\PYGZgt{}0; 1.0.1.0/24=\PYGZgt{}1; 1.0.2.0/24=\PYGZgt{}2;\PYGZdq{}}
\end{sphinxVerbatim}

Refer options and usages by \sphinxcode{\sphinxupquote{load-balancer.py -h}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/load\PYGZhy{}balancer.py \PYGZhy{}h
\PYG{g+go}{usage: load\PYGZhy{}balancer.py [\PYGZhy{}h] [\PYGZhy{}l CORE\PYGZus{}LIST] [\PYGZhy{}c CORE\PYGZus{}MASK] [\PYGZhy{}m MEM]}
\PYG{g+go}{                        [\PYGZhy{}\PYGZhy{}vdev [VDEV [VDEV ...]]]}
\PYG{g+go}{                        [\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem SOCKET\PYGZus{}MEM]}
\PYG{g+go}{                        [\PYGZhy{}b [PCI\PYGZus{}BLACKLIST [PCI\PYGZus{}BLACKLIST ...]]]}
\PYG{g+go}{                        [\PYGZhy{}w [PCI\PYGZus{}WHITELIST [PCI\PYGZus{}WHITELIST ...]]]}
\PYG{g+go}{                        [\PYGZhy{}\PYGZhy{}single\PYGZhy{}file\PYGZhy{}segments]}
\PYG{g+go}{                        [\PYGZhy{}\PYGZhy{}nof\PYGZhy{}memchan NOF\PYGZus{}MEMCHAN]}
\PYG{g+go}{                        [\PYGZhy{}d DEV\PYGZus{}UIDS] [\PYGZhy{}v [VOLUME [VOLUME ...]]]}
\PYG{g+go}{                        [\PYGZhy{}nq NOF\PYGZus{}QUEUES] [\PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged]}
\PYG{g+go}{                        [\PYGZhy{}rx RX\PYGZus{}PORTS] [\PYGZhy{}tx TX\PYGZus{}PORTS] [\PYGZhy{}wl WORKER\PYGZus{}LCORES]}
\PYG{g+go}{                        [\PYGZhy{}rsz RING\PYGZus{}SIZES] [\PYGZhy{}bsz BURST\PYGZus{}SIZES]}
\PYG{g+go}{                        [\PYGZhy{}\PYGZhy{}lpm LPM] [\PYGZhy{}\PYGZhy{}pos\PYGZhy{}lb POS\PYGZus{}LB]}
\PYG{g+go}{                        [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME] [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER]}
\PYG{g+go}{                        [\PYGZhy{}\PYGZhy{}workdir WORKDIR] [\PYGZhy{}\PYGZhy{}name NAME]}
\PYG{g+go}{                        [\PYGZhy{}ci CONTAINER\PYGZus{}IMAGE] [\PYGZhy{}fg] [\PYGZhy{}\PYGZhy{}dry\PYGZhy{}run]}

\PYG{g+go}{Launcher for load\PYGZhy{}balancer application container}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  ...}
\PYG{g+go}{  \PYGZhy{}d DEV\PYGZus{}UIDS, \PYGZhy{}\PYGZhy{}dev\PYGZhy{}uids DEV\PYGZus{}UIDS}
\PYG{g+go}{                        Virtual devices of SPP in resource UID format}
\PYG{g+go}{  \PYGZhy{}nq NOF\PYGZus{}QUEUES, \PYGZhy{}\PYGZhy{}nof\PYGZhy{}queues NOF\PYGZus{}QUEUES}
\PYG{g+go}{                        Number of queues of virtio (default is 1)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged       Disable docker\PYGZsq{}s privileged mode if it\PYGZsq{}s needed}
\PYG{g+go}{  \PYGZhy{}rx RX\PYGZus{}PORTS, \PYGZhy{}\PYGZhy{}rx\PYGZhy{}ports RX\PYGZus{}PORTS}
\PYG{g+go}{                        List of rx ports and queues handled by the I/O rx}
\PYG{g+go}{                        lcores}
\PYG{g+go}{  \PYGZhy{}tx TX\PYGZus{}PORTS, \PYGZhy{}\PYGZhy{}tx\PYGZhy{}ports TX\PYGZus{}PORTS}
\PYG{g+go}{                        List of tx ports and queues handled by the I/O tx}
\PYG{g+go}{                        lcores}
\PYG{g+go}{  \PYGZhy{}w WORKER\PYGZus{}LCORES, \PYGZhy{}\PYGZhy{}worker\PYGZhy{}lcores WORKER\PYGZus{}LCORES}
\PYG{g+go}{                        List of worker lcores}
\PYG{g+go}{  \PYGZhy{}rsz RING\PYGZus{}SIZES, \PYGZhy{}\PYGZhy{}ring\PYGZhy{}sizes RING\PYGZus{}SIZES}
\PYG{g+go}{                        Ring sizes of \PYGZsq{}rx\PYGZus{}read,rx\PYGZus{}send,w\PYGZus{}send,tx\PYGZus{}written\PYGZsq{}}
\PYG{g+go}{  \PYGZhy{}bsz BURST\PYGZus{}SIZES, \PYGZhy{}\PYGZhy{}burst\PYGZhy{}sizes BURST\PYGZus{}SIZES}
\PYG{g+go}{                        Burst sizes of rx, worker or tx}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}lpm LPM             List of LPM rules}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}pos\PYGZhy{}lb POS\PYGZus{}LB       Position of the 1\PYGZhy{}byte field used for identify}
\PYG{g+go}{                        worker}
\PYG{g+go}{  ...}
\end{sphinxVerbatim}


\subsubsection{Suricata Container}
\label{\detokenize{tools/sppc/app_launcher:suricata-container}}\label{\detokenize{tools/sppc/app_launcher:sppc-appl-suricata}}
\sphinxhref{https://suricata.readthedocs.io/en/suricata-4.1.2/index.html}{Suricata}
is a sophisticated IDS/IPS application.
SPP container supports suricata 4.1.4 hosted this
\sphinxhref{https://github.com/vipinpv85/DPDK\_SURICATA-4\_1\_1}{repository}.

Unlike other scripts, \sphinxcode{\sphinxupquote{app/suricata.py}} does not launch appliation
directly but bash to enable to edit config file on the container.
Suricata accepts options from config file specified with
\sphinxcode{\sphinxupquote{-{-}dpdk}} option.
You can copy your config to the container by using \sphinxcode{\sphinxupquote{docker cp}}.
Sample config \sphinxcode{\sphinxupquote{mysuricata.cfg}} is included under \sphinxcode{\sphinxupquote{suricata-4.1.4}}.

Here is an example of launching suricata with image
\sphinxcode{\sphinxupquote{sppc/suricata-ubuntu2:latest}}
which is built as described in
{\hyperref[\detokenize{tools/sppc/build_img:sppc-build-img-suricata}]{\sphinxcrossref{\DUrole{std,std-ref}{Build suricata image}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} docker cp your.cnf CONTAINER\PYGZus{}ID:/path/to/conf/your.conf
\PYG{g+gp}{\PYGZdl{}} ./suricata.py \PYGZhy{}d vhost:1,vhost:2 \PYGZhy{}fg \PYGZhy{}ci sppc/suricata\PYGZhy{}ubuntu2:latest
\PYG{g+gp}{\PYGZsh{}} suricata \PYGZhy{}\PYGZhy{}dpdk\PYG{o}{=}/path/to/config
\end{sphinxVerbatim}

Refer options and usages by \sphinxcode{\sphinxupquote{load-balancer.py -h}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/suricata.py \PYGZhy{}h
\PYG{g+go}{usage: suricata.py [\PYGZhy{}h] [\PYGZhy{}l CORE\PYGZus{}LIST] [\PYGZhy{}c CORE\PYGZus{}MASK] [\PYGZhy{}m MEM]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}vdev [VDEV [VDEV ...]]] [\PYGZhy{}\PYGZhy{}socket\PYGZhy{}mem SOCKET\PYGZus{}MEM]}
\PYG{g+go}{                   [\PYGZhy{}b [PCI\PYGZus{}BLACKLIST [PCI\PYGZus{}BLACKLIST ...]]]}
\PYG{g+go}{                   [\PYGZhy{}w [PCI\PYGZus{}WHITELIST [PCI\PYGZus{}WHITELIST ...]]]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}single\PYGZhy{}file\PYGZhy{}segments]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}nof\PYGZhy{}memchan NOF\PYGZus{}MEMCHAN] [\PYGZhy{}d DEV\PYGZus{}UIDS]}
\PYG{g+go}{                   [\PYGZhy{}v [VOLUME [VOLUME ...]]] [\PYGZhy{}nq NOF\PYGZus{}QUEUES]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME] [\PYGZhy{}\PYGZhy{}dist\PYGZhy{}ver DIST\PYGZus{}VER]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}workdir WORKDIR] [\PYGZhy{}\PYGZhy{}name NAME]}
\PYG{g+go}{                   [\PYGZhy{}ci CONTAINER\PYGZus{}IMAGE] [\PYGZhy{}fg] [\PYGZhy{}\PYGZhy{}dry\PYGZhy{}run]}

\PYG{g+go}{Launcher for suricata container}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  ...}
\PYG{g+go}{  \PYGZhy{}d DEV\PYGZus{}UIDS, \PYGZhy{}\PYGZhy{}dev\PYGZhy{}uids DEV\PYGZus{}UIDS}
\PYG{g+go}{                        Virtual devices of SPP in resource UID format}
\PYG{g+go}{  \PYGZhy{}nq NOF\PYGZus{}QUEUES, \PYGZhy{}\PYGZhy{}nof\PYGZhy{}queues NOF\PYGZus{}QUEUES}
\PYG{g+go}{                        Number of queues of virtio (default is 1)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}no\PYGZhy{}privileged       Disable docker\PYGZsq{}s privileged mode if it\PYGZsq{}s needed}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}dist\PYGZhy{}name DIST\PYGZus{}NAME}
\PYG{g+go}{                        Name of Linux distribution}
\PYG{g+go}{  ...}
\end{sphinxVerbatim}


\subsubsection{Helloworld Container}
\label{\detokenize{tools/sppc/app_launcher:helloworld-container}}\label{\detokenize{tools/sppc/app_launcher:sppc-appl-helloworld}}
The \sphinxhref{https://dpdk.org/doc/guides/sample\_app\_ug/hello\_world.html}{helloworld}
sample application is an example of the simplest DPDK application
that can be written.

Unlike from the other applications, it does not work as a network
function actually.
This app container script \sphinxcode{\sphinxupquote{helloworld.py}} is intended to be used
as a template for an user defined app container script.
You can use it as a template for developing your app container script.
An instruction for developing app container script is described in
{\hyperref[\detokenize{tools/sppc/howto_launcher:sppc-howto-define-appc}]{\sphinxcrossref{\DUrole{std,std-ref}{How to Define Your App Launcher}}}}.

Helloworld app container has no application specific options. There are
only EAL and app container options.
You should give \sphinxcode{\sphinxupquote{-l}} option for the simplest app container.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/helloworld.py \PYGZhy{}l \PYG{l+m}{4}\PYGZhy{}6 \PYGZhy{}fg
\PYG{g+go}{...}
\end{sphinxVerbatim}


\subsection{Use Cases}
\label{\detokenize{tools/sppc/usecases:use-cases}}\label{\detokenize{tools/sppc/usecases:spp-container-usecases}}\label{\detokenize{tools/sppc/usecases::doc}}
SPP Container provides an easy way to configure network path
for DPDK application running on containers.
It is useful for testing your NFV applications with \sphinxcode{\sphinxupquote{testpmd}} or
\sphinxcode{\sphinxupquote{pktgen}} quickly, or providing a reproducible environment for evaluation
with a configuration files.

In addition, using container requires less CPU and memory resources
comparing with using virtual machines.
It means that users can try to test variety kinds of use cases without
using expensive servers.

This chapter describes examples of simple use cases of SPP container.


\subsubsection{Perfromance Test of Vhost in Single Node}
\label{\detokenize{tools/sppc/usecases:perfromance-test-of-vhost-in-single-node}}\label{\detokenize{tools/sppc/usecases:sppc-usecases-test-vhost-single}}
First use case is a simple performance test of vhost PMDs as shown in
\hyperref[\detokenize{tools/sppc/usecases:figure-sppc-usecase-vhost}]{Fig.\@ \ref{\detokenize{tools/sppc/usecases:figure-sppc-usecase-vhost}}}.
Two of containers of \sphinxcode{\sphinxupquote{spp\_nfv}} are connected with a ring PMD and
all of app container processes run on a single node.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.580\linewidth]{{sppc_usecase_vhost}.pdf}
\caption{Test of vhost PMD in a single node}\label{\detokenize{tools/sppc/usecases:id1}}\label{\detokenize{tools/sppc/usecases:figure-sppc-usecase-vhost}}\end{figure}

You use three terminals in this example, first one is for \sphinxcode{\sphinxupquote{spp-ctl}},
second one is for SPP CLI and third one is for managing app containers.
First of all, launch \sphinxcode{\sphinxupquote{spp-ctl}} in terminal 1.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl
\end{sphinxVerbatim}

Then, \sphinxcode{\sphinxupquote{spp.py}} in terminal 2.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py
\end{sphinxVerbatim}

Move to terminal 3, launch app containers of \sphinxcode{\sphinxupquote{spp\_primary}}
and \sphinxcode{\sphinxupquote{spp\_nfv}} step by step in background mode.
You notice that vhost device is attached with \sphinxcode{\sphinxupquote{-d tap:1}} which is not
required if you have physical ports on host.
It is because that SPP primary requires at least one port even if
it is no need.
You can also assign a physical port instead of this vhost device.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary.py \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}p 0x01 \PYGZhy{}d tap:1
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{1} \PYGZhy{}l \PYG{l+m}{1}\PYGZhy{}2
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{2} \PYGZhy{}l \PYG{l+m}{3}\PYGZhy{}4
\end{sphinxVerbatim}

Then, add two vhost PMDs for pktgen app container from SPP CLI.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add vhost:1}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add vhost:2}
\end{sphinxVerbatim}

It is ready for launching pktgen app container. In this usecase,
use five lcores for pktgen. One lcore is used for master, and remaining
lcores are used for rx and tx evenly.
Device ID option \sphinxcode{\sphinxupquote{-d vhost:1,vhost:2}} is for refferring vhost 1 and 2.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} python3 app/pktgen.py \PYGZhy{}fg \PYGZhy{}l \PYG{l+m}{5}\PYGZhy{}9 \PYGZhy{}d vhost:1,vhost:2
\end{sphinxVerbatim}

Finally, configure network path from SPP controller,

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch ring:0 vhost:1}
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch vhost:2 ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 2; forward}
\end{sphinxVerbatim}

and start forwarding from pktgen.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} Pktgen:/\PYGZgt{} start \PYG{l+m}{1}
\end{sphinxVerbatim}

You find that packet count of rx of port 0 and tx of port 1
is increased rapidlly.


\subsubsection{Performance Test of Ring}
\label{\detokenize{tools/sppc/usecases:performance-test-of-ring}}\label{\detokenize{tools/sppc/usecases:sppc-usecases-test-ring}}
Ring PMD is a very fast path to communicate between DPDK processes.
It is a kind of zero-copy data passing via shared memory and better
performance than vhost PMD.
Currently, only \sphinxcode{\sphinxupquote{spp\_nfv}} provides ring PMD in SPP container.
It is also possible other DPDK applications to have ring PMD interface
for SPP technically,
but not implemented yet.

This use case is for testing performance of ring PMDs.
As described in \hyperref[\detokenize{tools/sppc/usecases:figure-sppc-usecase-ring}]{Fig.\@ \ref{\detokenize{tools/sppc/usecases:figure-sppc-usecase-ring}}},
each of app containers on which \sphinxcode{\sphinxupquote{spp\_nfv}} is running are connected
with ring PMDs in serial.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{sppc_usecase_ring}.pdf}
\caption{Test of ring PMD}\label{\detokenize{tools/sppc/usecases:id2}}\label{\detokenize{tools/sppc/usecases:figure-sppc-usecase-ring}}\end{figure}

You use three terminals on host 1, first one is for \sphinxcode{\sphinxupquote{spp-ctl}},
second one is for \sphinxcode{\sphinxupquote{spp.py}}, and third one is for \sphinxcode{\sphinxupquote{spp\_nfv}} app containers.
Pktgen on host 2 is started forwarding after setup on host 1 is finished.

First, launch \sphinxcode{\sphinxupquote{spp-ctl}} in terminal 1.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl
\end{sphinxVerbatim}

Then, launch \sphinxcode{\sphinxupquote{spp.py}} in terminal 2.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py
\end{sphinxVerbatim}

In terminal 3, launch \sphinxcode{\sphinxupquote{spp\_primary}} and \sphinxcode{\sphinxupquote{spp\_nfv}} containers
in background mode.
In this case, you attach physical ports to \sphinxcode{\sphinxupquote{spp\_primary}} with
portmask option.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary.py \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}p 0x03
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{1} \PYGZhy{}l \PYG{l+m}{1}\PYGZhy{}2
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{2} \PYGZhy{}l \PYG{l+m}{3}\PYGZhy{}4
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{3} \PYGZhy{}l \PYG{l+m}{5}\PYGZhy{}6
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{4} \PYGZhy{}l \PYG{l+m}{7}\PYGZhy{}8
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
It might happen an error to input if the number of SPP process is
increased. It also might get bothered to launch several SPP
processes if the number is large.

You can use \sphinxcode{\sphinxupquote{tools/spp-launcher.py}} to launch SPP processes
at once. Here is an example for launching \sphinxcode{\sphinxupquote{spp\_primary}} and
four \sphinxcode{\sphinxupquote{spp\_nfv}} processes. \sphinxcode{\sphinxupquote{-n}} is for specifying the nubmer of
\sphinxcode{\sphinxupquote{spp\_nfv}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 tools/spp\PYGZhy{}launcher.py \PYGZhy{}n \PYG{l+m}{4}
\end{sphinxVerbatim}

You will find that lcore assignment is the same as below.
Lcore is assigned from 0 for primary, and next two lcores for the
first \sphinxcode{\sphinxupquote{spp\_nfv}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary.py \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}p 0x03
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{1} \PYGZhy{}l \PYG{l+m}{1},2
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{2} \PYGZhy{}l \PYG{l+m}{3},4
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{3} \PYGZhy{}l \PYG{l+m}{5},6
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{4} \PYGZhy{}l \PYG{l+m}{7},8
\end{sphinxVerbatim}

You can also assign lcores with \sphinxcode{\sphinxupquote{-{-}shared}} to master lcore
be shared among \sphinxcode{\sphinxupquote{spp\_nfv}} processes.
It is useful to reduce the usage of lcores as explained in
{\hyperref[\detokenize{tools/sppc/usecases:sppc-usecases-pktgen-l2fwd-less-lcores}]{\sphinxcrossref{\DUrole{std,std-ref}{Pktgen and L2fwd using less Lcores}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 tools/spp\PYGZhy{}launcher.py \PYGZhy{}n \PYG{l+m}{4} \PYGZhy{}\PYGZhy{}shared
\end{sphinxVerbatim}

The result of assignment of this command is the same as below.
Master lcore 1 is shared among secondary processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary.py \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}p 0x03
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{1} \PYGZhy{}l \PYG{l+m}{1},2
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{2} \PYGZhy{}l \PYG{l+m}{1},3
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{3} \PYGZhy{}l \PYG{l+m}{1},4
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{4} \PYGZhy{}l \PYG{l+m}{1},5
\end{sphinxVerbatim}
\end{sphinxadmonition}

Add ring PMDs considering which of rings is shared between which of
containers.
You can use recipe scripts from \sphinxcode{\sphinxupquote{playback}} command instead of
typing commands step by step.
For this usecase example, it is included in
\sphinxcode{\sphinxupquote{recipes/sppc/samples/test\_ring.rcp}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add ring:1}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add ring:2}
\PYG{g+go}{spp \PYGZgt{} nfv 3; add ring:2}
\PYG{g+go}{spp \PYGZgt{} nfv 3; add ring:3}
\PYG{g+go}{spp \PYGZgt{} nfv 4; add ring:3}
\end{sphinxVerbatim}

Then, patch all of ports to be configured containers are connected
in serial.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch phy:0 ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch ring:0 ring:1}
\PYG{g+go}{spp \PYGZgt{} nfv 3; patch ring:1 ring:2}
\PYG{g+go}{spp \PYGZgt{} nfv 3; patch ring:2 ring:3}
\PYG{g+go}{spp \PYGZgt{} nfv 4; patch ring:3 phy:1}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 2; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 3; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 4; forward}
\end{sphinxVerbatim}

After setup on host 1 is finished, start forwarding from pktgen on host 2.
You can see the throughput of rx and tx ports on pktgen’s terminal.
You also find that the throughput is almost not decreased and keeping wire
rate speed even after it through several chained containers.


\subsubsection{Pktgen and L2fwd}
\label{\detokenize{tools/sppc/usecases:pktgen-and-l2fwd}}\label{\detokenize{tools/sppc/usecases:sppc-usecases-pktgen-l2fwd}}
To consider more practical service function chaining like use case,
connect not only SPP processes, but also DPDK application to \sphinxcode{\sphinxupquote{pktgen}}.
In this example, use \sphinxcode{\sphinxupquote{l2fwd}} app container as a DPDK application
for simplicity.
You can also use other DPDK applications as similar to this example
as described in next sections.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{sppc_usecase_l2fwdpktgen}.pdf}
\caption{Chainning pktgen and l2fwd}\label{\detokenize{tools/sppc/usecases:id3}}\label{\detokenize{tools/sppc/usecases:figure-sppc-usecase-l2fwdpktgen}}\end{figure}

This configuration requires more CPUs than previous example.
It is up to 14 lcores, but you can reduce lcores to do the trick.
It is a trade-off between usage and performance.
In this case, we focus on the usage of maximum lcores to get high
performance.

Here is a list of lcore assignment for each of app containers.
\begin{itemize}
\item {} 
One lcore for \sphinxcode{\sphinxupquote{spp\_primary}} container.

\item {} 
Eight lcores for four \sphinxcode{\sphinxupquote{spp\_nfv}} containers.

\item {} 
Three lcores for \sphinxcode{\sphinxupquote{pktgen}} container.

\item {} 
Two lcores for \sphinxcode{\sphinxupquote{l2fwd}} container.

\end{itemize}

First of all, launch \sphinxcode{\sphinxupquote{spp-ctl}} and \sphinxcode{\sphinxupquote{spp.py}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl

\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py
\end{sphinxVerbatim}

Then, launch \sphinxcode{\sphinxupquote{spp\_primary}} and \sphinxcode{\sphinxupquote{spp\_nfv}} containers in background.
It does not use physical NICs as similar to
{\hyperref[\detokenize{tools/sppc/usecases:sppc-usecases-test-vhost-single}]{\sphinxcrossref{\DUrole{std,std-ref}{Perfromance Test of Vhost in Single Node}}}}.
Use four of \sphinxcode{\sphinxupquote{spp\_nfv}} containers for using four vhost PMDs.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary.py \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}p 0x01 \PYGZhy{}d tap:1
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{1} \PYGZhy{}l \PYG{l+m}{1}\PYGZhy{}2
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{2} \PYGZhy{}l \PYG{l+m}{3}\PYGZhy{}4
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{3} \PYGZhy{}l \PYG{l+m}{5}\PYGZhy{}6
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{4} \PYGZhy{}l \PYG{l+m}{7}\PYGZhy{}8
\end{sphinxVerbatim}

Assign ring and vhost PMDs. Each of vhost IDs to be the same as
its secondary ID.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add vhost:1}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add vhost:2}
\PYG{g+go}{spp \PYGZgt{} nfv 3; add vhost:3}
\PYG{g+go}{spp \PYGZgt{} nfv 4; add vhost:4}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 4; add ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add ring:1}
\PYG{g+go}{spp \PYGZgt{} nfv 3; add ring:1}
\end{sphinxVerbatim}

After vhost PMDs are created, you can launch containers
of \sphinxcode{\sphinxupquote{pktgen}} and \sphinxcode{\sphinxupquote{l2fwd}}.

In this case, \sphinxcode{\sphinxupquote{pktgen}} container owns vhost 1 and 2,

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/pktgen.py \PYGZhy{}l \PYG{l+m}{9}\PYGZhy{}11 \PYGZhy{}d vhost:1,vhost:2
\end{sphinxVerbatim}

and \sphinxcode{\sphinxupquote{l2fwd}} container owns vhost 3 and 4.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python app/l2fwd.py \PYGZhy{}l \PYG{l+m}{12}\PYGZhy{}13 \PYGZhy{}d vhost:3,vhost:4
\end{sphinxVerbatim}

Then, configure network path by pactching each of ports
and start forwarding from SPP controller.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch ring:0 vhost:1}
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch vhost:2 ring:1}
\PYG{g+go}{spp \PYGZgt{} nfv 3; patch ring:1 vhost:3}
\PYG{g+go}{spp \PYGZgt{} nfv 4; patch vhost:4 ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 2; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 3; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 4; forward}
\end{sphinxVerbatim}

Finally, start forwarding from \sphinxcode{\sphinxupquote{pktgen}} container.
You can see that packet count is increased on both of
\sphinxcode{\sphinxupquote{pktgen}} and \sphinxcode{\sphinxupquote{l2fwd}}.

For this usecase example, recipe scripts are included in
\sphinxcode{\sphinxupquote{recipes/sppc/samples/pg\_l2fwd.rcp}}.


\subsubsection{Pktgen and L2fwd using less Lcores}
\label{\detokenize{tools/sppc/usecases:pktgen-and-l2fwd-using-less-lcores}}\label{\detokenize{tools/sppc/usecases:sppc-usecases-pktgen-l2fwd-less-lcores}}
This section describes the effort of reducing the usage of lcore for
{\hyperref[\detokenize{tools/sppc/usecases:sppc-usecases-pktgen-l2fwd}]{\sphinxcrossref{\DUrole{std,std-ref}{Pktgen and L2fwd}}}}.

Here is a list of lcore assignment for each of app containers.
It is totally 7 lcores while the maximum number is 14.
\begin{itemize}
\item {} 
One lcore for \sphinxcode{\sphinxupquote{spp\_primary}} container.

\item {} 
Three lcores for four \sphinxcode{\sphinxupquote{spp\_nfv}} containers.

\item {} 
Two lcores for pktgen container.

\item {} 
One lcores for l2fwd container.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{sppc_usecase_l2fwdpktgen_less}.pdf}
\caption{Pktgen and l2fwd using less lcores}\label{\detokenize{tools/sppc/usecases:id4}}\label{\detokenize{tools/sppc/usecases:figure-sppc-usecase-l2fwdpktgen-less}}\end{figure}

First of all, launch \sphinxcode{\sphinxupquote{spp-ctl}} and \sphinxcode{\sphinxupquote{spp.py}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl

\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py
\end{sphinxVerbatim}

Launch \sphinxcode{\sphinxupquote{spp\_primary}} and \sphinxcode{\sphinxupquote{spp\_nfv}} containers in background.
It does not use physical NICs as similar to
{\hyperref[\detokenize{tools/sppc/usecases:sppc-usecases-test-vhost-single}]{\sphinxcrossref{\DUrole{std,std-ref}{Perfromance Test of Vhost in Single Node}}}}.
Use two of \sphinxcode{\sphinxupquote{spp\_nfv}} containers for using four vhost PMDs.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary.py \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}p 0x01 \PYGZhy{}d tap:1
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{1} \PYGZhy{}l \PYG{l+m}{1},2
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{2} \PYGZhy{}l \PYG{l+m}{1},3
\end{sphinxVerbatim}

The number of process and CPUs are fewer than previous example.
You can reduce the number of \sphinxcode{\sphinxupquote{spp\_nfv}} processes by assigning
several vhost PMDs to one process, although performance is decreased
possibly.
For the number of lcores, you can reduce it by sharing
the master lcore 1 which has no heavy tasks.

Assign each of two vhost PMDs to the processes.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add vhost:1}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add vhost:2}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add vhost:3}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add vhost:4}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add ring:1}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add ring:1}
\end{sphinxVerbatim}

After vhost PMDs are created, you can launch containers
of \sphinxcode{\sphinxupquote{pktgen}} and \sphinxcode{\sphinxupquote{l2fwd}}.
These processes also share the master lcore 1 with others.

In this case, \sphinxcode{\sphinxupquote{pktgen}} container uses vhost 1 and 2,

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} python app/pktgen.py \PYGZhy{}l \PYG{l+m}{1},4,5 \PYGZhy{}d vhost:1,vhost:2
\end{sphinxVerbatim}

and \sphinxcode{\sphinxupquote{l2fwd}} container uses vhost 3 and 4.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python app/l2fwd.py \PYGZhy{}l \PYG{l+m}{1},6 \PYGZhy{}d vhost:3,vhost:4
\end{sphinxVerbatim}

Then, configure network path by pactching each of ports
and start forwarding from SPP controller.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch ring:0 vhost:1}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch vhost:2 ring:1}
\PYG{g+go}{spp \PYGZgt{} nfv 3; patch ring:1 vhost:3}
\PYG{g+go}{spp \PYGZgt{} nfv 4; patch vhost:4 ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 2; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 3; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 4; forward}
\end{sphinxVerbatim}

Finally, start forwarding from \sphinxcode{\sphinxupquote{pktgen}} container.
You can see that packet count is increased on both of
\sphinxcode{\sphinxupquote{pktgen}} and \sphinxcode{\sphinxupquote{l2fwd}}.

For this usecase example, recipe scripts are included in
\sphinxcode{\sphinxupquote{recipes/sppc/samples/pg\_l2fwd\_less.rcp}}.


\subsubsection{Load-Balancer and Pktgen}
\label{\detokenize{tools/sppc/usecases:load-balancer-and-pktgen}}\label{\detokenize{tools/sppc/usecases:sppc-usecases-lb-pktgen}}
Previous examples are all the single-path configurations and do not
have branches.
To explain how to setup a multi-path configuration, we use
\sphinxhref{https://dpdk.org/doc/guides/sample\_app\_ug/load\_balancer.html}{Load-Balancer}
application in this example.
It is an application distributes packet I/O task with several worker
lcores to share IP addressing.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{sppc_usecase_lb_pktgen}.pdf}
\caption{Multi-path configuration with load\_balancer and pktgen}\label{\detokenize{tools/sppc/usecases:id5}}\label{\detokenize{tools/sppc/usecases:figure-sppc-usecase-lb-pktgen}}\end{figure}

Packets from tx of \sphinxcode{\sphinxupquote{pktgen}}, through ring:0, are received by rx
of \sphinxcode{\sphinxupquote{load\_balancer}}.
Then, \sphinxcode{\sphinxupquote{load\_balancer}} classify the packets to decide the
destionations.
You can count received packets on rx ports of \sphinxcode{\sphinxupquote{pktgen}}.

There are six \sphinxcode{\sphinxupquote{spp\_nfv}} and two DPDK applications in this example.
To reduce the number of lcores, configure lcore assignment to share
the master lcore.
Do not assign several vhosts to a process to avoid the performance
degradation.
It is 15 lcores required to the configuration.

Here is a list of lcore assignment for each of app containers.
\begin{itemize}
\item {} 
One lcore for \sphinxcode{\sphinxupquote{spp\_primary}} container.

\item {} 
Seven lcores for four \sphinxcode{\sphinxupquote{spp\_nfv}} containers.

\item {} 
Three lcores for \sphinxcode{\sphinxupquote{pktgen}} container.

\item {} 
Four lcores for \sphinxcode{\sphinxupquote{load\_balancer}} container.

\end{itemize}

First of all, launch \sphinxcode{\sphinxupquote{spp-ctl}} and \sphinxcode{\sphinxupquote{spp.py}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{1}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp\PYGZhy{}ctl/spp\PYGZhy{}ctl

\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp
\PYG{g+gp}{\PYGZdl{}} python3 src/spp.py
\end{sphinxVerbatim}

Launch \sphinxcode{\sphinxupquote{spp\_primary}} and \sphinxcode{\sphinxupquote{spp\_nfv}} containers in background.
It does not use physical NICs as similar to
{\hyperref[\detokenize{tools/sppc/usecases:sppc-usecases-test-vhost-single}]{\sphinxcrossref{\DUrole{std,std-ref}{Perfromance Test of Vhost in Single Node}}}}.
Use six \sphinxcode{\sphinxupquote{spp\_nfv}} containers for using six vhost PMDs.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}primary.py \PYGZhy{}l \PYG{l+m}{0} \PYGZhy{}p 0x01 \PYGZhy{}d tap:1
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{1} \PYGZhy{}l \PYG{l+m}{1},2
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{2} \PYGZhy{}l \PYG{l+m}{1},3
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{3} \PYGZhy{}l \PYG{l+m}{1},4
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{4} \PYGZhy{}l \PYG{l+m}{1},5
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{5} \PYGZhy{}l \PYG{l+m}{1},6
\PYG{g+gp}{\PYGZdl{}} python3 app/spp\PYGZhy{}nfv.py \PYGZhy{}i \PYG{l+m}{6} \PYGZhy{}l \PYG{l+m}{1},7
\end{sphinxVerbatim}

Assign ring and vhost PMDs. Each of vhost IDs to be the same as
its secondary ID.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add vhost:1}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add vhost:2}
\PYG{g+go}{spp \PYGZgt{} nfv 3; add vhost:3}
\PYG{g+go}{spp \PYGZgt{} nfv 4; add vhost:4}
\PYG{g+go}{spp \PYGZgt{} nfv 5; add vhost:5}
\PYG{g+go}{spp \PYGZgt{} nfv 6; add vhost:6}
\PYG{g+go}{spp \PYGZgt{} nfv 1; add ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 2; add ring:1}
\PYG{g+go}{spp \PYGZgt{} nfv 3; add ring:2}
\PYG{g+go}{spp \PYGZgt{} nfv 4; add ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 5; add ring:1}
\PYG{g+go}{spp \PYGZgt{} nfv 6; add ring:2}
\end{sphinxVerbatim}

And patch all of ports.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; patch vhost:1 ring:0}
\PYG{g+go}{spp \PYGZgt{} nfv 2; patch ring:1 vhost:2}
\PYG{g+go}{spp \PYGZgt{} nfv 3; patch ring:2 vhost:3}
\PYG{g+go}{spp \PYGZgt{} nfv 4; patch ring:0 vhost:4}
\PYG{g+go}{spp \PYGZgt{} nfv 5; patch vhost:5 ring:1}
\PYG{g+go}{spp \PYGZgt{} nfv 6; patch vhost:6 ring:2}
\end{sphinxVerbatim}

You had better to check that network path is configured properly.
\sphinxcode{\sphinxupquote{topo}} command is useful for checking it with a graphical image.
Define two groups of vhost PMDs as \sphinxcode{\sphinxupquote{c1}} and \sphinxcode{\sphinxupquote{c2}} with
\sphinxcode{\sphinxupquote{topo\_subgraph}} command before.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+gp}{\PYGZsh{}} define c1 and c2 to \PYG{n+nb}{help} your understanding
\PYG{g+go}{spp \PYGZgt{} topo\PYGZus{}subgraph add c1 vhost:1,vhost:2,vhost:3}
\PYG{g+go}{spp \PYGZgt{} topo\PYGZus{}subgraph add c2 vhost:4,vhost:5,vhost:6}

\PYG{g+gp}{\PYGZsh{}} show network diagram
\PYG{g+go}{spp \PYGZgt{} topo term}
\end{sphinxVerbatim}

Finally, launch \sphinxcode{\sphinxupquote{pktgen}} and \sphinxcode{\sphinxupquote{load\_balancer}} app containers
to start traffic monitoring.

For \sphinxcode{\sphinxupquote{pktgen}} container, assign lcores 8-10 and vhost 1-3.
\sphinxcode{\sphinxupquote{-T}} options is required to enable color terminal output.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/pktgen.py \PYGZhy{}l \PYG{l+m}{8}\PYGZhy{}10 \PYGZhy{}d vhost:1,vhost:2,vhost:3 \PYGZhy{}T
\end{sphinxVerbatim}

For \sphinxcode{\sphinxupquote{load\_balancer}} container, assign lcores 12-15 and vhost 4-6.
Four lcores are assigned to rx, tx and two workers.
You should add \sphinxcode{\sphinxupquote{-nq}} option because this example requires three
or more queues. In this case, assign 4 queues.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{4}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} /path/to/spp/tools/sppc
\PYG{g+gp}{\PYGZdl{}} python3 app/load\PYGZus{}balancer.py \PYGZhy{}l \PYG{l+m}{11}\PYGZhy{}14 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d vhost:4,vhost:5,vhost:6 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}fg \PYGZhy{}nq \PYG{l+m}{4} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}rx \PYG{l+s+s2}{\PYGZdq{}(0,0,11),(0,1,11),(0,2,11)\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}tx \PYG{l+s+s2}{\PYGZdq{}(0,12),(1,12),(2,12)\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}w \PYG{l+m}{13},14 \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}lpm \PYG{l+s+s2}{\PYGZdq{}1.0.0.0/24=\PYGZgt{}0; 1.0.1.0/24=\PYGZgt{}1; 1.0.2.0/24=\PYGZgt{}2;\PYGZdq{}}
\end{sphinxVerbatim}

Then, configure network path by pactching each of ports
and start forwarding from SPP controller.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{2}
\PYG{g+go}{spp \PYGZgt{} nfv 1; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 2; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 3; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 4; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 5; forward}
\PYG{g+go}{spp \PYGZgt{} nfv 6; forward}
\end{sphinxVerbatim}

You start forwarding from \sphinxcode{\sphinxupquote{pktgen}} container.
The destination of \sphinxcode{\sphinxupquote{load\_balancer}} is decided by considering
LPM rules. Try to classify incoming packets to port 1 on the
\sphinxcode{\sphinxupquote{load\_balancer}} application.

On \sphinxcode{\sphinxupquote{pktgen}}, change the destination IP address of port 0
to \sphinxcode{\sphinxupquote{1.0.1.100}}, and start.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+go}{Pktgen:/\PYGZgt{} set 0 dst ip 1.0.1.100}
\PYG{g+go}{Pktgen:/\PYGZgt{} start 0}
\end{sphinxVerbatim}

As forwarding on port 0 is started, you will find the packet count of
port 1 is increase rapidly.
You can change the destination IP address and send packets to port 2
by stopping to forward,
changing the destination IP address to \sphinxcode{\sphinxupquote{1.0.2.100}} and restart
forwarding.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Terminal \PYG{l+m}{3}
\PYG{g+go}{Pktgen:/\PYGZgt{} stop 0}
\PYG{g+go}{Pktgen:/\PYGZgt{} set 0 dst ip 1.0.2.100}
\PYG{g+go}{Pktgen:/\PYGZgt{} start 0}
\end{sphinxVerbatim}

You might not be able to stop \sphinxcode{\sphinxupquote{load\_balancer}} application with \sphinxstyleemphasis{Ctrl-C}.
In this case, terminate it with \sphinxcode{\sphinxupquote{docker kill}} directly as explained in
{\hyperref[\detokenize{tools/sppc/app_launcher:sppc-appl-load-balancer}]{\sphinxcrossref{\DUrole{std,std-ref}{Load-Balancer Container}}}}.
You can find the name of container from \sphinxcode{\sphinxupquote{docker ps}}.

For this usecase example, recipe scripts are included in
\sphinxcode{\sphinxupquote{recipes/sppc/samples/lb\_pg.rcp}}.


\subsection{How to Define Your App Launcher}
\label{\detokenize{tools/sppc/howto_launcher:how-to-define-your-app-launcher}}\label{\detokenize{tools/sppc/howto_launcher:sppc-howto-define-appc}}\label{\detokenize{tools/sppc/howto_launcher::doc}}
SPP container is a set of python script for launching DPDK application
on a container with docker command. You can launch your own application
by preparing a container image and install your application in
the container.
In this chapter, you will understand how to define application container
for your application.


\subsubsection{Build Image}
\label{\detokenize{tools/sppc/howto_launcher:build-image}}\label{\detokenize{tools/sppc/howto_launcher:sppc-howto-build-img}}
SPP container provides a build tool with version specific Dockerfiles.
You should read the Dockerfiles to understand environmental variable
or command path are defined.
Build tool refer \sphinxcode{\sphinxupquote{conf/env.py}} for the definitions before running
docker build.

Dockerfiles of pktgen or SPP can help your understanding for building
app container in which your application is placed outside of DPDK’s
directory.
On the other hand, if you build an app container of DPDK sample
application, you do not need to prepare your Dockerfile because all of
examples are compiled while building DPDK’s image.


\subsubsection{Create App Container Script}
\label{\detokenize{tools/sppc/howto_launcher:create-app-container-script}}\label{\detokenize{tools/sppc/howto_launcher:sppc-howto-create-appc}}
As explained in {\hyperref[\detokenize{tools/sppc/app_launcher:spp-container-app-launcher}]{\sphinxcrossref{\DUrole{std,std-ref}{App Container Launchers}}}}, app container script
shold be prepared for each of applications.
Application of SPP container is roughly categorized as DPDK sample apps
or not. The former case is like that you change an existing DPDK sample
application and run as a app container.

For DPDK sample apps, it is easy to build image and create app container
script.
On the other hand, it is a bit complex because you should you should
define environmental variables, command path and compilation process by
your own.

This section describes how to define app container script,
first for DPDK sample applications,
and then second for other than them.


\subsubsection{DPDK Sample App Container}
\label{\detokenize{tools/sppc/howto_launcher:dpdk-sample-app-container}}\label{\detokenize{tools/sppc/howto_launcher:sppc-howto-dpdk-sample-appc}}
Procedure of App container script is defined in main() and
consists of three steps of
(1) parsing options, (2) setup docker command and
(3) application command run inside the container.

Here is a sample code of {\hyperref[\detokenize{tools/sppc/app_launcher:sppc-appl-l2fwd}]{\sphinxcrossref{\DUrole{std,std-ref}{L2fwd Container}}}}.
\sphinxcode{\sphinxupquote{parse\_args()}} is defined in each
of app container scripts to parse all of EAL, docker and application
specific options.
It returns a result of \sphinxcode{\sphinxupquote{parse\_args()}} method of
\sphinxcode{\sphinxupquote{argparse.ArgumentParser}} class.
App container script uses standard library module \sphinxcode{\sphinxupquote{argparse}}
for parsing the arguments.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{args} \PYG{o}{=} \PYG{n}{parse\PYGZus{}args}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Container image name such as \PYGZsq{}sppc/dpdk\PYGZhy{}ubuntu:18.04\PYGZsq{}}
    \PYG{k}{if} \PYG{n}{args}\PYG{o}{.}\PYG{n}{container\PYGZus{}image} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{n}{container\PYGZus{}image} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{container\PYGZus{}image}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{container\PYGZus{}image} \PYG{o}{=} \PYG{n}{common}\PYG{o}{.}\PYG{n}{container\PYGZus{}img\PYGZus{}name}\PYG{p}{(}
            \PYG{n}{common}\PYG{o}{.}\PYG{n}{IMG\PYGZus{}BASE\PYGZus{}NAMES}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dpdk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
            \PYG{n}{args}\PYG{o}{.}\PYG{n}{dist\PYGZus{}name}\PYG{p}{,} \PYG{n}{args}\PYG{o}{.}\PYG{n}{dist\PYGZus{}ver}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Check for other mandatory opitons.}
    \PYG{k}{if} \PYG{n}{args}\PYG{o}{.}\PYG{n}{port\PYGZus{}mask} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{n}{common}\PYG{o}{.}\PYG{n}{error\PYGZus{}exit}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}port\PYGZhy{}mask}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

If the name of container is given via \sphinxcode{\sphinxupquote{args.container\_image}}, it is
decided as a combination of basename, distribution and its version.
Basenames are defined as \sphinxcode{\sphinxupquote{IMG\_BASE\_NAMES}} in \sphinxcode{\sphinxupquote{lib/common.py}}.
In general, You do not need to change for using DPDK sample apps.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+c1}{\PYGZsh{} defined in lib/common.py}
\PYG{n}{IMG\PYGZus{}BASE\PYGZus{}NAMES} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dpdk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sppc/dpdk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pktgen}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sppc/pktgen}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{spp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sppc/spp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{suricata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sppc/suricata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Options can be referred via \sphinxcode{\sphinxupquote{args}}. For example, the name of container
image can be referred via \sphinxcode{\sphinxupquote{args.container\_image}}.

Before go to step (2) and (3), you had better to check given option,
expecially mandatory options.
\sphinxcode{\sphinxupquote{common.error\_exit()}} is a helper method to print an error message
for given option and do \sphinxcode{\sphinxupquote{exit()}}. In this case, \sphinxcode{\sphinxupquote{-{-}port-mask}} must
be given, or exit with an error message.

Setup of \sphinxcode{\sphinxupquote{sock\_files}} is required for creating network interfaces
for the container. \sphinxcode{\sphinxupquote{sock\_files()}} defined in \sphinxcode{\sphinxupquote{lib/app\_helper.py}} is
provided for creating socket files from given device UIDs.

Then, setup docker command and its options as step (2).
Docker options are added by using helper method
\sphinxcode{\sphinxupquote{setup\_docker\_opts()}} which generates commonly used options for app
containers.
This methods returns a list of a part of options to give it to
\sphinxcode{\sphinxupquote{subprocess.call()}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+c1}{\PYGZsh{} Setup docker command.}
\PYG{n}{docker\PYGZus{}cmd} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sudo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{docker}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{run}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{docker\PYGZus{}opts} \PYG{o}{=} \PYG{n}{app\PYGZus{}helper}\PYG{o}{.}\PYG{n}{setup\PYGZus{}docker\PYGZus{}opts}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{n}{sock\PYGZus{}files}\PYG{p}{)}
\end{sphinxVerbatim}

You also notice that \sphinxcode{\sphinxupquote{docker\_cmd}} has a backslash \sphinxcode{\sphinxupquote{\textbackslash{}\textbackslash{}}} at the end of
the list.
It is only used to format the printed command on the terminal.
If you do no care about formatting, you do not need to add this character.

Next step is (3), to setup the application command.
You should change \sphinxcode{\sphinxupquote{cmd\_path}} to specify your application.
In \sphinxcode{\sphinxupquote{app/l2fwd.py}}, the application compiled under \sphinxcode{\sphinxupquote{RTE\_SDK}} in DPDK’s
directory, but your application might be different.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+c1}{\PYGZsh{} Setup l2fwd command run on container.}
\PYG{n}{cmd\PYGZus{}path} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZob{}0:s\PYGZcb{}/examples/\PYGZob{}2:s\PYGZcb{}/\PYGZob{}1:s\PYGZcb{}/\PYGZob{}2:s\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}
    \PYG{n}{env}\PYG{o}{.}\PYG{n}{RTE\PYGZus{}SDK}\PYG{p}{,} \PYG{n}{env}\PYG{o}{.}\PYG{n}{RTE\PYGZus{}TARGET}\PYG{p}{,} \PYG{n}{APP\PYGZus{}NAME}\PYG{p}{)}

\PYG{n}{l2fwd\PYGZus{}cmd} \PYG{o}{=} \PYG{p}{[}\PYG{n}{cmd\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Setup EAL options.}
\PYG{n}{eal\PYGZus{}opts} \PYG{o}{=} \PYG{n}{app\PYGZus{}helper}\PYG{o}{.}\PYG{n}{setup\PYGZus{}eal\PYGZus{}opts}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{n}{APP\PYGZus{}NAME}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Setup l2fwd options.}
\PYG{n}{l2fwd\PYGZus{}opts} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{args}\PYG{o}{.}\PYG{n}{port\PYGZus{}mask}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

While setting up EAL option in \sphinxcode{\sphinxupquote{setup\_eal\_opts()}}, \sphinxcode{\sphinxupquote{-{-}file-prefix}} is
generated by using the name of application and a random number. It should
be unique on the system because it is used as the name of hugepage file.

Finally, combine command and all of options before launching from
\sphinxcode{\sphinxupquote{subprocess.call()}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{n}{cmds} \PYG{o}{=} \PYG{n}{docker\PYGZus{}cmd} \PYG{o}{+} \PYG{n}{docker\PYGZus{}opts} \PYG{o}{+} \PYG{p}{[}\PYG{n}{container\PYGZus{}image}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYGZbs{}
    \PYG{n}{l2fwd\PYGZus{}cmd} \PYG{o}{+} \PYG{n}{eal\PYGZus{}opts} \PYG{o}{+} \PYG{n}{l2fwd\PYGZus{}opts}
\PYG{k}{if} \PYG{n}{cmds}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{common}\PYG{o}{.}\PYG{n}{print\PYGZus{}pretty\PYGZus{}commands}\PYG{p}{(}\PYG{n}{cmds}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{args}\PYG{o}{.}\PYG{n}{dry\PYGZus{}run} \PYG{o+ow}{is} \PYG{n+nb+bp}{True}\PYG{p}{:}
    \PYG{n+nb}{exit}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Remove delimiters for print\PYGZus{}pretty\PYGZus{}commands().}
\PYG{k}{while} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{cmds}\PYG{p}{:}
    \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{call}\PYG{p}{(}\PYG{n}{cmds}\PYG{p}{)}
\end{sphinxVerbatim}

There are some optional behaviors in the final step.
\sphinxcode{\sphinxupquote{common.print\_pretty\_commands()}} replaces \sphinxcode{\sphinxupquote{\textbackslash{}\textbackslash{}}} with a newline character
and prints command line in pretty format.
If you give \sphinxcode{\sphinxupquote{-{-}dry-run}} option, this launcher script prints command line
and exits without launching container.


\subsubsection{None DPDK Sample Applications in Container}
\label{\detokenize{tools/sppc/howto_launcher:none-dpdk-sample-applications-in-container}}\label{\detokenize{tools/sppc/howto_launcher:sppc-howto-none-dpdk-sample-apps}}
There are several application using DPDK but not included in
\sphinxhref{https://dpdk.org/doc/guides/sample\_app\_ug/index.html}{sample applications}.
\sphinxcode{\sphinxupquote{pktgen.py}} is an example of this type of app container.
As described in {\hyperref[\detokenize{tools/sppc/howto_launcher:sppc-howto-dpdk-sample-appc}]{\sphinxcrossref{\DUrole{std,std-ref}{DPDK Sample App Container}}}},
app container consists of three steps and it is the same for
this case.

First of all, you define parsing option for EAL, docker and
your application.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k}{def} \PYG{n+nf}{parse\PYGZus{}args}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{parser} \PYG{o}{=} \PYG{n}{argparse}\PYG{o}{.}\PYG{n}{ArgumentParser}\PYG{p}{(}
        \PYG{n}{description}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Launcher for pktgen\PYGZhy{}dpdk application container}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{parser} \PYG{o}{=} \PYG{n}{app\PYGZus{}helper}\PYG{o}{.}\PYG{n}{add\PYGZus{}eal\PYGZus{}args}\PYG{p}{(}\PYG{n}{parser}\PYG{p}{)}
    \PYG{n}{parser} \PYG{o}{=} \PYG{n}{app\PYGZus{}helper}\PYG{o}{.}\PYG{n}{add\PYGZus{}appc\PYGZus{}args}\PYG{p}{(}\PYG{n}{parser}\PYG{p}{)}

    \PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}pcap\PYGZhy{}file}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{,}
        \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PCAP packet flow file of port, defined as }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{N:filename}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}script\PYGZhy{}file}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{,}
        \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Pktgen script (.pkt) to or a Lua script (.lua)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

    \PYG{n}{parser} \PYG{o}{=} \PYG{n}{app\PYGZus{}helper}\PYG{o}{.}\PYG{n}{add\PYGZus{}sppc\PYGZus{}args}\PYG{p}{(}\PYG{n}{parser}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{parser}\PYG{o}{.}\PYG{n}{parse\PYGZus{}args}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

It is almost the same as {\hyperref[\detokenize{tools/sppc/howto_launcher:sppc-howto-dpdk-sample-appc}]{\sphinxcrossref{\DUrole{std,std-ref}{DPDK Sample App Container}}}},
but it has options for \sphinxcode{\sphinxupquote{pktgen}} itself.
For your application, you can simply add options to \sphinxcode{\sphinxupquote{parser}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{args} \PYG{o}{=} \PYG{n}{parse\PYGZus{}args}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Setup of socket files for network interfaces is the same as DPDK sample apps.
However, you might need to change paht of command  which is run in the
container. In \sphinxcode{\sphinxupquote{app/pktgen.py}}, directory of \sphinxcode{\sphinxupquote{pktgen}} is defined as
\sphinxcode{\sphinxupquote{wd}}, and the name of application s defined as \sphinxcode{\sphinxupquote{APP\_NAME}}.
This directory can be changed with \sphinxcode{\sphinxupquote{-{-}workdir}} option.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+c1}{\PYGZsh{} Setup docker command.}
\PYG{k}{if} \PYG{n}{args}\PYG{o}{.}\PYG{n}{workdir} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{n}{wd} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{workdir}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{wd} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/root/pktgen\PYGZhy{}dpdk}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{docker\PYGZus{}cmd} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sudo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{docker}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{run}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{docker\PYGZus{}opts} \PYG{o}{=} \PYG{n}{app\PYGZus{}helper}\PYG{o}{.}\PYG{n}{setup\PYGZus{}docker\PYGZus{}opts}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{n}{sock\PYGZus{}files}\PYG{p}{,} \PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{wd}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Setup pktgen command}
\PYG{n}{pktgen\PYGZus{}cmd} \PYG{o}{=} \PYG{p}{[}\PYG{n}{APP\PYGZus{}NAME}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Setup EAL options.}
\PYG{n}{eal\PYGZus{}opts} \PYG{o}{=} \PYG{n}{app\PYGZus{}helper}\PYG{o}{.}\PYG{n}{setup\PYGZus{}eal\PYGZus{}opts}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{n}{APP\PYGZus{}NAME}\PYG{p}{)}
\end{sphinxVerbatim}

Finally, combine all of commands and its options and launch
from \sphinxcode{\sphinxupquote{subprocess.call()}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{n}{cmds} \PYG{o}{=} \PYG{n}{docker\PYGZus{}cmd} \PYG{o}{+} \PYG{n}{docker\PYGZus{}opts} \PYG{o}{+} \PYG{p}{[}\PYG{n}{container\PYGZus{}image}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYGZbs{}
    \PYG{n}{pktgen\PYGZus{}cmd} \PYG{o}{+} \PYG{n}{eal\PYGZus{}opts} \PYG{o}{+} \PYG{n}{pktgen\PYGZus{}opts}
\PYG{k}{if} \PYG{n}{cmds}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{common}\PYG{o}{.}\PYG{n}{print\PYGZus{}pretty\PYGZus{}commands}\PYG{p}{(}\PYG{n}{cmds}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{args}\PYG{o}{.}\PYG{n}{dry\PYGZus{}run} \PYG{o+ow}{is} \PYG{n+nb+bp}{True}\PYG{p}{:}
    \PYG{n+nb}{exit}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Remove delimiters for print\PYGZus{}pretty\PYGZus{}commands().}
\PYG{k}{while} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{cmds}\PYG{p}{:}
    \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{call}\PYG{p}{(}\PYG{n}{cmds}\PYG{p}{)}
\end{sphinxVerbatim}

As you can see, it is almost the same as DPDK sample app container
without application path and options of application specific.


\section{Helper tools}
\label{\detokenize{tools/helpers/index:helper-tools}}\label{\detokenize{tools/helpers/index:spp-tools-helpers-index}}\label{\detokenize{tools/helpers/index::doc}}
Helper tools are intended to be used from other programs, such as \sphinxcode{\sphinxupquote{spp-ctl}}
or SPP CLI.


\subsection{CPU Layout}
\label{\detokenize{tools/helpers/tools:cpu-layout}}\label{\detokenize{tools/helpers/tools:spp-tools-helpers-tools}}\label{\detokenize{tools/helpers/tools::doc}}
This tool is a customized script of DPDK’s user tool \sphinxcode{\sphinxupquote{cpu\_layout.py}}. It is
used from \sphinxcode{\sphinxupquote{spp-ctl}} to get CPU layout. The behaviour of this script is same
as original one if you just run on terminal.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} python3 tools/helpers/cpu\PYGZus{}layout.py
\PYG{g+go}{======================================================================}
\PYG{g+go}{Core and Socket Information (as reported by \PYGZsq{}/sys/devices/system/cpu\PYGZsq{})}
\PYG{g+go}{======================================================================}

\PYG{g+go}{cores =  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]}
\PYG{g+go}{sockets =  [0]}

\PYG{g+go}{        Socket 0}
\PYG{g+go}{        \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{Core 0  [0]}
\PYG{g+go}{Core 1  [1]}
\PYG{g+go}{...}
\end{sphinxVerbatim}

Customized version of \sphinxcode{\sphinxupquote{cpu\_layout.py}} accepts an additional option
\sphinxcode{\sphinxupquote{-{-}json}} to output the result in JSON format.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Output in JSON format
\PYG{g+gp}{\PYGZdl{}} python3 tools/helpers/cpu\PYGZus{}layout.py \PYGZhy{}\PYGZhy{}json \PYG{p}{\textbar{}} jq
\PYG{g+go}{[}
\PYG{g+go}{  \PYGZob{}}
\PYG{g+go}{    \PYGZdq{}socket\PYGZus{}id\PYGZdq{}: 0,}
\PYG{g+go}{    \PYGZdq{}cores\PYGZdq{}: [}
\PYG{g+go}{      \PYGZob{}}
\PYG{g+go}{        \PYGZdq{}core\PYGZus{}id\PYGZdq{}: 1,}
\PYG{g+go}{        \PYGZdq{}cpus\PYGZdq{}: [}
\PYG{g+go}{          1}
\PYG{g+go}{        ]}
\PYG{g+go}{      \PYGZcb{},}
\PYG{g+go}{      \PYGZob{}}
\PYG{g+go}{        \PYGZdq{}core\PYGZus{}id\PYGZdq{}: 0,}
\PYG{g+go}{        \PYGZdq{}cpus\PYGZdq{}: [}
\PYG{g+go}{          0}
\PYG{g+go}{        ]}
\PYG{g+go}{      \PYGZcb{},}
\PYG{g+go}{      ...}
\PYG{g+go}{  \PYGZcb{}}
\PYG{g+go}{]}
\end{sphinxVerbatim}

You can almost the same result from \sphinxcode{\sphinxupquote{spp-ctl}}, but the order of params are
just different.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZsh{}} Retrieve CPU layout via REST API
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X GET http://192.168.1.100:7777/v1/cpus \PYG{p}{\textbar{}} jq
\PYG{g+gp}{  \PYGZpc{}} Total    \PYGZpc{} Received \PYGZpc{} Xferd  Average Speed   Time    Time     Time  Current
\PYG{g+go}{                                 Dload  Upload   Total   Spent    Left  Speed}
\PYG{g+go}{100   505  100   505    0     0  18091      0 \PYGZhy{}\PYGZhy{}:\PYGZhy{}\PYGZhy{}:\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}:\PYGZhy{}\PYGZhy{}:\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}:\PYGZhy{}\PYGZhy{}:\PYGZhy{}\PYGZhy{} 18703}
\PYG{g+go}{[}
\PYG{g+go}{  \PYGZob{}}
\PYG{g+go}{    \PYGZdq{}cores\PYGZdq{}: [}
\PYG{g+go}{      \PYGZob{}}
\PYG{g+go}{        \PYGZdq{}cpus\PYGZdq{}: [}
\PYG{g+go}{          1}
\PYG{g+go}{        ],}
\PYG{g+go}{        \PYGZdq{}core\PYGZus{}id\PYGZdq{}: 1}
\PYG{g+go}{      \PYGZcb{},}
\PYG{g+go}{      \PYGZob{}}
\PYG{g+go}{        \PYGZdq{}cpus\PYGZdq{}: [}
\PYG{g+go}{          0}
\PYG{g+go}{        ],}
\PYG{g+go}{        \PYGZdq{}core\PYGZus{}id\PYGZdq{}: 0}
\PYG{g+go}{      \PYGZcb{},}
\PYG{g+go}{      ...}
\PYG{g+go}{    ],}
\PYG{g+go}{    \PYGZdq{}socket\PYGZus{}id\PYGZdq{}: 0}
\PYG{g+go}{  \PYGZcb{}}
\PYG{g+go}{]}
\end{sphinxVerbatim}


\subsection{Secondary Process Launcher}
\label{\detokenize{tools/helpers/tools:secondary-process-launcher}}
It is very simple python script used to lauch a secondary process from other
program. It is intended to be used from spp\_primary for launching. Here is
whole lines of the script.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python}
\PYG{c+c1}{\PYGZsh{} coding: utf\PYGZhy{}8}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}SPP secondary launcher.\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{subprocess}

\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{cmd} \PYG{o}{=} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
    \PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{call}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{sphinxVerbatim}

As you may notice, it just runs given name or path of command with options,
so you can any of command other than SPP secondary processes. However, it
might be nouse for almost of users.

The reason of why this script is required is to launch secondary process from
\sphinxcode{\sphinxupquote{spp\_primary}} indirectly to avoid launched secondaries to be zombies finally.
In addtion, secondary processes other than \sphinxcode{\sphinxupquote{spp\_nfv}} do not work correctly
after launched with execv() or other siblings directly from \sphinxcode{\sphinxupquote{spp\_primary}}.


\chapter{API Reference}
\label{\detokenize{api_ref/index:api-reference}}\label{\detokenize{api_ref/index:spp-api-ref-index}}\label{\detokenize{api_ref/index::doc}}

\section{spp-ctl REST API}
\label{\detokenize{api_ref/overview:spp-ctl-rest-api}}\label{\detokenize{api_ref/overview:spp-ctl-rest-api-ref}}\label{\detokenize{api_ref/overview::doc}}

\subsection{Overview}
\label{\detokenize{api_ref/overview:overview}}
\sphinxcode{\sphinxupquote{spp-ctl}} provides simple REST like API. It supports http only, not https.


\subsubsection{Request and Response}
\label{\detokenize{api_ref/overview:request-and-response}}
Request body is JSON format.
It is accepted both \sphinxcode{\sphinxupquote{text/plain}} and \sphinxcode{\sphinxupquote{application/json}}
for the content-type header.

A response of \sphinxcode{\sphinxupquote{GET}} is JSON format and the content-type is
\sphinxcode{\sphinxupquote{application/json}} if the request success.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl http://127.0.0.1:7777/v1/processes
\PYG{g+go}{[\PYGZob{}\PYGZdq{}type\PYGZdq{}: \PYGZdq{}primary\PYGZdq{}\PYGZcb{}, ..., \PYGZob{}\PYGZdq{}client\PYGZhy{}id\PYGZdq{}: 2, \PYGZdq{}type\PYGZdq{}: \PYGZdq{}vf\PYGZdq{}\PYGZcb{}]}

\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X POST http://localhost:7777/v1/vfs/1/components \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}core\PYGZdq{}: 2, \PYGZdq{}name\PYGZdq{}: \PYGZdq{}fwd0\PYGZus{}tx\PYGZdq{}, \PYGZdq{}type\PYGZdq{}: \PYGZdq{}forward\PYGZdq{}\PYGZcb{}\PYGZsq{}}
\end{sphinxVerbatim}

If a request is failed, the response is a text which shows error reason
and the content-type is \sphinxcode{\sphinxupquote{text/plain}}.


\subsubsection{Error code}
\label{\detokenize{api_ref/overview:error-code}}
\sphinxcode{\sphinxupquote{spp-ctl}} does basic syntax and lexical check of a request.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Error codes in spp-ctl.}\label{\detokenize{api_ref/overview:id1}}\label{\detokenize{api_ref/overview:table-spp-ctl-error-codes}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Error
&\sphinxstyletheadfamily 
Description
\\
\hline
400
&
Syntax or lexical error, or SPP returns error for the request.
\\
\hline
404
&
URL is not supported, or no SPP process of client-id in a URL.
\\
\hline
500
&
System error occured in \sphinxcode{\sphinxupquote{spp-ctl}}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Independent of Process Type}
\label{\detokenize{api_ref/proc_independ:independent-of-process-type}}\label{\detokenize{api_ref/proc_independ:spp-ctl-rest-api-proc-independ}}\label{\detokenize{api_ref/proc_independ::doc}}

\subsection{GET /v1/processes}
\label{\detokenize{api_ref/proc_independ:get-v1-processes}}
Show SPP processes connected with \sphinxcode{\sphinxupquote{spp-ctl}}.


\subsubsection{Response}
\label{\detokenize{api_ref/proc_independ:response}}
An array of dict of processes in which process type and secondary ID are
defined. So, primary process does not have this ID.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response code of getting processes.}\label{\detokenize{api_ref/proc_independ:id10}}\label{\detokenize{api_ref/proc_independ:table-spp-ctl-processes-codes}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Value
&\sphinxstyletheadfamily 
Description
\\
\hline
200
&
Normal response code.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response params of getting processes.}\label{\detokenize{api_ref/proc_independ:id11}}\label{\detokenize{api_ref/proc_independ:table-spp-ctl-processes}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
type
&
string
&
Process type such as \sphinxcode{\sphinxupquote{primary}}, \sphinxcode{\sphinxupquote{nfv}} or so.
\\
\hline
client-id
&
integer
&
Secondary ID, so \sphinxcode{\sphinxupquote{primary}} does not have it.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Examples}
\label{\detokenize{api_ref/proc_independ:examples}}

\paragraph{Request}
\label{\detokenize{api_ref/proc_independ:request}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X GET \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
http://127.0.0.1:7777/v1/processes
\end{sphinxVerbatim}


\paragraph{Response}
\label{\detokenize{api_ref/proc_independ:id1}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{p}{[}
  \PYG{p}{\PYGZob{}}
    \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}primary\PYGZdq{}}
  \PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{p}{\PYGZob{}}
    \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}vf\PYGZdq{}}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}client\PYGZhy{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}
  \PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{p}{\PYGZob{}}
    \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}nfv\PYGZdq{}}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}client\PYGZhy{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{GET /v1/cpu\_layout}
\label{\detokenize{api_ref/proc_independ:get-v1-cpu-layout}}
Show CPU layout of a server on which \sphinxcode{\sphinxupquote{spp-ctl}} running.


\subsubsection{Response}
\label{\detokenize{api_ref/proc_independ:id2}}
An array of CPU socket params which consists of each of physical core ID and
logical cores if hyper threading is enabled.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response code of CPU layout.}\label{\detokenize{api_ref/proc_independ:id12}}\label{\detokenize{api_ref/proc_independ:table-spp-ctl-cpu-layout-codes}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Value
&\sphinxstyletheadfamily 
Description
\\
\hline
200
&
Normal response code.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response params of getting CPU layout.}\label{\detokenize{api_ref/proc_independ:id13}}\label{\detokenize{api_ref/proc_independ:table-spp-ctl-cpu-layout-params}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
cores
&
array
&
Set of cores on a socket.
\\
\hline
core\_id
&
integer
&
ID of physical core.
\\
\hline
lcores
&
array
&
Set of IDs of logical cores.
\\
\hline
socket\_id
&
integer
&
Socket ID.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Examples}
\label{\detokenize{api_ref/proc_independ:id3}}

\paragraph{Request}
\label{\detokenize{api_ref/proc_independ:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X GET \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
http://127.0.0.1:7777/v1/cpu\PYGZus{}layout
\end{sphinxVerbatim}


\paragraph{Response}
\label{\detokenize{api_ref/proc_independ:id5}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{p}{[}
  \PYG{p}{\PYGZob{}}
    \PYG{n+nt}{\PYGZdq{}cores\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
      \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}core\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}lcores\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
      \PYG{p}{\PYGZcb{}}\PYG{p}{,}
      \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}core\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}lcores\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
      \PYG{p}{\PYGZcb{}}\PYG{p}{,}
      \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}core\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}lcores\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
      \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}core\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}lcores\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{]}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}socket\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{GET /v1/cpu\_usage}
\label{\detokenize{api_ref/proc_independ:get-v1-cpu-usage}}
Show CPU usage of a server on which \sphinxcode{\sphinxupquote{spp-ctl}} running.


\subsubsection{Response}
\label{\detokenize{api_ref/proc_independ:id6}}
An array of CPU usage of each of SPP processes. This usage consists of
two params, master lcore and lcore set including master and slaves.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response code of CPU layout.}\label{\detokenize{api_ref/proc_independ:id14}}\label{\detokenize{api_ref/proc_independ:table-spp-ctl-cpu-usage-codes}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Value
&\sphinxstyletheadfamily 
Description
\\
\hline
200
&
Normal response code.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response params of getting CPU layout.}\label{\detokenize{api_ref/proc_independ:id15}}\label{\detokenize{api_ref/proc_independ:table-spp-ctl-cpu-usage-params}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
proc-type
&
string
&
Proc type such as \sphinxcode{\sphinxupquote{primary}}, \sphinxcode{\sphinxupquote{nfv}} or so.
\\
\hline
master-lcore
&
integer
&
Lcore ID of master.
\\
\hline
lcores
&
array
&
All of Lcore IDs including master and slaves.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Examples}
\label{\detokenize{api_ref/proc_independ:id7}}

\paragraph{Request}
\label{\detokenize{api_ref/proc_independ:id8}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X GET \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
http://127.0.0.1:7777/v1/cpu\PYGZus{}usage
\end{sphinxVerbatim}


\paragraph{Response}
\label{\detokenize{api_ref/proc_independ:id9}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{p}{[}
  \PYG{p}{\PYGZob{}}
    \PYG{n+nt}{\PYGZdq{}proc\PYGZhy{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}primary\PYGZdq{}}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}master\PYGZhy{}lcore\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}lcores\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
      \PYG{l+m+mi}{0}
    \PYG{p}{]}
  \PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{p}{\PYGZob{}}
    \PYG{n+nt}{\PYGZdq{}proc\PYGZhy{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}nfv\PYGZdq{}}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}client\PYGZhy{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}master\PYGZhy{}lcore\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}lcores\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}
  \PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{p}{\PYGZob{}}
    \PYG{n+nt}{\PYGZdq{}proc\PYGZhy{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}vf\PYGZdq{}}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}client\PYGZhy{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}master\PYGZhy{}lcore\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}lcores\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{]}
\end{sphinxVerbatim}


\section{spp\_primary}
\label{\detokenize{api_ref/spp_primary:spp-primary}}\label{\detokenize{api_ref/spp_primary:spp-ctl-rest-api-spp-primary}}\label{\detokenize{api_ref/spp_primary::doc}}

\subsection{GET /v1/primary/status}
\label{\detokenize{api_ref/spp_primary:get-v1-primary-status}}
Show statistical information.
\begin{itemize}
\item {} 
Normal response codes: 200

\end{itemize}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_primary:request-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X GET \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/primary/status
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_primary:response}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response params of primary status.}\label{\detokenize{api_ref/spp_primary:id21}}\label{\detokenize{api_ref/spp_primary:table-spp-ctl-primary-status}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
lcores
&
array
&
Array of lcores spp\_primary is using.
\\
\hline
phy\_ports
&
array
&
Array of statistics of physical ports.
\\
\hline
ring\_ports
&
array
&
Array of statistics of ring ports.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Physical port object.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Attributes of physical port of primary status.}\label{\detokenize{api_ref/spp_primary:id22}}\label{\detokenize{api_ref/spp_primary:table-spp-ctl-primary-status-phy}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
id
&
integer
&
Port ID of the physical port.
\\
\hline
rx
&
integer
&
The total number of received packets.
\\
\hline
tx
&
integer
&
The total number of transferred packets.
\\
\hline
tx\_drop
&
integer
&
The total number of dropped packets of transferred.
\\
\hline
eth
&
string
&
MAC address of the port.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Ring port object.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Attributes of ring port of primary status.}\label{\detokenize{api_ref/spp_primary:id23}}\label{\detokenize{api_ref/spp_primary:table-spp-ctl-primary-status-ring}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
id
&
integer
&
Port ID of the ring port.
\\
\hline
rx
&
integer
&
The total number of received packets.
\\
\hline
rx\_drop
&
integer
&
The total number of dropped packets of received.
\\
\hline
tx
&
integer
&
The total number of transferred packets.
\\
\hline
tx\_drop
&
integer
&
The total number of dropped packets of transferred.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Response example}
\label{\detokenize{api_ref/spp_primary:response-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{p}{\PYGZob{}}
  \PYG{n+nt}{\PYGZdq{}lcores\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{l+m+mi}{0}
  \PYG{p}{]}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}phy\PYGZus{}ports\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZus{}drop\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}eth\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}56:48:4f:53:54:00\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZus{}drop\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}eth\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}56:48:4f:53:54:01\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}ring\PYGZus{}ports\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZus{}drop\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZus{}drop\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZus{}drop\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZus{}drop\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZus{}drop\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZus{}drop\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{PUT /v1/primary/forward}
\label{\detokenize{api_ref/spp_primary:put-v1-primary-forward}}
Start or stop forwarding.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_primary:id1}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}start\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/primary/forward
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_primary:id2}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{PUT}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_primary:equivalent-cli-command}}
Action is \sphinxcode{\sphinxupquote{start}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pri; forward
\end{sphinxVerbatim}

Action is \sphinxcode{\sphinxupquote{stop}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pri; stop
\end{sphinxVerbatim}


\subsection{PUT /v1/primary/ports}
\label{\detokenize{api_ref/spp_primary:put-v1-primary-ports}}
Add or delete port.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_primary:request-body}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request body params of ports of \sphinxstyleliteralintitle{\sphinxupquote{spp\_primary}}.}\label{\detokenize{api_ref/spp_primary:id24}}\label{\detokenize{api_ref/spp_primary:table-spp-ctl-spp-primary-ports-get-body}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
action
&
string
&
\sphinxcode{\sphinxupquote{add}} or \sphinxcode{\sphinxupquote{del}}.
\\
\hline
port
&
string
&
Resource UID of \{port\_type\}:\{port\_id\}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_primary:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}add\PYGZdq{}, \PYGZdq{}port\PYGZdq{}: \PYGZdq{}ring:0\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/primary/ports
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_primary:id4}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{PUT}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_primary:id5}}
Not supported in SPP CLI.


\subsection{DELETE /v1/primary/status}
\label{\detokenize{api_ref/spp_primary:delete-v1-primary-status}}
Clear statistical information.
\begin{itemize}
\item {} 
Normal response codes: 204

\end{itemize}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_primary:id6}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X DELETE \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/primary/status
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_primary:id7}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{DELETE}} request.


\subsection{PUT /v1/primary/patches}
\label{\detokenize{api_ref/spp_primary:put-v1-primary-patches}}
Add a patch.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_primary:id8}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request body params of patches of \sphinxstyleliteralintitle{\sphinxupquote{spp\_primary}}.}\label{\detokenize{api_ref/spp_primary:id25}}\label{\detokenize{api_ref/spp_primary:table-spp-ctl-spp-primary-ports-patches-body}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
src
&
string
&
Source port id.
\\
\hline
dst
&
string
&
Destination port id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_primary:id9}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}src\PYGZdq{}: \PYGZdq{}ring:0\PYGZdq{}, \PYGZdq{}dst\PYGZdq{}: \PYGZdq{}ring:1\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/primary/patches
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_primary:id10}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{PUT}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_primary:id11}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pri; patch \PYGZob{}src\PYGZcb{} \PYGZob{}dst\PYGZcb{}
\end{sphinxVerbatim}


\subsection{DELETE /v1/primary/patches}
\label{\detokenize{api_ref/spp_primary:delete-v1-primary-patches}}
Reset patches.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_primary:id12}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X DELETE \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/primary/patches
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_primary:id13}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{DELETE}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_primary:id14}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pri; patch reset
\end{sphinxVerbatim}


\subsection{DELETE /v1/primary}
\label{\detokenize{api_ref/spp_primary:delete-v1-primary}}
Terminate primary process.
\begin{itemize}
\item {} 
Normal response codes: 204

\end{itemize}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_primary:id15}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X DELETE \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/primary
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_primary:id16}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{DELETE}} request.


\subsection{PUT /v1/primary/launch}
\label{\detokenize{api_ref/spp_primary:put-v1-primary-launch}}
Launch a secondary process.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_primary:id17}}
There are four params for launching secondary process. \sphinxcode{\sphinxupquote{eal}} object
contains a set of EAL options, and \sphinxcode{\sphinxupquote{app}} contains options of teh process.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request body params for launch secondary for spp\_primary.}\label{\detokenize{api_ref/spp_primary:id26}}\label{\detokenize{api_ref/spp_primary:table-spp-ctl-spp-primary-launch-body}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
proc\_name
&
string
&
Process name such as \sphinxcode{\sphinxupquote{spp\_nfv}} or \sphinxcode{\sphinxupquote{spp\_vf}}.
\\
\hline
client\_id
&
integer
&
Secondary ID for the process.
\\
\hline
eal
&
object
&
Hash obj of DPDK’s EAL options.
\\
\hline
app
&
object
&
Hash obj of options of secondary process.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\sphinxupquote{eal}} object is a hash of EAL options and its values. All of EAL options
are referred in
\sphinxhref{https://doc.dpdk.org/guides/linux\_gsg/linux\_eal\_parameters.html}{EAL parameters}
in DPDK’s
\sphinxhref{https://doc.dpdk.org/guides/linux\_gsg/index.html}{Getting Started Guide for Linux}.

\sphinxcode{\sphinxupquote{app}} object is a hash of options of secondary process, and you can refer
options of each of processes in
\sphinxhref{https://spp-tmp.readthedocs.io/en/latest/setup/howto\_use.html}{How to Use}
section.


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_primary:id18}}
Launch \sphinxcode{\sphinxupquote{spp\_nfv}} with secondary ID 1 and lcores \sphinxcode{\sphinxupquote{1,2}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{}\PYGZob{}\PYGZsq{}proc\PYGZus{}name\PYGZsq{}: \PYGZsq{}spp\PYGZus{}nfv\PYGZsq{}, \PYGZsq{}client\PYGZus{}id\PYGZsq{}: \PYGZsq{}1\PYGZsq{}, \PYGZbs{}}
\PYG{l+s+s2}{    \PYGZsq{}eal\PYGZsq{}: \PYGZob{}\PYGZsq{}\PYGZhy{}m\PYGZsq{}: \PYGZsq{}512\PYGZsq{}, \PYGZsq{}\PYGZhy{}l\PYGZsq{}: \PYGZsq{}1,2\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}proc\PYGZhy{}type\PYGZsq{}: \PYGZsq{}secondary\PYGZsq{}\PYGZcb{}, \PYGZbs{}}
\PYG{l+s+s2}{    \PYGZsq{}app\PYGZsq{}: \PYGZob{}\PYGZsq{}\PYGZhy{}s\PYGZsq{}: \PYGZsq{}192.168.11.59:6666\PYGZsq{}, \PYGZsq{}\PYGZhy{}n\PYGZsq{}: \PYGZsq{}1\PYGZsq{}\PYGZcb{}\PYGZcb{}\PYGZdq{}}
\PYG{g+go}{  http://127.0.0.1:7777/v1/primary/launch}
\end{sphinxVerbatim}

Launch \sphinxcode{\sphinxupquote{spp\_vf}} with secondary ID 2 and lcores \sphinxcode{\sphinxupquote{1,4-7}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{}\PYGZob{}\PYGZsq{}proc\PYGZus{}name\PYGZsq{}: \PYGZsq{}spp\PYGZus{}vf\PYGZsq{}, \PYGZsq{}client\PYGZus{}id\PYGZsq{}: \PYGZsq{}2\PYGZsq{}, \PYGZbs{}}
\PYG{l+s+s2}{    \PYGZsq{}eal\PYGZsq{}: \PYGZob{}\PYGZsq{}\PYGZhy{}m\PYGZsq{}: \PYGZsq{}512\PYGZsq{}, \PYGZsq{}\PYGZhy{}l\PYGZsq{}: \PYGZsq{}1,4\PYGZhy{}7\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}proc\PYGZhy{}type\PYGZsq{}: \PYGZsq{}secondary\PYGZsq{}\PYGZcb{}, \PYGZbs{}}
\PYG{l+s+s2}{    \PYGZsq{}app\PYGZsq{}: \PYGZob{}\PYGZsq{}\PYGZhy{}s\PYGZsq{}: \PYGZsq{}192.168.11.59:6666\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}client\PYGZhy{}id\PYGZsq{}: \PYGZsq{}2\PYGZsq{}\PYGZcb{}\PYGZcb{}\PYGZdq{}}
\PYG{g+go}{  http://127.0.0.1:7777/v1/primary/launch}
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_primary:id19}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{PUT}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_primary:id20}}
\sphinxcode{\sphinxupquote{proc\_type}} is \sphinxcode{\sphinxupquote{nfv}}, \sphinxcode{\sphinxupquote{vf}} or \sphinxcode{\sphinxupquote{mirror}} or so.
\sphinxcode{\sphinxupquote{eal\_opts}} and \sphinxcode{\sphinxupquote{app\_opts}} are the same as launching from command line.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
pri; launch \PYGZob{}proc\PYGZus{}type\PYGZcb{} \PYGZob{}sec\PYGZus{}id\PYGZcb{} \PYGZob{}eal\PYGZus{}opts\PYGZcb{} \PYGZhy{}\PYGZhy{} \PYGZob{}app\PYGZus{}opts\PYGZcb{}
\end{sphinxVerbatim}


\section{spp\_nfv}
\label{\detokenize{api_ref/spp_nfv:spp-nfv}}\label{\detokenize{api_ref/spp_nfv:spp-ctl-rest-api-spp-nfv}}\label{\detokenize{api_ref/spp_nfv::doc}}

\subsection{GET /v1/nfvs/\{client\_id\}}
\label{\detokenize{api_ref/spp_nfv:get-v1-nfvs-client-id}}
Get the information of \sphinxcode{\sphinxupquote{spp\_nfv}}.
\begin{itemize}
\item {} 
Normal response codes: 200

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_nfv:request-path}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request parameter for getting info of \sphinxstyleliteralintitle{\sphinxupquote{spp\_nfv}}.}\label{\detokenize{api_ref/spp_nfv:id23}}\label{\detokenize{api_ref/spp_nfv:table-spp-ctl-nfvs-get}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_nfv:request-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X GET \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/nfvs/1
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_nfv:response}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response params of getting info of \sphinxstyleliteralintitle{\sphinxupquote{spp\_nfv}}.}\label{\detokenize{api_ref/spp_nfv:id24}}\label{\detokenize{api_ref/spp_nfv:table-spp-ctl-spp-nfv-res}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client-id
&
integer
&
client id.
\\
\hline
status
&
string
&
\sphinxcode{\sphinxupquote{running}} or \sphinxcode{\sphinxupquote{idling}}.
\\
\hline
ports
&
array
&
an array of port ids used by the process.
\\
\hline
patches
&
array
&
an array of patches.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Patch ports.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Attributes of patch command of \sphinxstyleliteralintitle{\sphinxupquote{spp\_nfv}}.}\label{\detokenize{api_ref/spp_nfv:id25}}\label{\detokenize{api_ref/spp_nfv:table-spp-ctl-patch-spp-nfv}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
src
&
string
&
source port id.
\\
\hline
dst
&
string
&
destination port id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Response example}
\label{\detokenize{api_ref/spp_nfv:response-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{p}{\PYGZob{}}
  \PYG{n+nt}{\PYGZdq{}client\PYGZhy{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}status\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}running\PYGZdq{}}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}ports\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{l+s+s2}{\PYGZdq{}phy:0\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}phy:1\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}vhost:0\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}vhost:1\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}ring:0\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}ring:1\PYGZdq{}}
  \PYG{p}{]}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}patches\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}src\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}vhost:0\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}dst\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:0\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}src\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:1\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}dst\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}vhost:1\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_nfv:equivalent-cli-command}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} nfv \PYGZob{}client\PYGZus{}id\PYGZcb{}; status
\end{sphinxVerbatim}


\subsection{PUT /v1/nfvs/\{client\_id\}/forward}
\label{\detokenize{api_ref/spp_nfv:put-v1-nfvs-client-id-forward}}
Start or Stop forwarding.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_nfv:id1}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params of forward command of \sphinxstyleliteralintitle{\sphinxupquote{spp\_nfv}}.}\label{\detokenize{api_ref/spp_nfv:id26}}\label{\detokenize{api_ref/spp_nfv:table-spp-ctl-spp-nfv-forward-get}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_nfv:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}start\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/nfvs/1/forward
\end{sphinxVerbatim}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_nfv:request-body}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request body params of forward of \sphinxstyleliteralintitle{\sphinxupquote{spp\_nfv}}.}\label{\detokenize{api_ref/spp_nfv:id27}}\label{\detokenize{api_ref/spp_nfv:table-spp-ctl-spp-nfv-forward-get-body}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
action
&
string
&
\sphinxcode{\sphinxupquote{start}} or \sphinxcode{\sphinxupquote{stop}}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_nfv:id3}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{PUT}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_nfv:id4}}
Action is \sphinxcode{\sphinxupquote{start}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} nfv \PYGZob{}client\PYGZus{}id\PYGZcb{}; forward
\end{sphinxVerbatim}

Action is \sphinxcode{\sphinxupquote{stop}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} nfv \PYGZob{}client\PYGZus{}id\PYGZcb{}; stop
\end{sphinxVerbatim}


\subsection{PUT /v1/nfvs/\{client\_id\}/ports}
\label{\detokenize{api_ref/spp_nfv:put-v1-nfvs-client-id-ports}}
Add or delete port.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request(path)}
\label{\detokenize{api_ref/spp_nfv:id5}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params of ports of \sphinxstyleliteralintitle{\sphinxupquote{spp\_nfv}}.}\label{\detokenize{api_ref/spp_nfv:id28}}\label{\detokenize{api_ref/spp_nfv:table-spp-ctl-spp-nfv-ports-get}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_nfv:id6}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request body params of ports of \sphinxstyleliteralintitle{\sphinxupquote{spp\_nfv}}.}\label{\detokenize{api_ref/spp_nfv:id29}}\label{\detokenize{api_ref/spp_nfv:table-spp-ctl-spp-nfv-ports-get-body}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
action
&
string
&
\sphinxcode{\sphinxupquote{add}} or \sphinxcode{\sphinxupquote{del}}.
\\
\hline
port
&
string
&
port id. port id is the form \{interface\_type\}:\{interface\_id\}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_nfv:id7}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}add\PYGZdq{}, \PYGZdq{}port\PYGZdq{}: \PYGZdq{}ring:0\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/nfvs/1/ports
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_nfv:id8}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{PUT}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_nfv:id9}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} nfv \PYGZob{}client\PYGZus{}id\PYGZcb{}; \PYGZob{}action\PYGZcb{} \PYGZob{}if\PYGZus{}type\PYGZcb{} \PYGZob{}if\PYGZus{}id\PYGZcb{}
\end{sphinxVerbatim}


\subsection{PUT /v1/nfvs/\{client\_id\}/patches}
\label{\detokenize{api_ref/spp_nfv:put-v1-nfvs-client-id-patches}}
Add a patch.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_nfv:id10}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params of patches of \sphinxstyleliteralintitle{\sphinxupquote{spp\_nfv}}.}\label{\detokenize{api_ref/spp_nfv:id30}}\label{\detokenize{api_ref/spp_nfv:table-spp-ctl-spp-nfv-patches-get}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_nfv:id11}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request body params of patches of \sphinxstyleliteralintitle{\sphinxupquote{spp\_nfv}}.}\label{\detokenize{api_ref/spp_nfv:id31}}\label{\detokenize{api_ref/spp_nfv:table-spp-ctl-spp-nfv-ports-patches-body}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
src
&
string
&
source port id.
\\
\hline
dst
&
string
&
destination port id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_nfv:id12}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}src\PYGZdq{}: \PYGZdq{}ring:0\PYGZdq{}, \PYGZdq{}dst\PYGZdq{}: \PYGZdq{}ring:1\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/nfvs/1/patches
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_nfv:id13}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{PUT}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_nfv:id14}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} nfv \PYGZob{}client\PYGZus{}id\PYGZcb{}; patch \PYGZob{}src\PYGZcb{} \PYGZob{}dst\PYGZcb{}
\end{sphinxVerbatim}


\subsection{DELETE /v1/nfvs/\{client\_id\}/patches}
\label{\detokenize{api_ref/spp_nfv:delete-v1-nfvs-client-id-patches}}
Reset patches.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_nfv:id15}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params of deleting patches of \sphinxstyleliteralintitle{\sphinxupquote{spp\_nfv}}.}\label{\detokenize{api_ref/spp_nfv:id32}}\label{\detokenize{api_ref/spp_nfv:table-spp-ctl-spp-nfv-del-patches}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_nfv:id16}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X DELETE \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/nfvs/1/patches
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_nfv:id17}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{DELETE}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_nfv:id18}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} nfv \PYGZob{}client\PYGZus{}id\PYGZcb{}; patch reset
\end{sphinxVerbatim}


\subsection{DELETE /v1/nfvs/\{client\_id\}}
\label{\detokenize{api_ref/spp_nfv:delete-v1-nfvs-client-id}}
Terminate \sphinxcode{\sphinxupquote{spp\_nfv}}.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_nfv:id19}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request parameter for terminating \sphinxstyleliteralintitle{\sphinxupquote{spp\_nfv}}.}\label{\detokenize{api_ref/spp_nfv:id33}}\label{\detokenize{api_ref/spp_nfv:table-spp-ctl-nfvs-delete}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_nfv:id20}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X DELETE \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/nfvs/1
\end{sphinxVerbatim}


\subsubsection{Response example}
\label{\detokenize{api_ref/spp_nfv:id21}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{DELETE}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_nfv:id22}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} nfv \PYGZob{}client\PYGZus{}id\PYGZcb{}; exit
\end{sphinxVerbatim}


\section{spp\_vf}
\label{\detokenize{api_ref/spp_vf:spp-vf}}\label{\detokenize{api_ref/spp_vf:spp-ctl-rest-api-spp-vf}}\label{\detokenize{api_ref/spp_vf::doc}}

\subsection{GET /v1/vfs/\{client\_id\}}
\label{\detokenize{api_ref/spp_vf:get-v1-vfs-client-id}}
Get the information of the \sphinxcode{\sphinxupquote{spp\_vf}} process.
\begin{itemize}
\item {} 
Normal response codes: 200

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_vf:request-path}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request parameter for getting spp\_vf.}\label{\detokenize{api_ref/spp_vf:id19}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-vfs-get}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_vf:request-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X GET \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/vfs/1
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_vf:response}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response params of getting spp\_vf.}\label{\detokenize{api_ref/spp_vf:id20}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-res}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client-id
&
integer
&
Client id.
\\
\hline
ports
&
array
&
Array of port ids used by the process.
\\
\hline
components
&
array
&
Array of component objects in the process.
\\
\hline
classifier\_table
&
array
&
Array of classifier tables in the process.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Component objects:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Component objects of getting spp\_vf.}\label{\detokenize{api_ref/spp_vf:id21}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-res-comp}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
core
&
integer
&
Core id running on the component
\\
\hline
name
&
string
&
Array of port ids used by the process.
\\
\hline
type
&
string
&
Array of component objects in the process.
\\
\hline
rx\_port
&
array
&
Array of port objs connected to rx of component.
\\
\hline
tx\_port
&
array
&
Array of port objs connected to tx of component.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Port objects:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Port objects of getting spp\_vf.}\label{\detokenize{api_ref/spp_vf:id22}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-res-port}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
port
&
string
&
port id of \{interface\_type\}:\{interface\_id\}.
\\
\hline
vlan
&
object
&
vlan operation which is applied to the port.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Vlan objects:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Vlan objects of getting spp\_vf.}\label{\detokenize{api_ref/spp_vf:id23}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-res-vlan}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
operation
&
string
&
\sphinxcode{\sphinxupquote{add}}, \sphinxcode{\sphinxupquote{del}} or \sphinxcode{\sphinxupquote{none}}.
\\
\hline
id
&
integer
&
vlan id.
\\
\hline
pcp
&
integer
&
vlan pcp.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Classifier table:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Vlan objects of getting spp\_vf.}\label{\detokenize{api_ref/spp_vf:id24}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-res-cls}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
type
&
string
&
\sphinxcode{\sphinxupquote{mac}} or \sphinxcode{\sphinxupquote{vlan}}.
\\
\hline
value
&
string
&
mac\_address or vlan\_id/mac\_address.
\\
\hline
port
&
string
&
port id applied to classify.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Response example}
\label{\detokenize{api_ref/spp_vf:response-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{p}{\PYGZob{}}
  \PYG{n+nt}{\PYGZdq{}client\PYGZhy{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}ports\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{l+s+s2}{\PYGZdq{}phy:0\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}phy:1\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}vhost:0\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}vhost:1\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}ring:0\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}ring:1\PYGZdq{}}
  \PYG{p}{]}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}components\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}fwd0\PYGZus{}tx\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}forward\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZus{}port\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:0\PYGZdq{}}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}vlan\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}operation\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}none\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}pcp\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZus{}port\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}vhost:0\PYGZdq{}}\PYG{p}{,}
          \PYG{n+nt}{\PYGZdq{}vlan\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}operation\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}none\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}pcp\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}unuse\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}unuse\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{5}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}fwd1\PYGZus{}rx\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}forward\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZus{}port\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}vhost:1\PYGZdq{}}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}vlan\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}operation\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}none\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}pcp\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZus{}port\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:3\PYGZdq{}}\PYG{p}{,}
          \PYG{n+nt}{\PYGZdq{}vlan\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}operation\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}none\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}pcp\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{6}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}cls\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}classifier\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZus{}port\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}phy:0\PYGZdq{}}\PYG{p}{,}
          \PYG{n+nt}{\PYGZdq{}vlan\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}operation\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}none\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}pcp\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZus{}port\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:0\PYGZdq{}}\PYG{p}{,}
          \PYG{n+nt}{\PYGZdq{}vlan\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}operation\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}none\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}pcp\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:2\PYGZdq{}}\PYG{p}{,}
          \PYG{n+nt}{\PYGZdq{}vlan\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}operation\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}none\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}pcp\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{7}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}mgr1\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}merge\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZus{}port\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:1\PYGZdq{}}\PYG{p}{,}
          \PYG{n+nt}{\PYGZdq{}vlan\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}operation\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}none\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}pcp\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:3\PYGZdq{}}\PYG{p}{,}
          \PYG{n+nt}{\PYGZdq{}vlan\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}operation\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}none\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}pcp\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZus{}port\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}phy:0\PYGZdq{}}\PYG{p}{,}
          \PYG{n+nt}{\PYGZdq{}vlan\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}operation\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}none\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}pcp\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{p}{]}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}classifier\PYGZus{}table\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}mac\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}value\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}FA:16:3E:7D:CC:35\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:0\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The component which type is \sphinxcode{\sphinxupquote{unused}} is to indicate unused core.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_vf:equivalent-cli-command}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} vf \PYGZob{}client\PYGZus{}id\PYGZcb{}; status
\end{sphinxVerbatim}


\subsection{POST /v1/vfs/\{client\_id\}/components}
\label{\detokenize{api_ref/spp_vf:post-v1-vfs-client-id-components}}
Start component.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_vf:id1}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params of components of spp\_vf.}\label{\detokenize{api_ref/spp_vf:id25}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-components}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_vf:request-body}}
\sphinxcode{\sphinxupquote{type}} param is oen of \sphinxcode{\sphinxupquote{forwarder}}, \sphinxcode{\sphinxupquote{merger}} or \sphinxcode{\sphinxupquote{classifier}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response params of components of spp\_vf.}\label{\detokenize{api_ref/spp_vf:id26}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-components-res}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
name
&
string
&
component name should be unique among processes.
\\
\hline
core
&
integer
&
core id.
\\
\hline
type
&
string
&
component type.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_vf:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X POST \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}name\PYGZdq{}: \PYGZdq{}fwd1\PYGZdq{}, \PYGZdq{}core\PYGZdq{}: 12, \PYGZdq{}type\PYGZdq{}: \PYGZdq{}forwarder\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/vfs/1/components
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_vf:id3}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{POST}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_vf:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} vf \PYGZob{}client\PYGZus{}id\PYGZcb{}; component start \PYGZob{}name\PYGZcb{} \PYGZob{}core\PYGZcb{} \PYGZob{}type\PYGZcb{}
\end{sphinxVerbatim}


\subsection{DELETE /v1/vfs/\{sec id\}/components/\{name\}}
\label{\detokenize{api_ref/spp_vf:delete-v1-vfs-sec-id-components-name}}
Stop component.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_vf:id5}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params of deleting component of spp\_vf.}\label{\detokenize{api_ref/spp_vf:id27}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-del}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
name
&
string
&
component name.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_vf:id6}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X DELETE \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/vfs/1/components/fwd1
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_vf:id7}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{POST}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_vf:id8}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} vf \PYGZob{}client\PYGZus{}id\PYGZcb{}; component stop \PYGZob{}name\PYGZcb{}
\end{sphinxVerbatim}


\subsection{PUT /v1/vfs/\{client\_id\}/components/\{name\}/ports}
\label{\detokenize{api_ref/spp_vf:put-v1-vfs-client-id-components-name-ports}}
Add or delete port to the component.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_vf:id9}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params for ports of component of spp\_vf.}\label{\detokenize{api_ref/spp_vf:id28}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-comp-port}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
name
&
string
&
component name.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_vf:id10}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request body params for ports of component of spp\_vf.}\label{\detokenize{api_ref/spp_vf:id29}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-comp-port-body}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
action
&
string
&
\sphinxcode{\sphinxupquote{attach}} or \sphinxcode{\sphinxupquote{detach}}.
\\
\hline
port
&
string
&
port id of \{interface\_type\}:\{interface\_id\}.
\\
\hline
dir
&
string
&
\sphinxcode{\sphinxupquote{rx}} or \sphinxcode{\sphinxupquote{tx}}.
\\
\hline
vlan
&
object
&
vlan operation applied to port. it can be omitted.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Vlan object:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request body params for vlan ports of component of spp\_vf.}\label{\detokenize{api_ref/spp_vf:id30}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-comp-port-body-vlan}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
operation
&
string
&
\sphinxcode{\sphinxupquote{add}}, \sphinxcode{\sphinxupquote{del}} or \sphinxcode{\sphinxupquote{none}}.
\\
\hline
id
&
integer
&
vid. ignored if operation is \sphinxcode{\sphinxupquote{del}} or \sphinxcode{\sphinxupquote{none}}.
\\
\hline
pcp
&
integer
&
pcp. ignored if operation is \sphinxcode{\sphinxupquote{del}} or \sphinxcode{\sphinxupquote{none}}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_vf:id11}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}attach\PYGZdq{}, \PYGZdq{}port\PYGZdq{}: \PYGZdq{}vhost:1\PYGZdq{}, \PYGZdq{}dir\PYGZdq{}: \PYGZdq{}rx\PYGZdq{}, \PYGZbs{}}
\PYG{l+s+s1}{       \PYGZdq{}vlan\PYGZdq{}: \PYGZob{}\PYGZdq{}operation\PYGZdq{}: \PYGZdq{}add\PYGZdq{}, \PYGZdq{}id\PYGZdq{}: 677, \PYGZdq{}pcp\PYGZdq{}: 0\PYGZcb{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/vfs/1/components/fwd1/ports
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}detach\PYGZdq{}, \PYGZdq{}port\PYGZdq{}: \PYGZdq{}vhost:0\PYGZdq{}, \PYGZdq{}dir\PYGZdq{}: \PYGZdq{}tx\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/vfs/1/components/fwd1/ports
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_vf:id12}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{PUT}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_vf:id13}}
Action is \sphinxcode{\sphinxupquote{attach}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} vf \PYGZob{}client\PYGZus{}id\PYGZcb{}; port add \PYGZob{}port\PYGZcb{} \PYGZob{}dir\PYGZcb{} \PYGZob{}name\PYGZcb{}
\end{sphinxVerbatim}

Action is \sphinxcode{\sphinxupquote{attach}} with vlan tag feature.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZsh{} Add vlan tag
spp \PYGZgt{} vf \PYGZob{}client\PYGZus{}id\PYGZcb{}; port add \PYGZob{}port\PYGZcb{} \PYGZob{}dir\PYGZcb{} \PYGZob{}name\PYGZcb{} add\PYGZus{}vlantag \PYGZob{}id\PYGZcb{} \PYGZob{}pcp\PYGZcb{}

\PYGZsh{} Delete vlan tag
spp \PYGZgt{} vf \PYGZob{}client\PYGZus{}id\PYGZcb{}; port add \PYGZob{}port\PYGZcb{} \PYGZob{}dir\PYGZcb{} \PYGZob{}name\PYGZcb{} del\PYGZus{}vlantag
\end{sphinxVerbatim}

Action is \sphinxcode{\sphinxupquote{detach}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} vf \PYGZob{}client\PYGZus{}id\PYGZcb{}; port del \PYGZob{}port\PYGZcb{} \PYGZob{}dir\PYGZcb{} \PYGZob{}name\PYGZcb{}
\end{sphinxVerbatim}


\subsection{PUT /v1/vfs/\{sec id\}/classifier\_table}
\label{\detokenize{api_ref/spp_vf:put-v1-vfs-sec-id-classifier-table}}
Set or Unset classifier table.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_vf:id14}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params for classifier\_table of spp\_vf.}\label{\detokenize{api_ref/spp_vf:id31}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-cls-table}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_vf:id15}}
For \sphinxcode{\sphinxupquote{vlan}} param, it can be omitted if it is for \sphinxcode{\sphinxupquote{mac}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request body params for classifier\_table of spp\_vf.}\label{\detokenize{api_ref/spp_vf:id32}}\label{\detokenize{api_ref/spp_vf:table-spp-ctl-spp-vf-cls-table-body}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
action
&
string
&
\sphinxcode{\sphinxupquote{add}} or \sphinxcode{\sphinxupquote{del}}.
\\
\hline
type
&
string
&
\sphinxcode{\sphinxupquote{mac}} or \sphinxcode{\sphinxupquote{vlan}}.
\\
\hline
vlan
&
integer or null
&
vlan id for \sphinxcode{\sphinxupquote{vlan}}. null for \sphinxcode{\sphinxupquote{mac}}.
\\
\hline
mac\_address
&
string
&
mac address.
\\
\hline
port
&
string
&
port id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_vf:id16}}
Add an entry of port \sphinxcode{\sphinxupquote{ring:0}} with MAC address \sphinxcode{\sphinxupquote{FA:16:3E:7D:CC:35}} to
the table.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}add\PYGZdq{}, \PYGZdq{}type\PYGZdq{}: \PYGZdq{}mac\PYGZdq{}, \PYGZbs{}}
\PYG{l+s+s1}{     \PYGZdq{}mac\PYGZus{}address\PYGZdq{}: \PYGZdq{}FA:16:3E:7D:CC:35\PYGZdq{}, \PYGZbs{}}
\PYG{l+s+s1}{     \PYGZdq{}port\PYGZdq{}: \PYGZdq{}ring:0\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/vfs/1/classifier\PYGZus{}table
\end{sphinxVerbatim}

Delete an entry of port \sphinxcode{\sphinxupquote{ring:0}} with MAC address \sphinxcode{\sphinxupquote{FA:16:3E:7D:CC:35}} from
the table.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}del\PYGZdq{}, \PYGZdq{}type\PYGZdq{}: \PYGZdq{}vlan\PYGZdq{}, \PYGZdq{}vlan\PYGZdq{}: 475, \PYGZbs{}}
\PYG{l+s+s1}{     \PYGZdq{}mac\PYGZus{}address\PYGZdq{}: \PYGZdq{}FA:16:3E:7D:CC:35\PYGZdq{}, \PYGZdq{}port\PYGZdq{}: \PYGZdq{}ring:0\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/vfs/1/classifier\PYGZus{}table
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_vf:id17}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{PUT}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_vf:id18}}
Type is \sphinxcode{\sphinxupquote{mac}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} vf \PYGZob{}cli\PYGZus{}id\PYGZcb{}; classifier\PYGZus{}table \PYGZob{}action\PYGZcb{} mac \PYGZob{}mac\PYGZus{}addr\PYGZcb{} \PYGZob{}port\PYGZcb{}
\end{sphinxVerbatim}

Type is \sphinxcode{\sphinxupquote{vlan}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} vf \PYGZob{}cli\PYGZus{}id\PYGZcb{}; classifier\PYGZus{}table \PYGZob{}action\PYGZcb{} vlan \PYGZob{}vlan\PYGZcb{} \PYGZob{}mac\PYGZus{}addr\PYGZcb{} \PYGZob{}port\PYGZcb{}
\end{sphinxVerbatim}


\section{spp\_mirror}
\label{\detokenize{api_ref/spp_mirror:spp-mirror}}\label{\detokenize{api_ref/spp_mirror:spp-ctl-rest-api-spp-mirror}}\label{\detokenize{api_ref/spp_mirror::doc}}

\subsection{GET /v1/mirrors/\{client\_id\}}
\label{\detokenize{api_ref/spp_mirror:get-v1-mirrors-client-id}}
Get the information of the \sphinxcode{\sphinxupquote{spp\_mirror}} process.
\begin{itemize}
\item {} 
Normal response codes: 200

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_mirror:request-path}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request parameter for getting spp\_mirror.}\label{\detokenize{api_ref/spp_mirror:id14}}\label{\detokenize{api_ref/spp_mirror:table-spp-ctl-mirrors-get}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_mirror:request-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X GET \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/mirrors/1
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_mirror:response}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response params of getting spp\_mirror.}\label{\detokenize{api_ref/spp_mirror:id15}}\label{\detokenize{api_ref/spp_mirror:table-spp-ctl-spp-mirror-res}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client-id
&
integer
&
client id.
\\
\hline
ports
&
array
&
an array of port ids used by the process.
\\
\hline
components
&
array
&
an array of component objects in the process.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Component objects:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Component objects of getting spp\_mirror.}\label{\detokenize{api_ref/spp_mirror:id16}}\label{\detokenize{api_ref/spp_mirror:table-spp-ctl-spp-mirror-res-comp}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
core
&
integer
&
core id running on the component
\\
\hline
name
&
string
&
an array of port ids used by the process.
\\
\hline
type
&
string
&
an array of component objects in the process.
\\
\hline
rx\_port
&
array
&
an array of port objects connected to the rx side of the component.
\\
\hline
tx\_port
&
array
&
an array of port objects connected to the tx side of the component.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Port objects:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Port objects of getting spp\_vf.}\label{\detokenize{api_ref/spp_mirror:id17}}\label{\detokenize{api_ref/spp_mirror:table-spp-ctl-spp-mirror-res-port}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
port
&
string
&
port id. port id is the form \{interface\_type\}:\{interface\_id\}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Response example}
\label{\detokenize{api_ref/spp_mirror:response-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{p}{\PYGZob{}}
  \PYG{n+nt}{\PYGZdq{}client\PYGZhy{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}ports\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{l+s+s2}{\PYGZdq{}phy:0\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}phy:1\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}ring:0\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}ring:1\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}ring:2\PYGZdq{}}
  \PYG{p}{]}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}components\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}mr0\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}mirror\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZus{}port\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:0\PYGZdq{}}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}tx\PYGZus{}port\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:1\PYGZdq{}}
        \PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ring:2\PYGZdq{}}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}type\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}unuse\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The component which type is \sphinxcode{\sphinxupquote{unused}} is to indicate unused core.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_mirror:equivalent-cli-command}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} mirror \PYGZob{}client\PYGZus{}id\PYGZcb{}; status
\end{sphinxVerbatim}


\subsection{POST /v1/mirrors/\{client\_id\}/components}
\label{\detokenize{api_ref/spp_mirror:post-v1-mirrors-client-id-components}}
Start component.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_mirror:id1}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params of components of spp\_mirror.}\label{\detokenize{api_ref/spp_mirror:id18}}\label{\detokenize{api_ref/spp_mirror:table-spp-ctl-spp-mirror-components}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_mirror:request-body}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response params of components of spp\_mirror.}\label{\detokenize{api_ref/spp_mirror:id19}}\label{\detokenize{api_ref/spp_mirror:table-spp-ctl-spp-mirror-components-res}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
name
&
string
&
component name. must be unique in the process.
\\
\hline
core
&
integer
&
core id.
\\
\hline
type
&
string
&
component type. only \sphinxcode{\sphinxupquote{mirror}} is available.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_mirror:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X POST \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}name\PYGZdq{}: \PYGZdq{}mr1\PYGZdq{}, \PYGZdq{}core\PYGZdq{}: 12, \PYGZdq{}type\PYGZdq{}: \PYGZdq{}mirror\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/mirrors/1/components
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_mirror:id3}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{POST}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_mirror:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} mirror \PYGZob{}client\PYGZus{}id\PYGZcb{}; component start \PYGZob{}name\PYGZcb{} \PYGZob{}core\PYGZcb{} \PYGZob{}type\PYGZcb{}
\end{sphinxVerbatim}


\subsection{DELETE /v1/mirrors/\{client\_id\}/components/\{name\}}
\label{\detokenize{api_ref/spp_mirror:delete-v1-mirrors-client-id-components-name}}
Stop component.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_mirror:id5}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params of deleting component of spp\_mirror.}\label{\detokenize{api_ref/spp_mirror:id20}}\label{\detokenize{api_ref/spp_mirror:table-spp-ctl-spp-mirror-del}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
name
&
string
&
component name.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_mirror:id6}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X DELETE \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/mirrors/1/components/mr1
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_mirror:id7}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{POST}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_mirror:id8}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} mirror \PYGZob{}client\PYGZus{}id\PYGZcb{}; component stop \PYGZob{}name\PYGZcb{}
\end{sphinxVerbatim}


\subsection{PUT /v1/mirrors/\{client\_id\}/components/\{name\}/ports}
\label{\detokenize{api_ref/spp_mirror:put-v1-mirrors-client-id-components-name-ports}}
Add or delete port to the component.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_mirror:id9}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params for ports of component of spp\_mirror.}\label{\detokenize{api_ref/spp_mirror:id21}}\label{\detokenize{api_ref/spp_mirror:table-spp-ctl-spp-mirror-comp-port}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
name
&
string
&
component name.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_mirror:id10}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request body params for ports of component of spp\_mirror.}\label{\detokenize{api_ref/spp_mirror:id22}}\label{\detokenize{api_ref/spp_mirror:table-spp-ctl-spp-mirror-comp-port-body}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
action
&
string
&
\sphinxcode{\sphinxupquote{attach}} or \sphinxcode{\sphinxupquote{detach}}.
\\
\hline
port
&
string
&
port id. port id is the form \{interface\_type\}:\{interface\_id\}.
\\
\hline
dir
&
string
&
\sphinxcode{\sphinxupquote{rx}} or \sphinxcode{\sphinxupquote{tx}}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_mirror:id11}}
Attach rx port of \sphinxcode{\sphinxupquote{ring:1}} to component named \sphinxcode{\sphinxupquote{mr1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}attach\PYGZdq{}, \PYGZdq{}port\PYGZdq{}: \PYGZdq{}ring:1\PYGZdq{}, \PYGZdq{}dir\PYGZdq{}: \PYGZdq{}rx\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/mirrors/1/components/mr1/ports
\end{sphinxVerbatim}

Detach tx port of \sphinxcode{\sphinxupquote{ring:1}} from component named \sphinxcode{\sphinxupquote{mr1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}detach\PYGZdq{}, \PYGZdq{}port\PYGZdq{}: \PYGZdq{}ring:0\PYGZdq{}, \PYGZdq{}dir\PYGZdq{}: \PYGZdq{}tx\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/mirrors/1/components/mr1/ports
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_mirror:id12}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{PUT}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_mirror:id13}}
Action is \sphinxcode{\sphinxupquote{attach}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} mirror \PYGZob{}client\PYGZus{}id\PYGZcb{}; port add \PYGZob{}port\PYGZcb{} \PYGZob{}dir\PYGZcb{} \PYGZob{}name\PYGZcb{}
\end{sphinxVerbatim}

Action is \sphinxcode{\sphinxupquote{detach}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} mirror \PYGZob{}client\PYGZus{}id\PYGZcb{}; port del \PYGZob{}port\PYGZcb{} \PYGZob{}dir\PYGZcb{} \PYGZob{}name\PYGZcb{}
\end{sphinxVerbatim}


\section{spp\_pcap}
\label{\detokenize{api_ref/spp_pcap:spp-pcap}}\label{\detokenize{api_ref/spp_pcap:spp-ctl-rest-api-spp-pcap}}\label{\detokenize{api_ref/spp_pcap::doc}}

\subsection{GET /v1/pcaps/\{client\_id\}}
\label{\detokenize{api_ref/spp_pcap:get-v1-pcaps-client-id}}
Get the information of the \sphinxcode{\sphinxupquote{spp\_pcap}} process.
\begin{itemize}
\item {} 
Normal response codes: 200

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_pcap:request-path}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request parameter for getting spp\_pcap info.}\label{\detokenize{api_ref/spp_pcap:id9}}\label{\detokenize{api_ref/spp_pcap:table-spp-ctl-pcap-get}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_pcap:request-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X GET \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/pcaps/1
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_pcap:response}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Response params of getting spp\_pcap.}\label{\detokenize{api_ref/spp_pcap:id10}}\label{\detokenize{api_ref/spp_pcap:table-spp-ctl-spp-pcap-res}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client-id
&
integer
&
client id.
\\
\hline
status
&
string
&
status of the process. “running” or “idle”.
\\
\hline
core
&
array
&
an array of core objects in the process.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Core objects:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Core objects of getting spp\_pcap.}\label{\detokenize{api_ref/spp_pcap:id11}}\label{\detokenize{api_ref/spp_pcap:table-spp-ctl-spp-pcap-res-core}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
core
&
integer
&
core id
\\
\hline
role
&
string
&
role of the task running on the core. “receive” or “write”.
\\
\hline
rx\_port
&
array
&
an array of port object for caputure. This member exists if role is
“recieve”. Note that there is only a port object in the array.
\\
\hline
filename
&
string
&
a path name of output file. This member exists if role is “write”.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

There is only a port object in the array.

Port object:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Port objects of getting spp\_pcap.}\label{\detokenize{api_ref/spp_pcap:id12}}\label{\detokenize{api_ref/spp_pcap:table-spp-ctl-spp-pcap-res-port}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
port
&
string
&
port id. port id is the form \{interface\_type\}:\{interface\_id\}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Response example}
\label{\detokenize{api_ref/spp_pcap:response-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{p}{\PYGZob{}}
  \PYG{n+nt}{\PYGZdq{}client\PYGZhy{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}status\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}running\PYGZdq{}}\PYG{p}{,}
  \PYG{n+nt}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}role\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}receive\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rx\PYGZus{}port\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}port\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}phy:0\PYGZdq{}}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}role\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}write\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}filename\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}/tmp/spp\PYGZus{}pcap.20181108110600.ring0.1.2.pcap\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_pcap:equivalent-cli-command}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap \PYGZob{}client\PYGZus{}id\PYGZcb{}; status
\end{sphinxVerbatim}


\subsection{PUT /v1/pcaps/\{client\_id\}/capture}
\label{\detokenize{api_ref/spp_pcap:put-v1-pcaps-client-id-capture}}
Start or Stop capturing.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_pcap:id1}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request params of capture of spp\_pcap.}\label{\detokenize{api_ref/spp_pcap:id13}}\label{\detokenize{api_ref/spp_pcap:table-spp-ctl-spp-pcap-capture}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request (body)}
\label{\detokenize{api_ref/spp_pcap:request-body}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request body params of capture of spp\_pcap.}\label{\detokenize{api_ref/spp_pcap:id14}}\label{\detokenize{api_ref/spp_pcap:table-spp-ctl-spp-pcap-capture-body}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
action
&
string
&
\sphinxcode{\sphinxupquote{start}} or \sphinxcode{\sphinxupquote{stop}}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_pcap:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X PUT \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}start\PYGZdq{}\PYGZcb{}\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/pcaps/1/capture
\end{sphinxVerbatim}


\subsubsection{Response}
\label{\detokenize{api_ref/spp_pcap:id3}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{PUT}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_pcap:id4}}
Action is \sphinxcode{\sphinxupquote{start}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap \PYGZob{}client\PYGZus{}id\PYGZcb{}; start
\end{sphinxVerbatim}

Action is \sphinxcode{\sphinxupquote{stop}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap \PYGZob{}client\PYGZus{}id\PYGZcb{}; stop
\end{sphinxVerbatim}


\subsection{DELETE /v1/pcaps/\{client\_id\}}
\label{\detokenize{api_ref/spp_pcap:delete-v1-pcaps-client-id}}
Terminate \sphinxcode{\sphinxupquote{spp\_pcap}} process.
\begin{itemize}
\item {} 
Normal response codes: 204

\item {} 
Error response codes: 400, 404

\end{itemize}


\subsubsection{Request (path)}
\label{\detokenize{api_ref/spp_pcap:id5}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Request parameter for terminating spp\_pcap.}\label{\detokenize{api_ref/spp_pcap:id15}}\label{\detokenize{api_ref/spp_pcap:table-spp-ctl-pcap-delete}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
client\_id
&
integer
&
client id.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Request example}
\label{\detokenize{api_ref/spp_pcap:id6}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{\PYGZdl{}} curl \PYGZhy{}X DELETE \PYGZhy{}H \PYG{l+s+s1}{\PYGZsq{}application/json\PYGZsq{}} \PYG{l+s+se}{\PYGZbs{}}
  http://127.0.0.1:7777/v1/pcaps/1
\end{sphinxVerbatim}


\subsubsection{Response example}
\label{\detokenize{api_ref/spp_pcap:id7}}
There is no body content for the response of a successful \sphinxcode{\sphinxupquote{DELETE}} request.


\subsubsection{Equivalent CLI command}
\label{\detokenize{api_ref/spp_pcap:id8}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
spp \PYGZgt{} pcap \PYGZob{}client\PYGZus{}id\PYGZcb{}; exit
\end{sphinxVerbatim}

This documentation is the latest tagged version, but some of the latest
developing features might be not included.
All of features not included in this documentation is described in the
developing version of
\sphinxhref{https://spp.readthedocs.io/en/latest/}{SPP documentation}.



\renewcommand{\indexname}{Index}
\printindex
\end{document}